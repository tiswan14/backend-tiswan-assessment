
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for src/generated/prisma/runtime/wasm-compiler-edge.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../index.html">All files</a> / <a href="index.html">src/generated/prisma/runtime</a> wasm-compiler-edge.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/6114</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/3715</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/1342</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/26</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a>
<a name='L56'></a><a href='#L56'>56</a>
<a name='L57'></a><a href='#L57'>57</a>
<a name='L58'></a><a href='#L58'>58</a>
<a name='L59'></a><a href='#L59'>59</a>
<a name='L60'></a><a href='#L60'>60</a>
<a name='L61'></a><a href='#L61'>61</a>
<a name='L62'></a><a href='#L62'>62</a>
<a name='L63'></a><a href='#L63'>63</a>
<a name='L64'></a><a href='#L64'>64</a>
<a name='L65'></a><a href='#L65'>65</a>
<a name='L66'></a><a href='#L66'>66</a>
<a name='L67'></a><a href='#L67'>67</a>
<a name='L68'></a><a href='#L68'>68</a>
<a name='L69'></a><a href='#L69'>69</a>
<a name='L70'></a><a href='#L70'>70</a>
<a name='L71'></a><a href='#L71'>71</a>
<a name='L72'></a><a href='#L72'>72</a>
<a name='L73'></a><a href='#L73'>73</a>
<a name='L74'></a><a href='#L74'>74</a>
<a name='L75'></a><a href='#L75'>75</a>
<a name='L76'></a><a href='#L76'>76</a>
<a name='L77'></a><a href='#L77'>77</a>
<a name='L78'></a><a href='#L78'>78</a>
<a name='L79'></a><a href='#L79'>79</a>
<a name='L80'></a><a href='#L80'>80</a>
<a name='L81'></a><a href='#L81'>81</a>
<a name='L82'></a><a href='#L82'>82</a>
<a name='L83'></a><a href='#L83'>83</a>
<a name='L84'></a><a href='#L84'>84</a>
<a name='L85'></a><a href='#L85'>85</a></td><td class="line-coverage quiet"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">&nbsp;
/* !!! This is code generated by Prisma. Do not edit directly. !!!
/* eslint-disable */
"use strict";var iu=<span class="cstat-no" title="statement not covered" >Object.create;</span>var Kr=<span class="cstat-no" title="statement not covered" >Object.defineProperty;</span>var ou=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyDescriptor;</span>var su=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyNames;</span>var au=<span class="cstat-no" title="statement not covered" >Object.getPrototypeOf,</span>lu=<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty;</span>var ye=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >e&amp;&amp;(t=e(e=0)),t)</span>;</span></span>var me=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >t||e((t={exports:{}}).exports,t),t.exports)</span>,</span></span>pt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >for(var r in t)<span class="cstat-no" title="statement not covered" >Kr(e,r,{get:t[r],enumerable:!0})}</span></span>,</span>Vo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r,n)=&gt;{<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;typeof t=="object"||typeof t=="function")<span class="cstat-no" title="statement not covered" >for(let i of su(t))<span class="cstat-no" title="statement not covered" >!lu.call(e,i)&amp;&amp;i!==r&amp;&amp;Kr(e,i,{get:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t[i],</span>enumerable:!(n=ou(t,i))||n.enumerable});<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn e}</span>;</span>var $e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;(<span class="cstat-no" title="statement not covered" >r=e!=null?iu(au(e)):{},Vo(t||!e||!e.__esModule?Kr(r,"default",{value:e,enumerable:!0}):r,e))</span>,</span>qo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >Vo(Kr({},"__esModule",{value:!0}),e);</span></span>function <span class="fstat-no" title="function not covered" >ui(</span>e,t){<span class="cstat-no" title="statement not covered" >if(t=t.toLowerCase(),t==="utf8"||t==="utf-8")<span class="cstat-no" title="statement not covered" >return new h(mu.encode(e));<span class="cstat-no" title="statement not covered" >i</span></span>f(t==="base64"||t==="base64url")<span class="cstat-no" title="statement not covered" >return e=e.replace(/-/g,"+").replace(/_/g,"/"),e=e.replace(/[^A-Za-z0-9+/]/g,""),new h([...atob(e)].map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r.charCodeAt(0))</span>);<span class="cstat-no" title="statement not covered" >i</span></span>f(t==="binary"||t==="ascii"||t==="latin1"||t==="latin-1")<span class="cstat-no" title="statement not covered" >return new h([...e].map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r.charCodeAt(0))</span>);<span class="cstat-no" title="statement not covered" >i</span></span>f(t==="ucs2"||t==="ucs-2"||t==="utf16le"||t==="utf-16le"){let r=<span class="cstat-no" title="statement not covered" >new h(e.length*2),</span>n=<span class="cstat-no" title="statement not covered" >new DataView(r.buffer);<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;e.length;i++)<span class="cstat-no" title="statement not covered" >n.setUint16(i*2,e.charCodeAt(i),!0);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t==="hex"){let r=<span class="cstat-no" title="statement not covered" >new h(e.length/2);<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;e.length;i+=2,n++)<span class="cstat-no" title="statement not covered" >r[n]=parseInt(e.slice(i,i+2),16);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}<span class="cstat-no" title="statement not covered" ></span>j</span>o(`encoding "${t}"`)}</span>function <span class="fstat-no" title="function not covered" >cu(</span>e){let r=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyNames(DataView.prototype).filter(<span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >a.startsWith("get")||a.startsWith("set"))</span>,</span>n=<span class="cstat-no" title="statement not covered" >r.map(<span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >a.replace("get","read").replace("set","write"))</span>,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(a</span>,f)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(w=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return Y(w,"offset"),de(w,"offset"),ee(w,"offset",this.length-1),new DataView(this.buffer)[r[a]](w,f)}</span>,</span></span>o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(a</span>,f)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(w,A=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{let R=<span class="cstat-no" title="statement not covered" >r[a].match(/set(\w+\d+)/)[1].toLowerCase(),</span>S=<span class="cstat-no" title="statement not covered" >pu[R];<span class="cstat-no" title="statement not covered" ></span>return Y(A,"offset"),de(A,"offset"),ee(A,"offset",this.length-1),uu(w,"value",S[0],S[1]),new DataView(this.buffer)[r[a]](A,w,f),A+parseInt(r[a].match(/\d+/)[0])/8}</span>,</span></span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >a=</span>&gt;{<span class="cstat-no" title="statement not covered" >a.forEach(<span class="fstat-no" title="function not covered" >f=</span>&gt;{<span class="cstat-no" title="statement not covered" >f.includes("Uint")&amp;&amp;(e[f.replace("Uint","UInt")]=e[f]),f.includes("Float64")&amp;&amp;(e[f.replace("Float64","Double")]=e[f]),f.includes("Float32")&amp;&amp;(e[f.replace("Float32","Float")]=e[f])}</span>)}</span>;<span class="cstat-no" title="statement not covered" ></span>n.forEach(<span class="fstat-no" title="function not covered" >(a</span>,f)=&gt;{<span class="cstat-no" title="statement not covered" >a.startsWith("read")&amp;&amp;(e[a]=i(f,!1),e[a+"LE"]=i(f,!0),e[a+"BE"]=i(f,!1)),a.startsWith("write")&amp;&amp;(e[a]=o(f,!1),e[a+"LE"]=o(f,!0),e[a+"BE"]=o(f,!1)),s([a,a+"LE",a+"BE"])}</span>)}</span>function <span class="fstat-no" title="function not covered" >jo(</span>e){<span class="cstat-no" title="statement not covered" >throw new Error(`Buffer polyfill does not implement "${e}"`)}</span>function <span class="fstat-no" title="function not covered" >zr(</span>e,t){<span class="cstat-no" title="statement not covered" >if(!(e instanceof Uint8Array))<span class="cstat-no" title="statement not covered" >throw new TypeError(`The "${t}" argument must be an instance of Buffer or Uint8Array`)}</span></span>function <span class="fstat-no" title="function not covered" >ee(</span>e,t,r=<span class="branch-0 cbranch-no" title="branch not covered" >gu+1)</span>{<span class="cstat-no" title="statement not covered" >if(e&lt;0||e&gt;r){let n=<span class="cstat-no" title="statement not covered" >new RangeError(`The value of "${t}" is out of range. It must be &gt;= 0 &amp;&amp; &lt;= ${r}. Received ${e}`);<span class="cstat-no" title="statement not covered" ></span>throw n.code="ERR_OUT_OF_RANGE",n}</span>}</span>function <span class="fstat-no" title="function not covered" >Y(</span>e,t){<span class="cstat-no" title="statement not covered" >if(typeof e!="number"){let r=<span class="cstat-no" title="statement not covered" >new TypeError(`The "${t}" argument must be of type number. Received type ${typeof e}.`);<span class="cstat-no" title="statement not covered" ></span>throw r.code="ERR_INVALID_ARG_TYPE",r}</span>}</span>function <span class="fstat-no" title="function not covered" >de(</span>e,t){<span class="cstat-no" title="statement not covered" >if(!Number.isInteger(e)||Number.isNaN(e)){let r=<span class="cstat-no" title="statement not covered" >new RangeError(`The value of "${t}" is out of range. It must be an integer. Received ${e}`);<span class="cstat-no" title="statement not covered" ></span>throw r.code="ERR_OUT_OF_RANGE",r}</span>}</span>function <span class="fstat-no" title="function not covered" >uu(</span>e,t,r,n){<span class="cstat-no" title="statement not covered" >if(e&lt;r||e&gt;n){let i=<span class="cstat-no" title="statement not covered" >new RangeError(`The value of "${t}" is out of range. It must be &gt;= ${r} and &lt;= ${n}. Received ${e}`);<span class="cstat-no" title="statement not covered" ></span>throw i.code="ERR_OUT_OF_RANGE",i}</span>}</span>function <span class="fstat-no" title="function not covered" >Bo(</span>e,t){<span class="cstat-no" title="statement not covered" >if(typeof e!="string"){let r=<span class="cstat-no" title="statement not covered" >new TypeError(`The "${t}" argument must be of type string. Received type ${typeof e}`);<span class="cstat-no" title="statement not covered" ></span>throw r.code="ERR_INVALID_ARG_TYPE",r}</span>}</span>function <span class="fstat-no" title="function not covered" >yu(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >"utf8")</span>{<span class="cstat-no" title="statement not covered" >return h.from(e,t)}</span>var h,pu,mu,du,fu,gu,y,pi,c=<span class="cstat-no" title="statement not covered" >ye(<span class="fstat-no" title="function not covered" >()</span>=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >h=class e extends Uint8Array{_isBuffer=<span class="cstat-no" title="statement not covered" >!0;<span class="fstat-no" title="function not covered" ></span>ge</span>t offset(){<span class="cstat-no" title="statement not covered" >return this.byteOffset}<span class="fstat-no" title="function not covered" ></span>st</span>atic alloc(t,r=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >"utf8")</span>{<span class="cstat-no" title="statement not covered" >return Bo(n,"encoding"),e.allocUnsafe(t).fill(r,n)}<span class="fstat-no" title="function not covered" ></span>st</span>atic allocUnsafe(t){<span class="cstat-no" title="statement not covered" >return e.from(t)}<span class="fstat-no" title="function not covered" ></span>st</span>atic allocUnsafeSlow(t){<span class="cstat-no" title="statement not covered" >return e.from(t)}<span class="fstat-no" title="function not covered" ></span>st</span>atic isBuffer(t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;!!t._isBuffer}<span class="fstat-no" title="function not covered" ></span>st</span>atic byteLength(t,r=<span class="branch-0 cbranch-no" title="branch not covered" >"utf8")</span>{<span class="cstat-no" title="statement not covered" >if(typeof t=="string")<span class="cstat-no" title="statement not covered" >return ui(t,r).byteLength;<span class="cstat-no" title="statement not covered" >i</span></span>f(t&amp;&amp;t.byteLength)<span class="cstat-no" title="statement not covered" >return t.byteLength;l</span></span>et n=<span class="cstat-no" title="statement not covered" >new TypeError('The "string" argument must be of type string or an instance of Buffer or ArrayBuffer.');<span class="cstat-no" title="statement not covered" ></span>throw n.code="ERR_INVALID_ARG_TYPE",n}<span class="fstat-no" title="function not covered" ></span>st</span>atic isEncoding(t){<span class="cstat-no" title="statement not covered" >return fu.includes(t)}<span class="fstat-no" title="function not covered" ></span>st</span>atic compare(t,r){<span class="cstat-no" title="statement not covered" >zr(t,"buff1"),zr(r,"buff2");<span class="cstat-no" title="statement not covered" >f</span>or(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.length;n++){<span class="cstat-no" title="statement not covered" >if(t[n]&lt;r[n])<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >i</span></span>f(t[n]&gt;r[n])<span class="cstat-no" title="statement not covered" >return 1}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn t.length===r.length?0:t.length&gt;r.length?1:-1}<span class="fstat-no" title="function not covered" ></span>st</span>atic from(t,r=<span class="branch-0 cbranch-no" title="branch not covered" >"utf8")</span>{<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;typeof t=="object"&amp;&amp;t.type==="Buffer")<span class="cstat-no" title="statement not covered" >return new e(t.data);<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof t=="number")<span class="cstat-no" title="statement not covered" >return new e(new Uint8Array(t));<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof t=="string")<span class="cstat-no" title="statement not covered" >return ui(t,r);<span class="cstat-no" title="statement not covered" >i</span></span>f(ArrayBuffer.isView(t)){let{byteOffset:n,byteLength:i,buffer:o}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return"map"in t&amp;&amp;typeof t.map=="function"?new e(t.map(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >s%256)</span>,n,i):new e(o,n,i)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t&amp;&amp;typeof t=="object"&amp;&amp;("length"in t||"byteLength"in t||"buffer"in t))<span class="cstat-no" title="statement not covered" >return new e(t);<span class="cstat-no" title="statement not covered" >t</span></span>hrow new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}<span class="fstat-no" title="function not covered" ></span>st</span>atic concat(t,r){<span class="cstat-no" title="statement not covered" >if(t.length===0)<span class="cstat-no" title="statement not covered" >return e.alloc(0);l</span></span>et n=<span class="cstat-no" title="statement not covered" >[].concat(...t.map(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >[...o])</span>),</span>i=<span class="cstat-no" title="statement not covered" >e.alloc(r!==void 0?r:n.length);<span class="cstat-no" title="statement not covered" ></span>return i.set(r!==void 0?n.slice(0,r):n),i}<span class="fstat-no" title="function not covered" ></span>sl</span>ice(t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >this.length)</span>{<span class="cstat-no" title="statement not covered" >return this.subarray(t,r)}<span class="fstat-no" title="function not covered" ></span>su</span>barray(t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >this.length)</span>{<span class="cstat-no" title="statement not covered" >return Object.setPrototypeOf(super.subarray(t,r),e.prototype)}<span class="fstat-no" title="function not covered" ></span>re</span>verse(){<span class="cstat-no" title="statement not covered" >return super.reverse(),this}<span class="fstat-no" title="function not covered" ></span>re</span>adIntBE(t,r){<span class="cstat-no" title="statement not covered" >Y(t,"offset"),de(t,"offset"),ee(t,"offset",this.length-1),Y(r,"byteLength"),de(r,"byteLength");l</span>et n=<span class="cstat-no" title="statement not covered" >new DataView(this.buffer,t,r),</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;r;o++)<span class="cstat-no" title="statement not covered" >i=i*256+n.getUint8(o);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.getUint8(0)&amp;128&amp;&amp;(i-=Math.pow(256,r)),i}<span class="fstat-no" title="function not covered" ></span>re</span>adIntLE(t,r){<span class="cstat-no" title="statement not covered" >Y(t,"offset"),de(t,"offset"),ee(t,"offset",this.length-1),Y(r,"byteLength"),de(r,"byteLength");l</span>et n=<span class="cstat-no" title="statement not covered" >new DataView(this.buffer,t,r),</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;r;o++)<span class="cstat-no" title="statement not covered" >i+=n.getUint8(o)*Math.pow(256,o);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.getUint8(r-1)&amp;128&amp;&amp;(i-=Math.pow(256,r)),i}<span class="fstat-no" title="function not covered" ></span>re</span>adUIntBE(t,r){<span class="cstat-no" title="statement not covered" >Y(t,"offset"),de(t,"offset"),ee(t,"offset",this.length-1),Y(r,"byteLength"),de(r,"byteLength");l</span>et n=<span class="cstat-no" title="statement not covered" >new DataView(this.buffer,t,r),</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;r;o++)<span class="cstat-no" title="statement not covered" >i=i*256+n.getUint8(o);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}<span class="fstat-no" title="function not covered" ></span>re</span>adUintBE(t,r){<span class="cstat-no" title="statement not covered" >return this.readUIntBE(t,r)}<span class="fstat-no" title="function not covered" ></span>re</span>adUIntLE(t,r){<span class="cstat-no" title="statement not covered" >Y(t,"offset"),de(t,"offset"),ee(t,"offset",this.length-1),Y(r,"byteLength"),de(r,"byteLength");l</span>et n=<span class="cstat-no" title="statement not covered" >new DataView(this.buffer,t,r),</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;r;o++)<span class="cstat-no" title="statement not covered" >i+=n.getUint8(o)*Math.pow(256,o);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}<span class="fstat-no" title="function not covered" ></span>re</span>adUintLE(t,r){<span class="cstat-no" title="statement not covered" >return this.readUIntLE(t,r)}<span class="fstat-no" title="function not covered" ></span>wr</span>iteIntBE(t,r,n){<span class="cstat-no" title="statement not covered" >return t=t&lt;0?t+Math.pow(256,n):t,this.writeUIntBE(t,r,n)}<span class="fstat-no" title="function not covered" ></span>wr</span>iteIntLE(t,r,n){<span class="cstat-no" title="statement not covered" >return t=t&lt;0?t+Math.pow(256,n):t,this.writeUIntLE(t,r,n)}<span class="fstat-no" title="function not covered" ></span>wr</span>iteUIntBE(t,r,n){<span class="cstat-no" title="statement not covered" >Y(r,"offset"),de(r,"offset"),ee(r,"offset",this.length-1),Y(n,"byteLength"),de(n,"byteLength");l</span>et i=<span class="cstat-no" title="statement not covered" >new DataView(this.buffer,r,n);<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >n-1;</span>o&gt;=0;o--)<span class="cstat-no" title="statement not covered" >i.setUint8(o,t&amp;255),t=t/256;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r+n}<span class="fstat-no" title="function not covered" ></span>wr</span>iteUintBE(t,r,n){<span class="cstat-no" title="statement not covered" >return this.writeUIntBE(t,r,n)}<span class="fstat-no" title="function not covered" ></span>wr</span>iteUIntLE(t,r,n){<span class="cstat-no" title="statement not covered" >Y(r,"offset"),de(r,"offset"),ee(r,"offset",this.length-1),Y(n,"byteLength"),de(n,"byteLength");l</span>et i=<span class="cstat-no" title="statement not covered" >new DataView(this.buffer,r,n);<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;n;o++)<span class="cstat-no" title="statement not covered" >i.setUint8(o,t&amp;255),t=t/256;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r+n}<span class="fstat-no" title="function not covered" ></span>wr</span>iteUintLE(t,r,n){<span class="cstat-no" title="statement not covered" >return this.writeUIntLE(t,r,n)}<span class="fstat-no" title="function not covered" ></span>to</span>JSON(){<span class="cstat-no" title="statement not covered" >return{type:"Buffer",data:Array.from(this)}}<span class="fstat-no" title="function not covered" ></span>sw</span>ap16(){let t=<span class="cstat-no" title="statement not covered" >new DataView(this.buffer,this.byteOffset,this.byteLength);<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;this.length;r+=2)<span class="cstat-no" title="statement not covered" >t.setUint16(r,t.getUint16(r,!0),!1);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}<span class="fstat-no" title="function not covered" ></span>sw</span>ap32(){let t=<span class="cstat-no" title="statement not covered" >new DataView(this.buffer,this.byteOffset,this.byteLength);<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;this.length;r+=4)<span class="cstat-no" title="statement not covered" >t.setUint32(r,t.getUint32(r,!0),!1);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}<span class="fstat-no" title="function not covered" ></span>sw</span>ap64(){let t=<span class="cstat-no" title="statement not covered" >new DataView(this.buffer,this.byteOffset,this.byteLength);<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;this.length;r+=8)<span class="cstat-no" title="statement not covered" >t.setBigUint64(r,t.getBigUint64(r,!0),!1);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}<span class="fstat-no" title="function not covered" ></span>co</span>mpare(t,r=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >t.length,</span>i=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>o=<span class="branch-0 cbranch-no" title="branch not covered" >this.length)</span>{<span class="cstat-no" title="statement not covered" >return zr(t,"target"),Y(r,"targetStart"),Y(n,"targetEnd"),Y(i,"sourceStart"),Y(o,"sourceEnd"),ee(r,"targetStart"),ee(n,"targetEnd",t.length),ee(i,"sourceStart"),ee(o,"sourceEnd",this.length),e.compare(this.slice(i,o),t.slice(r,n))}<span class="fstat-no" title="function not covered" ></span>eq</span>uals(t){<span class="cstat-no" title="statement not covered" >return zr(t,"otherBuffer"),this.length===t.length&amp;&amp;this.every(<span class="fstat-no" title="function not covered" >(r</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >r===t[n])</span>}<span class="fstat-no" title="function not covered" ></span>co</span>py(t,r=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>i=<span class="branch-0 cbranch-no" title="branch not covered" >this.length)</span>{<span class="cstat-no" title="statement not covered" >ee(r,"targetStart"),ee(n,"sourceStart",this.length),ee(i,"sourceEnd"),r&gt;&gt;&gt;=0,n&gt;&gt;&gt;=0,i&gt;&gt;&gt;=0;l</span>et o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;n&lt;i&amp;&amp;!(this[n]===void 0||t[r]===void 0);)<span class="cstat-no" title="statement not covered" >t[r]=this[n],o++,n++,r++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn o}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(t,r,n,i=<span class="branch-0 cbranch-no" title="branch not covered" >"utf8")</span>{let o=<span class="cstat-no" title="statement not covered" >typeof r=="string"?0:r??0,</span>s=<span class="cstat-no" title="statement not covered" >typeof n=="string"?this.length-o:n??this.length-o;<span class="cstat-no" title="statement not covered" ></span>return i=typeof r=="string"?r:typeof n=="string"?n:i,Y(o,"offset"),Y(s,"length"),ee(o,"offset",this.length),ee(s,"length",this.length),(i==="ucs2"||i==="ucs-2"||i==="utf16le"||i==="utf-16le")&amp;&amp;(s=s-s%2),ui(t,i).copy(this,o,0,s)}<span class="fstat-no" title="function not covered" ></span>fi</span>ll(t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >this.length,</span>i=<span class="branch-0 cbranch-no" title="branch not covered" >"utf-8")</span>{let o=<span class="cstat-no" title="statement not covered" >typeof r=="string"?0:r,</span>s=<span class="cstat-no" title="statement not covered" >typeof n=="string"?this.length:n;<span class="cstat-no" title="statement not covered" ></span>if(i=typeof r=="string"?r:typeof n=="string"?n:i,t=e.from(typeof t=="number"?[t]:t??[],i),Bo(i,"encoding"),ee(o,"offset",this.length),ee(s,"end",this.length),t.length!==0)<span class="cstat-no" title="statement not covered" >for(let a=<span class="cstat-no" title="statement not covered" >o;</span>a&lt;s;a+=t.length)<span class="cstat-no" title="statement not covered" >super.set(t.slice(0,t.length+a&gt;=this.length?this.length-a:t.length),a);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn this}<span class="fstat-no" title="function not covered" ></span>in</span>cludes(t,r=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >"utf-8")</span>{<span class="cstat-no" title="statement not covered" >return this.indexOf(t,r,n)!==-1}<span class="fstat-no" title="function not covered" ></span>la</span>stIndexOf(t,r=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >"utf-8")</span>{<span class="cstat-no" title="statement not covered" >return this.indexOf(t,r,n,!0)}<span class="fstat-no" title="function not covered" ></span>in</span>dexOf(t,r=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >"utf-8",</span>i=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{let o=<span class="cstat-no" title="statement not covered" >i?this.findLastIndex.bind(this):this.findIndex.bind(this);<span class="cstat-no" title="statement not covered" ></span>n=typeof r=="string"?r:n;l</span>et s=<span class="cstat-no" title="statement not covered" >e.from(typeof t=="number"?[t]:t,n),</span>a=<span class="cstat-no" title="statement not covered" >typeof r=="string"?0:r;<span class="cstat-no" title="statement not covered" ></span>return a=typeof r=="number"?a:null,a=Number.isNaN(a)?null:a,a??=i?this.length:0,a=a&lt;0?this.length+a:a,s.length===0&amp;&amp;i===!1?a&gt;=this.length?this.length:a:s.length===0&amp;&amp;i===!0?(a&gt;=this.length?this.length:a)||this.length:o(<span class="fstat-no" title="function not covered" >(f</span>,w)=&gt;<span class="cstat-no" title="statement not covered" >(i?w&lt;=a:w&gt;=a)&amp;&amp;this[w]===s[0]&amp;&amp;s.every(<span class="fstat-no" title="function not covered" >(R</span>,S)=&gt;<span class="cstat-no" title="statement not covered" >this[w+S]===R)</span>)</span>}<span class="fstat-no" title="function not covered" ></span>to</span>String(t=<span class="branch-0 cbranch-no" title="branch not covered" >"utf8",</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >this.length)</span>{<span class="cstat-no" title="statement not covered" >if(r=r&lt;0?0:r,t=t.toString().toLowerCase(),n&lt;=0)<span class="cstat-no" title="statement not covered" >return"";<span class="cstat-no" title="statement not covered" >i</span></span>f(t==="utf8"||t==="utf-8")<span class="cstat-no" title="statement not covered" >return du.decode(this.slice(r,n));<span class="cstat-no" title="statement not covered" >i</span></span>f(t==="base64"||t==="base64url"){let i=<span class="cstat-no" title="statement not covered" >btoa(this.reduce(<span class="fstat-no" title="function not covered" >(o</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >o+pi(s),</span>""));<span class="cstat-no" title="statement not covered" ></span>return t==="base64url"?i.replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,""):i}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t==="binary"||t==="ascii"||t==="latin1"||t==="latin-1")<span class="cstat-no" title="statement not covered" >return this.slice(r,n).reduce(<span class="fstat-no" title="function not covered" >(i</span>,o)=&gt;<span class="cstat-no" title="statement not covered" >i+pi(o&amp;(t==="ascii"?127:255)),</span>"");<span class="cstat-no" title="statement not covered" >i</span></span>f(t==="ucs2"||t==="ucs-2"||t==="utf16le"||t==="utf-16le"){let i=<span class="cstat-no" title="statement not covered" >new DataView(this.buffer.slice(r,n));<span class="cstat-no" title="statement not covered" ></span>return Array.from({length:i.byteLength/2},<span class="fstat-no" title="function not covered" >(o</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >s*2+1&lt;i.byteLength?pi(i.getUint16(s*2,!0)):"")</span>.join("")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t==="hex")<span class="cstat-no" title="statement not covered" >return this.slice(r,n).reduce(<span class="fstat-no" title="function not covered" >(i</span>,o)=&gt;<span class="cstat-no" title="statement not covered" >i+o.toString(16).padStart(2,"0"),</span>"");<span class="cstat-no" title="statement not covered" >j</span></span>o(`encoding "${t}"`)}<span class="fstat-no" title="function not covered" ></span>to</span>LocaleString(){<span class="cstat-no" title="statement not covered" >return this.toString()}<span class="fstat-no" title="function not covered" ></span>in</span>spect(){<span class="cstat-no" title="statement not covered" >return`&lt;Buffer ${this.toString("hex").match(/.{1,2}/g).join(" ")}&gt;`}</span>};<span class="cstat-no" title="statement not covered" >p</span>u={int8:[-128,127],int16:[-32768,32767],int32:[-2147483648,2147483647],uint8:[0,255],uint16:[0,65535],uint32:[0,4294967295],float32:[-1/0,1/0],float64:[-1/0,1/0],bigint64:[-0x8000000000000000n,0x7fffffffffffffffn],biguint64:[0n,0xffffffffffffffffn]},mu=new TextEncoder,du=new TextDecoder,fu=["utf8","utf-8","hex","base64","ascii","binary","base64url","ucs2","ucs-2","utf16le","utf-16le","latin1","latin-1"],gu=4294967295;<span class="cstat-no" title="statement not covered" >c</span>u(h.prototype);<span class="cstat-no" title="statement not covered" >y</span>=new Proxy(yu,{<span class="fstat-no" title="function not covered" >co</span>nstruct(e,[t,r]){<span class="cstat-no" title="statement not covered" >return h.from(t,r)}</span>,<span class="fstat-no" title="function not covered" >ge</span>t(e,t){<span class="cstat-no" title="statement not covered" >return h[t]}</span>}),pi=String.fromCodePoint}</span>);</span>var g,x,u=<span class="cstat-no" title="statement not covered" >ye(<span class="fstat-no" title="function not covered" >()</span>=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >g={nextTick:<span class="fstat-no" title="function not covered" >(e</span>,...t)=&gt;{<span class="cstat-no" title="statement not covered" >setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >e(...t)}</span>,0)}</span>,env:{},version:"",cwd:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >"/",</span>stderr:{},argv:["/bin/node"],pid:1e4},{cwd:x}=g}</span>);</span>var b,p=<span class="cstat-no" title="statement not covered" >ye(<span class="fstat-no" title="function not covered" >()</span>=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >b=globalThis.performance??(<span class="fstat-no" title="function not covered" >()</span>=&gt;{let e=<span class="cstat-no" title="statement not covered" >Date.now();<span class="cstat-no" title="statement not covered" ></span>return{now:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Date.now()-e}</span>}</span>)()}</span>);</span>var E,m=<span class="cstat-no" title="statement not covered" >ye(<span class="fstat-no" title="function not covered" >()</span>=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >E=<span class="fstat-no" title="function not covered" >()</span>=&gt;{};<span class="cstat-no" title="statement not covered" >E</span>.prototype=E}</span>);</span>var d=<span class="cstat-no" title="statement not covered" >ye(<span class="fstat-no" title="function not covered" >()</span>=&gt;{"use strict"});</span>function <span class="fstat-no" title="function not covered" >Jo(</span>e,t){var r,n,i,o,s,a,f,w,A=<span class="cstat-no" title="statement not covered" >e.constructor,</span>R=<span class="cstat-no" title="statement not covered" >A.precision;<span class="cstat-no" title="statement not covered" ></span>if(!e.s||!t.s)<span class="cstat-no" title="statement not covered" >return t.s||(t=new A(e)),W?q(t,R):t;<span class="cstat-no" title="statement not covered" >i</span></span>f(f=e.d,w=t.d,s=e.e,i=t.e,f=f.slice(),o=s-i,o){<span class="cstat-no" title="statement not covered" >for(o&lt;0?(n=f,o=-o,a=w.length):(n=w,i=s,a=f.length),s=Math.ceil(R/H),a=s&gt;a?s+1:a+1,o&gt;a&amp;&amp;(o=a,n.length=1),n.reverse();o--;)<span class="cstat-no" title="statement not covered" >n.push(0);<span class="cstat-no" title="statement not covered" >n</span></span>.reverse()}<span class="cstat-no" title="statement not covered" ></span>f</span>or(a=f.length,o=w.length,a-o&lt;0&amp;&amp;(o=a,n=w,w=f,f=n),r=0;o;)<span class="cstat-no" title="statement not covered" >r=(f[--o]=f[o]+w[o]+r)/te|0,f[o]%=te;<span class="cstat-no" title="statement not covered" >f</span></span>or(r&amp;&amp;(f.unshift(r),++i),a=f.length;f[--a]==0;)<span class="cstat-no" title="statement not covered" >f.pop();<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.d=f,t.e=i,W?q(t,R):t}</span>function <span class="fstat-no" title="function not covered" >Re(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if(e!==~~e||e&lt;t||e&gt;r)<span class="cstat-no" title="statement not covered" >throw Error(Ye+e)}</span></span>function <span class="fstat-no" title="function not covered" >Ae(</span>e){var t,r,n,i=<span class="cstat-no" title="statement not covered" >e.length-1,</span>o=<span class="cstat-no" title="statement not covered" >"",</span>s=<span class="cstat-no" title="statement not covered" >e[0];<span class="cstat-no" title="statement not covered" ></span>if(i&gt;0){<span class="cstat-no" title="statement not covered" >for(o+=s,t=1;t&lt;i;t++)<span class="cstat-no" title="statement not covered" >n=e[t]+"",r=H-n.length,r&amp;&amp;(o+=Ve(r)),o+=n;<span class="cstat-no" title="statement not covered" >s</span></span>=e[t],n=s+"",r=H-n.length,r&amp;&amp;(o+=Ve(r))}</span>else <span class="cstat-no" title="statement not covered" >if(s===0)<span class="cstat-no" title="statement not covered" >return"0";<span class="cstat-no" title="statement not covered" >f</span></span></span>or(;s%10===0;)<span class="cstat-no" title="statement not covered" >s/=10;<span class="cstat-no" title="statement not covered" >r</span></span>eturn o+s}</span>function <span class="fstat-no" title="function not covered" >Wo(</span>e,t){var r,n,i,o,s,a,f=<span class="cstat-no" title="statement not covered" >0,</span>w=<span class="cstat-no" title="statement not covered" >0,</span>A=<span class="cstat-no" title="statement not covered" >e.constructor,</span>R=<span class="cstat-no" title="statement not covered" >A.precision;<span class="cstat-no" title="statement not covered" ></span>if(Z(e)&gt;16)<span class="cstat-no" title="statement not covered" >throw Error(di+Z(e));<span class="cstat-no" title="statement not covered" >i</span></span>f(!e.s)<span class="cstat-no" title="statement not covered" >return new A(he);<span class="cstat-no" title="statement not covered" >f</span></span>or(t==null?(W=!1,a=R):a=t,s=new A(.03125);e.abs().gte(.1);)<span class="cstat-no" title="statement not covered" >e=e.times(s),w+=5;<span class="cstat-no" title="statement not covered" >f</span></span>or(n=Math.log(ze(2,w))/Math.LN10*2+5|0,a+=n,r=i=o=new A(he),A.precision=a;;){<span class="cstat-no" title="statement not covered" >if(i=q(i.times(e),a),r=r.times(++f),s=o.plus(_e(i,r,a)),Ae(s.d).slice(0,a)===Ae(o.d).slice(0,a)){<span class="cstat-no" title="statement not covered" >for(;w--;)<span class="cstat-no" title="statement not covered" >o=q(o.times(o),a);<span class="cstat-no" title="statement not covered" >r</span></span>eturn A.precision=R,t==null?(W=!0,q(o,R)):o}<span class="cstat-no" title="statement not covered" ></span>o</span>=s}</span>}</span>function <span class="fstat-no" title="function not covered" >Z(</span>e){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >e.e*H,</span>r=<span class="cstat-no" title="statement not covered" >e.d[0];</span>r&gt;=10;r/=10)<span class="cstat-no" title="statement not covered" >t++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >mi(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if(t&gt;e.LN10.sd())<span class="cstat-no" title="statement not covered" >throw W=!0,r&amp;&amp;(e.precision=r),Error(be+"LN10 precision limit exceeded");<span class="cstat-no" title="statement not covered" >r</span></span>eturn q(new e(e.LN10),t)}</span>function <span class="fstat-no" title="function not covered" >Ve(</span>e){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >"";</span>e--;)<span class="cstat-no" title="statement not covered" >t+="0";<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Kt(</span>e,t){var r,n,i,o,s,a,f,w,A,R=<span class="cstat-no" title="statement not covered" >1,</span>S=<span class="cstat-no" title="statement not covered" >10,</span>C=<span class="cstat-no" title="statement not covered" >e,</span>L=<span class="cstat-no" title="statement not covered" >C.d,</span>k=<span class="cstat-no" title="statement not covered" >C.constructor,</span>M=<span class="cstat-no" title="statement not covered" >k.precision;<span class="cstat-no" title="statement not covered" ></span>if(C.s&lt;1)<span class="cstat-no" title="statement not covered" >throw Error(be+(C.s?"NaN":"-Infinity"));<span class="cstat-no" title="statement not covered" >i</span></span>f(C.eq(he))<span class="cstat-no" title="statement not covered" >return new k(0);<span class="cstat-no" title="statement not covered" >i</span></span>f(t==null?(W=!1,w=M):w=t,C.eq(10))<span class="cstat-no" title="statement not covered" >return t==null&amp;&amp;(W=!0),mi(k,w);<span class="cstat-no" title="statement not covered" >i</span></span>f(w+=S,k.precision=w,r=Ae(L),n=r.charAt(0),o=Z(C),Math.abs(o)&lt;15e14){<span class="cstat-no" title="statement not covered" >for(;n&lt;7&amp;&amp;n!=1||n==1&amp;&amp;r.charAt(1)&gt;3;)<span class="cstat-no" title="statement not covered" >C=C.times(e),r=Ae(C.d),n=r.charAt(0),R++;<span class="cstat-no" title="statement not covered" >o</span></span>=Z(C),n&gt;1?(C=new k("0."+r),o++):C=new k(n+"."+r.slice(1))}</span>else <span class="cstat-no" title="statement not covered" >return f=mi(k,w+2,M).times(o+""),C=Kt(new k(n+"."+r.slice(1)),w-S).plus(f),k.precision=M,t==null?(W=!0,q(C,M)):C;<span class="cstat-no" title="statement not covered" >f</span></span>or(a=s=C=_e(C.minus(he),C.plus(he),w),A=q(C.times(C),w),i=3;;){<span class="cstat-no" title="statement not covered" >if(s=q(s.times(A),w),f=a.plus(_e(s,new k(i),w)),Ae(f.d).slice(0,w)===Ae(a.d).slice(0,w))<span class="cstat-no" title="statement not covered" >return a=a.times(2),o!==0&amp;&amp;(a=a.plus(mi(k,w+2,M).times(o+""))),a=_e(a,new k(R),w),k.precision=M,t==null?(W=!0,q(a,M)):a;<span class="cstat-no" title="statement not covered" >a</span></span>=f,i+=2}</span>}</span>function <span class="fstat-no" title="function not covered" >Qo(</span>e,t){var r,n,i;<span class="cstat-no" title="statement not covered" >for((r=t.indexOf("."))&gt;-1&amp;&amp;(t=t.replace(".","")),(n=t.search(/e/i))&gt;0?(r&lt;0&amp;&amp;(r=n),r+=+t.slice(n+1),t=t.substring(0,n)):r&lt;0&amp;&amp;(r=t.length),n=0;t.charCodeAt(n)===48;)<span class="cstat-no" title="statement not covered" >++n;<span class="cstat-no" title="statement not covered" >f</span></span>or(i=t.length;t.charCodeAt(i-1)===48;)<span class="cstat-no" title="statement not covered" >--i;<span class="cstat-no" title="statement not covered" >i</span></span>f(t=t.slice(n,i),t){<span class="cstat-no" title="statement not covered" >if(i-=n,r=r-n-1,e.e=dt(r/H),e.d=[],n=(r+1)%H,r&lt;0&amp;&amp;(n+=H),n&lt;i){<span class="cstat-no" title="statement not covered" >for(n&amp;&amp;e.d.push(+t.slice(0,n)),i-=H;n&lt;i;)<span class="cstat-no" title="statement not covered" >e.d.push(+t.slice(n,n+=H));<span class="cstat-no" title="statement not covered" >t</span></span>=t.slice(n),n=H-t.length}</span>else <span class="cstat-no" title="statement not covered" >n-=i;<span class="cstat-no" title="statement not covered" >f</span></span>or(;n--;)<span class="cstat-no" title="statement not covered" >t+="0";<span class="cstat-no" title="statement not covered" >i</span></span>f(e.d.push(+t),W&amp;&amp;(e.e&gt;Yr||e.e&lt;-Yr))<span class="cstat-no" title="statement not covered" >throw Error(di+r)}</span></span>else <span class="cstat-no" title="statement not covered" >e.s=0,e.e=0,e.d=[0];<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >q(</span>e,t,r){var n,i,o,s,a,f,w,A,R=<span class="cstat-no" title="statement not covered" >e.d;<span class="cstat-no" title="statement not covered" ></span>for(s=1,o=R[0];o&gt;=10;o/=10)<span class="cstat-no" title="statement not covered" >s++;<span class="cstat-no" title="statement not covered" >i</span></span>f(n=t-s,n&lt;0)<span class="cstat-no" title="statement not covered" >n+=H,i=t,w=R[A=0];e</span>lse{<span class="cstat-no" title="statement not covered" >if(A=Math.ceil((n+1)/H),o=R.length,A&gt;=o)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >f</span></span>or(w=o=R[A],s=1;o&gt;=10;o/=10)<span class="cstat-no" title="statement not covered" >s++;<span class="cstat-no" title="statement not covered" >n</span></span>%=H,i=n-H+s}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r!==void 0&amp;&amp;(o=ze(10,s-i-1),a=w/o%10|0,f=t&lt;0||R[A+1]!==void 0||w%o,f=r&lt;4?(a||f)&amp;&amp;(r==0||r==(e.s&lt;0?3:2)):a&gt;5||a==5&amp;&amp;(r==4||f||r==6&amp;&amp;(n&gt;0?i&gt;0?w/ze(10,s-i):0:R[A-1])%10&amp;1||r==(e.s&lt;0?8:7))),t&lt;1||!R[0])<span class="cstat-no" title="statement not covered" >return f?(o=Z(e),R.length=1,t=t-o-1,R[0]=ze(10,(H-t%H)%H),e.e=dt(-t/H)||0):(R.length=1,R[0]=e.e=e.s=0),e;<span class="cstat-no" title="statement not covered" >i</span></span>f(n==0?(R.length=A,o=1,A--):(R.length=A+1,o=ze(10,H-n),R[A]=i&gt;0?(w/ze(10,s-i)%ze(10,i)|0)*o:0),f)<span class="cstat-no" title="statement not covered" >for(;;)<span class="cstat-no" title="statement not covered" >if(A==0){<span class="cstat-no" title="statement not covered" >(R[0]+=o)==te&amp;&amp;(R[0]=1,++e.e);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>else{<span class="cstat-no" title="statement not covered" >if(R[A]+=o,R[A]!=te)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >R</span></span>[A--]=0,o=1}<span class="cstat-no" title="statement not covered" ></span>f</span></span></span>or(n=R.length;R[--n]===0;)<span class="cstat-no" title="statement not covered" >R.pop();<span class="cstat-no" title="statement not covered" >i</span></span>f(W&amp;&amp;(e.e&gt;Yr||e.e&lt;-Yr))<span class="cstat-no" title="statement not covered" >throw Error(di+Z(e));<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >Ko(</span>e,t){var r,n,i,o,s,a,f,w,A,R,S=<span class="cstat-no" title="statement not covered" >e.constructor,</span>C=<span class="cstat-no" title="statement not covered" >S.precision;<span class="cstat-no" title="statement not covered" ></span>if(!e.s||!t.s)<span class="cstat-no" title="statement not covered" >return t.s?t.s=-t.s:t=new S(e),W?q(t,C):t;<span class="cstat-no" title="statement not covered" >i</span></span>f(f=e.d,R=t.d,n=t.e,w=e.e,f=f.slice(),s=w-n,s){<span class="cstat-no" title="statement not covered" >for(A=s&lt;0,A?(r=f,s=-s,a=R.length):(r=R,n=w,a=f.length),i=Math.max(Math.ceil(C/H),a)+2,s&gt;i&amp;&amp;(s=i,r.length=1),r.reverse(),i=s;i--;)<span class="cstat-no" title="statement not covered" >r.push(0);<span class="cstat-no" title="statement not covered" >r</span></span>.reverse()}</span>else{<span class="cstat-no" title="statement not covered" >for(i=f.length,a=R.length,A=i&lt;a,A&amp;&amp;(a=i),i=0;i&lt;a;i++)<span class="cstat-no" title="statement not covered" >if(f[i]!=R[i]){<span class="cstat-no" title="statement not covered" >A=f[i]&lt;R[i];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>s</span></span>=0}<span class="cstat-no" title="statement not covered" ></span>f</span>or(A&amp;&amp;(r=f,f=R,R=r,t.s=-t.s),a=f.length,i=R.length-a;i&gt;0;--i)<span class="cstat-no" title="statement not covered" >f[a++]=0;<span class="cstat-no" title="statement not covered" >f</span></span>or(i=R.length;i&gt;s;){<span class="cstat-no" title="statement not covered" >if(f[--i]&lt;R[i]){<span class="cstat-no" title="statement not covered" >for(o=i;o&amp;&amp;f[--o]===0;)<span class="cstat-no" title="statement not covered" >f[o]=te-1;<span class="cstat-no" title="statement not covered" >-</span></span>-f[o],f[i]+=te}<span class="cstat-no" title="statement not covered" ></span>f</span>[i]-=R[i]}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;f[--a]===0;)<span class="cstat-no" title="statement not covered" >f.pop();<span class="cstat-no" title="statement not covered" >f</span></span>or(;f[0]===0;f.shift())<span class="cstat-no" title="statement not covered" >--n;<span class="cstat-no" title="statement not covered" >r</span></span>eturn f[0]?(t.d=f,t.e=n,W?q(t,C):t):new S(0)}</span>function <span class="fstat-no" title="function not covered" >Ze(</span>e,t,r){var n,i=<span class="cstat-no" title="statement not covered" >Z(e),</span>o=<span class="cstat-no" title="statement not covered" >Ae(e.d),</span>s=<span class="cstat-no" title="statement not covered" >o.length;<span class="cstat-no" title="statement not covered" ></span>return t?(r&amp;&amp;(n=r-s)&gt;0?o=o.charAt(0)+"."+o.slice(1)+Ve(n):s&gt;1&amp;&amp;(o=o.charAt(0)+"."+o.slice(1)),o=o+(i&lt;0?"e":"e+")+i):i&lt;0?(o="0."+Ve(-i-1)+o,r&amp;&amp;(n=r-s)&gt;0&amp;&amp;(o+=Ve(n))):i&gt;=s?(o+=Ve(i+1-s),r&amp;&amp;(n=r-i-1)&gt;0&amp;&amp;(o=o+"."+Ve(n))):((n=i+1)&lt;s&amp;&amp;(o=o.slice(0,n)+"."+o.slice(n)),r&amp;&amp;(n=r-s)&gt;0&amp;&amp;(i+1===s&amp;&amp;(o+="."),o+=Ve(n))),e.s&lt;0?"-"+o:o}</span>function <span class="fstat-no" title="function not covered" >Ho(</span>e,t){<span class="cstat-no" title="statement not covered" >if(e.length&gt;t)<span class="cstat-no" title="statement not covered" >return e.length=t,!0}</span></span>function <span class="fstat-no" title="function not covered" >zo(</span>e){var t,r,n;function <span class="fstat-no" title="function not covered" >i(</span>o){var s=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(!(s instanceof i))<span class="cstat-no" title="statement not covered" >return new i(o);<span class="cstat-no" title="statement not covered" >i</span></span>f(s.constructor=i,o instanceof i){<span class="cstat-no" title="statement not covered" >s.s=o.s,s.e=o.e,s.d=(o=o.d)?o.slice():o;<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof o=="number"){<span class="cstat-no" title="statement not covered" >if(o*0!==0)<span class="cstat-no" title="statement not covered" >throw Error(Ye+o);<span class="cstat-no" title="statement not covered" >i</span></span>f(o&gt;0)<span class="cstat-no" title="statement not covered" >s.s=1;e</span>lse <span class="cstat-no" title="statement not covered" >if(o&lt;0)<span class="cstat-no" title="statement not covered" >o=-o,s.s=-1;e</span>lse{<span class="cstat-no" title="statement not covered" >s.s=0,s.e=0,s.d=[0];<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(o===~~o&amp;&amp;o&lt;1e7){<span class="cstat-no" title="statement not covered" >s.e=0,s.d=[o];<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Qo(s,o.toString())}</span>else <span class="cstat-no" title="statement not covered" >if(typeof o!="string")<span class="cstat-no" title="statement not covered" >throw Error(Ye+o);<span class="cstat-no" title="statement not covered" >i</span></span></span>f(o.charCodeAt(0)===45?(o=o.slice(1),s.s=-1):s.s=1,wu.test(o))<span class="cstat-no" title="statement not covered" >Qo(s,o);e</span>lse <span class="cstat-no" title="statement not covered" >throw Error(Ye+o)}<span class="cstat-no" title="statement not covered" ></span></span>if(i.prototype=I,i.ROUND_UP=0,i.ROUND_DOWN=1,i.ROUND_CEIL=2,i.ROUND_FLOOR=3,i.ROUND_HALF_UP=4,i.ROUND_HALF_DOWN=5,i.ROUND_HALF_EVEN=6,i.ROUND_HALF_CEIL=7,i.ROUND_HALF_FLOOR=8,i.clone=zo,i.config=i.set=bu,e===void 0&amp;&amp;(e={}),e)<span class="cstat-no" title="statement not covered" >for(n=["precision","rounding","toExpNeg","toExpPos","LN10"],t=0;t&lt;n.length;)<span class="cstat-no" title="statement not covered" >e.hasOwnProperty(r=n[t++])||(e[r]=this[r]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn i.config(e),i}</span>function <span class="fstat-no" title="function not covered" >bu(</span>e){<span class="cstat-no" title="statement not covered" >if(!e||typeof e!="object")<span class="cstat-no" title="statement not covered" >throw Error(be+"Object expected");v</span></span>ar t,r,n,i=<span class="cstat-no" title="statement not covered" >["precision",1,mt,"rounding",0,8,"toExpNeg",-1/0,0,"toExpPos",0,1/0];<span class="cstat-no" title="statement not covered" ></span>for(t=0;t&lt;i.length;t+=3)<span class="cstat-no" title="statement not covered" >if((n=e[r=i[t]])!==void 0)<span class="cstat-no" title="statement not covered" >if(dt(n)===n&amp;&amp;n&gt;=i[t+1]&amp;&amp;n&lt;=i[t+2])<span class="cstat-no" title="statement not covered" >this[r]=n;e</span>lse <span class="cstat-no" title="statement not covered" >throw Error(Ye+r+": "+n);<span class="cstat-no" title="statement not covered" >i</span></span></span></span>f((n=e[r="LN10"])!==void 0)<span class="cstat-no" title="statement not covered" >if(n==Math.LN10)<span class="cstat-no" title="statement not covered" >this[r]=new this(n);e</span>lse <span class="cstat-no" title="statement not covered" >throw Error(Ye+r+": "+n);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn this}</span>var mt,hu,fi,W,be,Ye,di,dt,ze,wu,he,te,H,Go,Yr,I,_e,fi,Zr,Yo=<span class="cstat-no" title="statement not covered" >ye(<span class="fstat-no" title="function not covered" >()</span>=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >m</span>t=1e9,hu={precision:20,rounding:4,toExpNeg:-7,toExpPos:21,LN10:"2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"},W=!0,be="[DecimalError] ",Ye=be+"Invalid argument: ",di=be+"Exponent out of range: ",dt=Math.floor,ze=Math.pow,wu=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,te=1e7,H=7,Go=9007199254740991,Yr=dt(Go/H),I={};<span class="cstat-no" title="statement not covered" >I</span>.absoluteValue=I.abs=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >new this.constructor(this);<span class="cstat-no" title="statement not covered" ></span>return e.s&amp;&amp;(e.s=1),e}</span>;<span class="cstat-no" title="statement not covered" >I</span>.comparedTo=I.cmp=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,r,n,i,o=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(e=new o.constructor(e),o.s!==e.s)<span class="cstat-no" title="statement not covered" >return o.s||-e.s;<span class="cstat-no" title="statement not covered" >i</span></span>f(o.e!==e.e)<span class="cstat-no" title="statement not covered" >return o.e&gt;e.e^o.s&lt;0?1:-1;<span class="cstat-no" title="statement not covered" >f</span></span>or(n=o.d.length,i=e.d.length,t=0,r=n&lt;i?n:i;t&lt;r;++t)<span class="cstat-no" title="statement not covered" >if(o.d[t]!==e.d[t])<span class="cstat-no" title="statement not covered" >return o.d[t]&gt;e.d[t]^o.s&lt;0?1:-1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn n===i?0:n&gt;i^o.s&lt;0?1:-1}</span>;<span class="cstat-no" title="statement not covered" >I</span>.decimalPlaces=I.dp=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this,</span>t=<span class="cstat-no" title="statement not covered" >e.d.length-1,</span>r=<span class="cstat-no" title="statement not covered" >(t-e.e)*H;<span class="cstat-no" title="statement not covered" ></span>if(t=e.d[t],t)<span class="cstat-no" title="statement not covered" >for(;t%10==0;t/=10)<span class="cstat-no" title="statement not covered" >r--;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn r&lt;0?0:r}</span>;<span class="cstat-no" title="statement not covered" >I</span>.dividedBy=I.div=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return _e(this,new this.constructor(e))}</span>;<span class="cstat-no" title="statement not covered" >I</span>.dividedToIntegerBy=I.idiv=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >t.constructor;<span class="cstat-no" title="statement not covered" ></span>return q(_e(t,new r(e),0,1),r.precision)}</span>;<span class="cstat-no" title="statement not covered" >I</span>.equals=I.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!this.cmp(e)}</span>;<span class="cstat-no" title="statement not covered" >I</span>.exponent=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Z(this)}</span>;<span class="cstat-no" title="statement not covered" >I</span>.greaterThan=I.gt=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.cmp(e)&gt;0}</span>;<span class="cstat-no" title="statement not covered" >I</span>.greaterThanOrEqualTo=I.gte=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.cmp(e)&gt;=0}</span>;<span class="cstat-no" title="statement not covered" >I</span>.isInteger=I.isint=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.e&gt;this.d.length-2}</span>;<span class="cstat-no" title="statement not covered" >I</span>.isNegative=I.isneg=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.s&lt;0}</span>;<span class="cstat-no" title="statement not covered" >I</span>.isPositive=I.ispos=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.s&gt;0}</span>;<span class="cstat-no" title="statement not covered" >I</span>.isZero=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.s===0}</span>;<span class="cstat-no" title="statement not covered" >I</span>.lessThan=I.lt=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.cmp(e)&lt;0}</span>;<span class="cstat-no" title="statement not covered" >I</span>.lessThanOrEqualTo=I.lte=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.cmp(e)&lt;1}</span>;<span class="cstat-no" title="statement not covered" >I</span>.logarithm=I.log=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor,</span>i=<span class="cstat-no" title="statement not covered" >n.precision,</span>o=<span class="cstat-no" title="statement not covered" >i+5;<span class="cstat-no" title="statement not covered" ></span>if(e===void 0)<span class="cstat-no" title="statement not covered" >e=new n(10);e</span>lse <span class="cstat-no" title="statement not covered" >if(e=new n(e),e.s&lt;1||e.eq(he))<span class="cstat-no" title="statement not covered" >throw Error(be+"NaN");<span class="cstat-no" title="statement not covered" >i</span></span></span>f(r.s&lt;1)<span class="cstat-no" title="statement not covered" >throw Error(be+(r.s?"NaN":"-Infinity"));<span class="cstat-no" title="statement not covered" >r</span></span>eturn r.eq(he)?new n(0):(W=!1,t=_e(Kt(r,o),Kt(e,o),o),W=!0,q(t,i))}</span>;<span class="cstat-no" title="statement not covered" >I</span>.minus=I.sub=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return e=new t.constructor(e),t.s==e.s?Ko(t,e):Jo(t,(e.s=-e.s,e))}</span>;<span class="cstat-no" title="statement not covered" >I</span>.modulo=I.mod=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor,</span>i=<span class="cstat-no" title="statement not covered" >n.precision;<span class="cstat-no" title="statement not covered" ></span>if(e=new n(e),!e.s)<span class="cstat-no" title="statement not covered" >throw Error(be+"NaN");<span class="cstat-no" title="statement not covered" >r</span></span>eturn r.s?(W=!1,t=_e(r,e,0,1).times(e),W=!0,r.minus(t)):q(new n(r),i)}</span>;<span class="cstat-no" title="statement not covered" >I</span>.naturalExponential=I.exp=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Wo(this)}</span>;<span class="cstat-no" title="statement not covered" >I</span>.naturalLogarithm=I.ln=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Kt(this)}</span>;<span class="cstat-no" title="statement not covered" >I</span>.negated=I.neg=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >new this.constructor(this);<span class="cstat-no" title="statement not covered" ></span>return e.s=-e.s||0,e}</span>;<span class="cstat-no" title="statement not covered" >I</span>.plus=I.add=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return e=new t.constructor(e),t.s==e.s?Jo(t,e):Ko(t,(e.s=-e.s,e))}</span>;<span class="cstat-no" title="statement not covered" >I</span>.precision=I.sd=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,r,n,i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(e!==void 0&amp;&amp;e!==!!e&amp;&amp;e!==1&amp;&amp;e!==0)<span class="cstat-no" title="statement not covered" >throw Error(Ye+e);<span class="cstat-no" title="statement not covered" >i</span></span>f(t=Z(i)+1,n=i.d.length-1,r=n*H+1,n=i.d[n],n){<span class="cstat-no" title="statement not covered" >for(;n%10==0;n/=10)<span class="cstat-no" title="statement not covered" >r--;<span class="cstat-no" title="statement not covered" >f</span></span>or(n=i.d[0];n&gt;=10;n/=10)<span class="cstat-no" title="statement not covered" >r++}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn e&amp;&amp;t&gt;r?t:r}</span>;<span class="cstat-no" title="statement not covered" >I</span>.squareRoot=I.sqrt=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,t,r,n,i,o,s,a=<span class="cstat-no" title="statement not covered" >this,</span>f=<span class="cstat-no" title="statement not covered" >a.constructor;<span class="cstat-no" title="statement not covered" ></span>if(a.s&lt;1){<span class="cstat-no" title="statement not covered" >if(!a.s)<span class="cstat-no" title="statement not covered" >return new f(0);<span class="cstat-no" title="statement not covered" >t</span></span>hrow Error(be+"NaN")}<span class="cstat-no" title="statement not covered" ></span>f</span>or(e=Z(a),W=!1,i=Math.sqrt(+a),i==0||i==1/0?(t=Ae(a.d),(t.length+e)%2==0&amp;&amp;(t+="0"),i=Math.sqrt(t),e=dt((e+1)/2)-(e&lt;0||e%2),i==1/0?t="5e"+e:(t=i.toExponential(),t=t.slice(0,t.indexOf("e")+1)+e),n=new f(t)):n=new f(i.toString()),r=f.precision,i=s=r+3;;)<span class="cstat-no" title="statement not covered" >if(o=n,n=o.plus(_e(a,o,s+2)).times(.5),Ae(o.d).slice(0,s)===(t=Ae(n.d)).slice(0,s)){<span class="cstat-no" title="statement not covered" >if(t=t.slice(s-3,s+1),i==s&amp;&amp;t=="4999"){<span class="cstat-no" title="statement not covered" >if(q(o,r+1,0),o.times(o).eq(a)){<span class="cstat-no" title="statement not covered" >n=o;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(t!="9999")<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >s</span></span></span>+=4}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn W=!0,q(n,r)}</span>;<span class="cstat-no" title="statement not covered" >I</span>.times=I.mul=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,r,n,i,o,s,a,f,w,A=<span class="cstat-no" title="statement not covered" >this,</span>R=<span class="cstat-no" title="statement not covered" >A.constructor,</span>S=<span class="cstat-no" title="statement not covered" >A.d,</span>C=<span class="cstat-no" title="statement not covered" >(e=new R(e)).d;<span class="cstat-no" title="statement not covered" ></span>if(!A.s||!e.s)<span class="cstat-no" title="statement not covered" >return new R(0);<span class="cstat-no" title="statement not covered" >f</span></span>or(e.s*=A.s,r=A.e+e.e,f=S.length,w=C.length,f&lt;w&amp;&amp;(o=S,S=C,C=o,s=f,f=w,w=s),o=[],s=f+w,n=s;n--;)<span class="cstat-no" title="statement not covered" >o.push(0);<span class="cstat-no" title="statement not covered" >f</span></span>or(n=w;--n&gt;=0;){<span class="cstat-no" title="statement not covered" >for(t=0,i=f+n;i&gt;n;)<span class="cstat-no" title="statement not covered" >a=o[i]+C[n]*S[i-n-1]+t,o[i--]=a%te|0,t=a/te|0;<span class="cstat-no" title="statement not covered" >o</span></span>[i]=(o[i]+t)%te|0}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;!o[--s];)<span class="cstat-no" title="statement not covered" >o.pop();<span class="cstat-no" title="statement not covered" >r</span></span>eturn t?++r:o.shift(),e.d=o,e.e=r,W?q(e,R.precision):e}</span>;<span class="cstat-no" title="statement not covered" >I</span>.toDecimalPlaces=I.todp=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return r=new n(r),e===void 0?r:(Re(e,0,mt),t===void 0?t=n.rounding:Re(t,0,8),q(r,e+Z(r)+1,t))}</span>;<span class="cstat-no" title="statement not covered" >I</span>.toExponential=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r,n=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >n.constructor;<span class="cstat-no" title="statement not covered" ></span>return e===void 0?r=Ze(n,!0):(Re(e,0,mt),t===void 0?t=i.rounding:Re(t,0,8),n=q(new i(n),e+1,t),r=Ze(n,!0,e+1)),r}</span>;<span class="cstat-no" title="statement not covered" >I</span>.toFixed=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r,n,i=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >i.constructor;<span class="cstat-no" title="statement not covered" ></span>return e===void 0?Ze(i):(Re(e,0,mt),t===void 0?t=o.rounding:Re(t,0,8),n=q(new o(i),e+Z(i)+1,t),r=Ze(n.abs(),!1,e+Z(n)+1),i.isneg()&amp;&amp;!i.isZero()?"-"+r:r)}</span>;<span class="cstat-no" title="statement not covered" >I</span>.toInteger=I.toint=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this,</span>t=<span class="cstat-no" title="statement not covered" >e.constructor;<span class="cstat-no" title="statement not covered" ></span>return q(new t(e),Z(e)+1,t.rounding)}</span>;<span class="cstat-no" title="statement not covered" >I</span>.toNumber=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return+this}</span>;<span class="cstat-no" title="statement not covered" >I</span>.toPower=I.pow=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,r,n,i,o,s,a=<span class="cstat-no" title="statement not covered" >this,</span>f=<span class="cstat-no" title="statement not covered" >a.constructor,</span>w=<span class="cstat-no" title="statement not covered" >12,</span>A=<span class="cstat-no" title="statement not covered" >+(e=new f(e));<span class="cstat-no" title="statement not covered" ></span>if(!e.s)<span class="cstat-no" title="statement not covered" >return new f(he);<span class="cstat-no" title="statement not covered" >i</span></span>f(a=new f(a),!a.s){<span class="cstat-no" title="statement not covered" >if(e.s&lt;1)<span class="cstat-no" title="statement not covered" >throw Error(be+"Infinity");<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}<span class="cstat-no" title="statement not covered" ></span>i</span>f(a.eq(he))<span class="cstat-no" title="statement not covered" >return a;<span class="cstat-no" title="statement not covered" >i</span></span>f(n=f.precision,e.eq(he))<span class="cstat-no" title="statement not covered" >return q(a,n);<span class="cstat-no" title="statement not covered" >i</span></span>f(t=e.e,r=e.d.length-1,s=t&gt;=r,o=a.s,s){<span class="cstat-no" title="statement not covered" >if((r=A&lt;0?-A:A)&lt;=Go){<span class="cstat-no" title="statement not covered" >for(i=new f(he),t=Math.ceil(n/H+4),W=!1;r%2&amp;&amp;(i=i.times(a),Ho(i.d,t)),r=dt(r/2),r!==0;)<span class="cstat-no" title="statement not covered" >a=a.times(a),Ho(a.d,t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn W=!0,e.s&lt;0?new f(he).div(i):q(i,n)}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(o&lt;0)<span class="cstat-no" title="statement not covered" >throw Error(be+"NaN");<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn o=o&lt;0&amp;&amp;e.d[Math.max(t,r)]&amp;1?-1:1,a.s=1,W=!1,i=e.times(Kt(a,n+w)),W=!0,i=Wo(i),i.s=o,i}</span>;<span class="cstat-no" title="statement not covered" >I</span>.toPrecision=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r,n,i=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >i.constructor;<span class="cstat-no" title="statement not covered" ></span>return e===void 0?(r=Z(i),n=Ze(i,r&lt;=o.toExpNeg||r&gt;=o.toExpPos)):(Re(e,1,mt),t===void 0?t=o.rounding:Re(t,0,8),i=q(new o(i),e,t),r=Z(i),n=Ze(i,e&lt;=r||r&lt;=o.toExpNeg,e)),n}</span>;<span class="cstat-no" title="statement not covered" >I</span>.toSignificantDigits=I.tosd=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return e===void 0?(e=n.precision,t=n.rounding):(Re(e,1,mt),t===void 0?t=n.rounding:Re(t,0,8)),q(new n(r),e,t)}</span>;<span class="cstat-no" title="statement not covered" >I</span>.toString=I.valueOf=I.val=I.toJSON=I[Symbol.for("nodejs.util.inspect.custom")]=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this,</span>t=<span class="cstat-no" title="statement not covered" >Z(e),</span>r=<span class="cstat-no" title="statement not covered" >e.constructor;<span class="cstat-no" title="statement not covered" ></span>return Ze(e,t&lt;=r.toExpNeg||t&gt;=r.toExpPos)}</span>;<span class="cstat-no" title="statement not covered" >_</span>e=<span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >e(</span>n,i){var o,s=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >n.length;<span class="cstat-no" title="statement not covered" ></span>for(n=n.slice();a--;)<span class="cstat-no" title="statement not covered" >o=n[a]*i+s,n[a]=o%te|0,s=o/te|0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn s&amp;&amp;n.unshift(s),n}</span>function <span class="fstat-no" title="function not covered" >t(</span>n,i,o,s){var a,f;<span class="cstat-no" title="statement not covered" >if(o!=s)<span class="cstat-no" title="statement not covered" >f=o&gt;s?1:-1;e</span>lse <span class="cstat-no" title="statement not covered" >for(a=f=0;a&lt;o;a++)<span class="cstat-no" title="statement not covered" >if(n[a]!=i[a]){<span class="cstat-no" title="statement not covered" >f=n[a]&gt;i[a]?1:-1;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn f}</span>function <span class="fstat-no" title="function not covered" >r(</span>n,i,o){<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >0;</span>o--;)<span class="cstat-no" title="statement not covered" >n[o]-=s,s=n[o]&lt;i[o]?1:0,n[o]=s*te+n[o]-i[o];<span class="cstat-no" title="statement not covered" >f</span></span>or(;!n[0]&amp;&amp;n.length&gt;1;)<span class="cstat-no" title="statement not covered" >n.shift()}<span class="cstat-no" title="statement not covered" ></span></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(n,i,o,s){var a,f,w,A,R,S,C,L,k,M,De,ue,B,pe,Ke,ci,xe,Jr,Wr=<span class="cstat-no" title="statement not covered" >n.constructor,</span>nu=<span class="cstat-no" title="statement not covered" >n.s==i.s?1:-1,</span>ve=<span class="cstat-no" title="statement not covered" >n.d,</span>z=<span class="cstat-no" title="statement not covered" >i.d;<span class="cstat-no" title="statement not covered" ></span>if(!n.s)<span class="cstat-no" title="statement not covered" >return new Wr(n);<span class="cstat-no" title="statement not covered" >i</span></span>f(!i.s)<span class="cstat-no" title="statement not covered" >throw Error(be+"Division by zero");<span class="cstat-no" title="statement not covered" >f</span></span>or(f=n.e-i.e,xe=z.length,Ke=ve.length,C=new Wr(nu),L=C.d=[],w=0;z[w]==(ve[w]||0);)<span class="cstat-no" title="statement not covered" >++w;<span class="cstat-no" title="statement not covered" >i</span></span>f(z[w]&gt;(ve[w]||0)&amp;&amp;--f,o==null?ue=o=Wr.precision:s?ue=o+(Z(n)-Z(i))+1:ue=o,ue&lt;0)<span class="cstat-no" title="statement not covered" >return new Wr(0);<span class="cstat-no" title="statement not covered" >i</span></span>f(ue=ue/H+2|0,w=0,xe==1)<span class="cstat-no" title="statement not covered" >for(A=0,z=z[0],ue++;(w&lt;Ke||A)&amp;&amp;ue--;w++)<span class="cstat-no" title="statement not covered" >B=A*te+(ve[w]||0),L[w]=B/z|0,A=B%z|0;e</span></span>lse{<span class="cstat-no" title="statement not covered" >for(A=te/(z[0]+1)|0,A&gt;1&amp;&amp;(z=e(z,A),ve=e(ve,A),xe=z.length,Ke=ve.length),pe=xe,k=ve.slice(0,xe),M=k.length;M&lt;xe;)<span class="cstat-no" title="statement not covered" >k[M++]=0;<span class="cstat-no" title="statement not covered" >J</span></span>r=z.slice(),Jr.unshift(0),ci=z[0],z[1]&gt;=te/2&amp;&amp;++ci;<span class="cstat-no" title="statement not covered" >d</span>o <span class="cstat-no" title="statement not covered" >A=0,a=t(z,k,xe,M),a&lt;0?(De=k[0],xe!=M&amp;&amp;(De=De*te+(k[1]||0)),A=De/ci|0,A&gt;1?(A&gt;=te&amp;&amp;(A=te-1),R=e(z,A),S=R.length,M=k.length,a=t(R,k,S,M),a==1&amp;&amp;(A--,r(R,xe&lt;S?Jr:z,S))):(A==0&amp;&amp;(a=A=1),R=z.slice()),S=R.length,S&lt;M&amp;&amp;R.unshift(0),r(k,R,M),a==-1&amp;&amp;(M=k.length,a=t(z,k,xe,M),a&lt;1&amp;&amp;(A++,r(k,xe&lt;M?Jr:z,M))),M=k.length):a===0&amp;&amp;(A++,k=[0]),L[w++]=A,a&amp;&amp;k[0]?k[M++]=ve[pe]||0:(k=[ve[pe]],M=1);w</span>hile((pe++&lt;Ke||k[0]!==void 0)&amp;&amp;ue--)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn L[0]||L.shift(),C.e=f,q(C,s?o+Z(C)+1:o)}</span>}</span>();<span class="cstat-no" title="statement not covered" >f</span>i=zo(hu);<span class="cstat-no" title="statement not covered" >h</span>e=new fi(1);<span class="cstat-no" title="statement not covered" >Z</span>r=fi}</span>);</span>var v,se,l=<span class="cstat-no" title="statement not covered" >ye(<span class="fstat-no" title="function not covered" >()</span>=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >Yo();<span class="cstat-no" title="statement not covered" >v</span>=class extends Zr{<span class="fstat-no" title="function not covered" >st</span>atic isDecimal(t){<span class="cstat-no" title="statement not covered" >return t instanceof Zr}<span class="fstat-no" title="function not covered" ></span>st</span>atic random(t=<span class="branch-0 cbranch-no" title="branch not covered" >20)</span>{{let n=<span class="cstat-no" title="statement not covered" >globalThis.crypto.getRandomValues(new Uint8Array(t)).reduce(<span class="fstat-no" title="function not covered" >(i</span>,o)=&gt;<span class="cstat-no" title="statement not covered" >i+o,</span>"");<span class="cstat-no" title="statement not covered" ></span>return new Zr(`0.${n.slice(0,t)}`)}</span>}},se=v}</span>);</span>function <span class="fstat-no" title="function not covered" >Au(</span>){<span class="cstat-no" title="statement not covered" >return!1}</span>function <span class="fstat-no" title="function not covered" >bi(</span>){<span class="cstat-no" title="statement not covered" >return{dev:0,ino:0,mode:0,nlink:0,uid:0,gid:0,rdev:0,size:0,blksize:0,blocks:0,atimeMs:0,mtimeMs:0,ctimeMs:0,birthtimeMs:0,atime:new Date,mtime:new Date,ctime:new Date,birthtime:new Date}}</span>function <span class="fstat-no" title="function not covered" >Ru(</span>){<span class="cstat-no" title="statement not covered" >return bi()}</span>function <span class="fstat-no" title="function not covered" >Cu(</span>){<span class="cstat-no" title="statement not covered" >return[]}</span>function <span class="fstat-no" title="function not covered" >Su(</span>e){<span class="cstat-no" title="statement not covered" >e(null,[])}</span>function <span class="fstat-no" title="function not covered" >Iu(</span>){<span class="cstat-no" title="statement not covered" >return""}</span>function <span class="fstat-no" title="function not covered" >ku(</span>){<span class="cstat-no" title="statement not covered" >return""}</span>function <span class="fstat-no" title="function not covered" >Ou(</span>){}function <span class="fstat-no" title="function not covered" >Du(</span>){}function <span class="fstat-no" title="function not covered" >_u(</span>){}function <span class="fstat-no" title="function not covered" >Mu(</span>){}function <span class="fstat-no" title="function not covered" >Nu(</span>){}function <span class="fstat-no" title="function not covered" >Lu(</span>){}function <span class="fstat-no" title="function not covered" >Uu(</span>){}function <span class="fstat-no" title="function not covered" >Fu(</span>){}function <span class="fstat-no" title="function not covered" >$u(</span>){<span class="cstat-no" title="statement not covered" >return{close:<span class="fstat-no" title="function not covered" >()</span>=&gt;{},on:<span class="fstat-no" title="function not covered" >()</span>=&gt;{},removeAllListeners:<span class="fstat-no" title="function not covered" >()</span>=&gt;{}}}</span>function <span class="fstat-no" title="function not covered" >Vu(</span>e,t){<span class="cstat-no" title="statement not covered" >t(null,bi())}</span>var qu,Bu,fs,gs=<span class="cstat-no" title="statement not covered" >ye(<span class="fstat-no" title="function not covered" >()</span>=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >q</span>u={},Bu={existsSync:Au,lstatSync:bi,stat:Vu,statSync:Ru,readdirSync:Cu,readdir:Su,readlinkSync:Iu,realpathSync:ku,chmodSync:Ou,renameSync:Du,mkdirSync:_u,rmdirSync:Mu,rmSync:Nu,unlinkSync:Lu,watchFile:Uu,unwatchFile:Fu,watch:$u,promises:qu},fs=Bu}</span>);</span>var ys=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >()</span>=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>()}</span>);</span>var hs=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >($</span>y,ju)=&gt;{<span class="cstat-no" title="statement not covered" >ju.exports={name:"@prisma/internals",version:"6.17.1",description:"This package is intended for Prisma's internal use",main:"dist/index.js",types:"dist/index.d.ts",repository:{type:"git",url:"https://github.com/prisma/prisma.git",directory:"packages/internals"},homepage:"https://www.prisma.io",author:"Tim Suchanek &lt;suchanek@prisma.io&gt;",bugs:"https://github.com/prisma/prisma/issues",license:"Apache-2.0",scripts:{dev:"DEV=true tsx helpers/build.ts",build:"tsx helpers/build.ts",test:"dotenv -e ../../.db.env -- jest --silent",prepublishOnly:"pnpm run build"},files:["README.md","dist","!**/libquery_engine*","!dist/get-generators/engines/*","scripts"],devDependencies:{"@babel/helper-validator-identifier":"7.25.9","@opentelemetry/api":"1.9.0","@swc/core":"1.11.5","@swc/jest":"0.2.37","@types/babel__helper-validator-identifier":"7.15.2","@types/jest":"29.5.14","@types/node":"18.19.76","@types/resolve":"1.20.6",archiver:"6.0.2","checkpoint-client":"1.1.33","cli-truncate":"4.0.0",dotenv:"16.5.0",empathic:"2.0.0","escape-string-regexp":"5.0.0",execa:"8.0.1","fast-glob":"3.3.3","find-up":"7.0.0","fp-ts":"2.16.9","fs-extra":"11.3.0","global-directory":"4.0.0",globby:"11.1.0","identifier-regex":"1.0.0","indent-string":"4.0.0","is-windows":"1.0.2","is-wsl":"3.1.0",jest:"29.7.0","jest-junit":"16.0.0",kleur:"4.1.5","mock-stdin":"1.0.0","new-github-issue-url":"0.2.1","node-fetch":"3.3.2","npm-packlist":"5.1.3",open:"7.4.2","p-map":"4.0.0",resolve:"1.22.10","string-width":"7.2.0","strip-indent":"4.0.0","temp-dir":"2.0.0",tempy:"1.0.1","terminal-link":"4.0.0",tmp:"0.2.3","ts-pattern":"5.6.2","ts-toolbelt":"9.6.0",typescript:"5.4.5",yarn:"1.22.22"},dependencies:{"@prisma/config":"workspace:*","@prisma/debug":"workspace:*","@prisma/dmmf":"workspace:*","@prisma/driver-adapter-utils":"workspace:*","@prisma/engines":"workspace:*","@prisma/fetch-engine":"workspace:*","@prisma/generator":"workspace:*","@prisma/generator-helper":"workspace:*","@prisma/get-platform":"workspace:*","@prisma/prisma-schema-wasm":"6.17.1-1.272a37d34178c2894197e17273bf937f25acdeac","@prisma/schema-engine-wasm":"6.17.1-1.272a37d34178c2894197e17273bf937f25acdeac","@prisma/schema-files-loader":"workspace:*",arg:"5.0.2",prompts:"2.4.2"},peerDependencies:{typescript:"&gt;=5.1.0"},peerDependenciesMeta:{typescript:{optional:!0}},sideEffects:!1}}</span>);</span>function <span class="fstat-no" title="function not covered" >Hu(</span>...e){<span class="cstat-no" title="statement not covered" >return e.join("/")}</span>function <span class="fstat-no" title="function not covered" >Gu(</span>...e){<span class="cstat-no" title="statement not covered" >return e.join("/")}</span>function <span class="fstat-no" title="function not covered" >Ju(</span>e){let t=<span class="cstat-no" title="statement not covered" >ws(e),</span>r=<span class="cstat-no" title="statement not covered" >bs(e),</span>[n,i]=<span class="cstat-no" title="statement not covered" >t.split(".");<span class="cstat-no" title="statement not covered" ></span>return{root:"/",dir:r,base:t,ext:i,name:n}}</span>function <span class="fstat-no" title="function not covered" >ws(</span>e){let t=<span class="cstat-no" title="statement not covered" >e.split("/");<span class="cstat-no" title="statement not covered" ></span>return t[t.length-1]}</span>function <span class="fstat-no" title="function not covered" >bs(</span>e){<span class="cstat-no" title="statement not covered" >return e.split("/").slice(0,-1).join("/")}</span>function <span class="fstat-no" title="function not covered" >Ku(</span>e){let t=<span class="cstat-no" title="statement not covered" >e.split("/").filter(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >i!==""&amp;&amp;i!==".")</span>,</span>r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i of t)<span class="cstat-no" title="statement not covered" >i===".."?r.pop():r.push(i);l</span></span>et n=<span class="cstat-no" title="statement not covered" >r.join("/");<span class="cstat-no" title="statement not covered" ></span>return e.startsWith("/")?"/"+n:n}</span>var Es,Wu,zu,Yu,rn,xs=<span class="cstat-no" title="statement not covered" >ye(<span class="fstat-no" title="function not covered" >()</span>=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >E</span>s="/",Wu=":";<span class="cstat-no" title="statement not covered" >z</span>u={sep:Es},Yu={basename:ws,delimiter:Wu,dirname:bs,join:Gu,normalize:Ku,parse:Ju,posix:zu,resolve:Hu,sep:Es},rn=Yu}</span>);</span>var xi=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>pt(xi,{Hash:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Zt,</span>createHash:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Ps,</span>default:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >yt,</span>randomFillSync:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >sn,</span>randomUUID:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >on,</span>webcrypto:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Xt}</span>);f</span>unction <span class="fstat-no" title="function not covered" >on(</span>){<span class="cstat-no" title="statement not covered" >return globalThis.crypto.randomUUID()}</span>function <span class="fstat-no" title="function not covered" >sn(</span>e,t,r){<span class="cstat-no" title="statement not covered" >return t!==void 0&amp;&amp;(r!==void 0?e=e.subarray(t,t+r):e=e.subarray(t)),globalThis.crypto.getRandomValues(e)}</span>function <span class="fstat-no" title="function not covered" >Ps(</span>e){<span class="cstat-no" title="statement not covered" >return new Zt(e)}</span>var Xt,Zt,yt,Xe=<span class="cstat-no" title="statement not covered" >ye(<span class="fstat-no" title="function not covered" >()</span>=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >X</span>t=globalThis.crypto;<span class="cstat-no" title="statement not covered" >Z</span>t=class{#t=<span class="cstat-no" title="statement not covered" >[];</span>#e;<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.#e=t}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){<span class="cstat-no" title="statement not covered" >this.#t.push(t)}<span class="fstat-no" title="function not covered" ></span>as</span>ync digest(){let t=<span class="cstat-no" title="statement not covered" >new Uint8Array(this.#t.reduce(<span class="fstat-no" title="function not covered" >(i</span>,o)=&gt;<span class="cstat-no" title="statement not covered" >i+o.length,</span>0)),</span>r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i of this.#t)<span class="cstat-no" title="statement not covered" >t.set(i,r),r+=i.length;l</span></span>et n=<span class="cstat-no" title="statement not covered" >await globalThis.crypto.subtle.digest(this.#e,t);<span class="cstat-no" title="statement not covered" ></span>return new Uint8Array(n)}</span>},yt={webcrypto:Xt,randomUUID:on,randomFillSync:sn,createHash:Ps,Hash:Zt}}</span>);</span>var Pi=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >(F</span>h,ep)=&gt;{<span class="cstat-no" title="statement not covered" >ep.exports={name:"@prisma/engines-version",version:"6.17.1-1.272a37d34178c2894197e17273bf937f25acdeac",main:"index.js",types:"index.d.ts",license:"Apache-2.0",author:"Tim Suchanek &lt;suchanek@prisma.io&gt;",prisma:{enginesVersion:"272a37d34178c2894197e17273bf937f25acdeac"},repository:{type:"git",url:"https://github.com/prisma/engines-wrapper.git",directory:"packages/engines-version"},devDependencies:{"@types/node":"18.19.76",typescript:"4.9.5"},files:["index.js","index.d.ts"],scripts:{build:"tsc -d"}}}</span>);</span>var Ts=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >an</span>=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(an,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >a</span>n.enginesVersion=void 0;<span class="cstat-no" title="statement not covered" >a</span>n.enginesVersion=Pi().prisma.enginesVersion}</span>);</span>var Rs=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >(X</span>h,As)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >A</span>s.exports=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>r)=&gt;{<span class="cstat-no" title="statement not covered" >if(r={indent:" ",includeEmptyLines:!1,...r},typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof t!="number")<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t}\``);<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof r.indent!="string")<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r.indent}\``);<span class="cstat-no" title="statement not covered" >i</span></span>f(t===0)<span class="cstat-no" title="statement not covered" >return e;l</span></span>et n=<span class="cstat-no" title="statement not covered" >r.includeEmptyLines?/^/gm:/^(?!\s*$)/gm;<span class="cstat-no" title="statement not covered" ></span>return e.replace(n,r.indent.repeat(t))}</span>}</span>);</span>var Ss=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >(N</span>w,un)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>n.exports=<span class="fstat-no" title="function not covered" >(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let t;<span class="cstat-no" title="statement not covered" >if(e.repoUrl)<span class="cstat-no" title="statement not covered" >t=e.repoUrl;e</span>lse <span class="cstat-no" title="statement not covered" >if(e.user&amp;&amp;e.repo)<span class="cstat-no" title="statement not covered" >t=`https://github.com/${e.user}/${e.repo}`;e</span>lse <span class="cstat-no" title="statement not covered" >throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");l</span></span></span>et r=<span class="cstat-no" title="statement not covered" >new URL(`${t}/issues/new`),</span>n=<span class="cstat-no" title="statement not covered" >["body","title","labels","template","milestone","assignee","projects"];<span class="cstat-no" title="statement not covered" ></span>for(let i of n){let o=<span class="cstat-no" title="statement not covered" >e[i];<span class="cstat-no" title="statement not covered" ></span>if(o!==void 0){<span class="cstat-no" title="statement not covered" >if(i==="labels"||i==="projects"){<span class="cstat-no" title="statement not covered" >if(!Array.isArray(o))<span class="cstat-no" title="statement not covered" >throw new TypeError(`The \`${i}\` option should be an array`);<span class="cstat-no" title="statement not covered" >o</span></span>=o.join(",")}<span class="cstat-no" title="statement not covered" ></span>r</span>.searchParams.set(i,o)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r.toString()}</span>;<span class="cstat-no" title="statement not covered" >u</span>n.exports.default=un.exports}</span>);</span>var Ii=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >(C</span>P,_s)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >_</span>s.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >e(</span>t,r,n,i,o){<span class="cstat-no" title="statement not covered" >return t&lt;r||n&lt;r?t&gt;n?n+1:t+1:i===o?r:r+1}<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(t,r){<span class="cstat-no" title="statement not covered" >if(t===r)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >i</span></span>f(t.length&gt;r.length){var n=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>t=r,r=n}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i=<span class="cstat-no" title="statement not covered" >t.length,</span>o=<span class="cstat-no" title="statement not covered" >r.length;</span>i&gt;0&amp;&amp;t.charCodeAt(i-1)===r.charCodeAt(o-1);)<span class="cstat-no" title="statement not covered" >i--,o--;<span class="cstat-no" title="statement not covered" >f</span></span>or(var s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;i&amp;&amp;t.charCodeAt(s)===r.charCodeAt(s);)<span class="cstat-no" title="statement not covered" >s++;<span class="cstat-no" title="statement not covered" >i</span></span>f(i-=s,o-=s,i===0||o&lt;3)<span class="cstat-no" title="statement not covered" >return o;v</span></span>ar a=<span class="cstat-no" title="statement not covered" >0,</span>f,w,A,R,S,C,L,k,M,De,ue,B,pe=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(f=0;f&lt;i;f++)<span class="cstat-no" title="statement not covered" >pe.push(f+1),pe.push(t.charCodeAt(s+f));<span class="cstat-no" title="statement not covered" >f</span></span>or(var Ke=<span class="cstat-no" title="statement not covered" >pe.length-1;</span>a&lt;o-3;)<span class="cstat-no" title="statement not covered" >for(M=r.charCodeAt(s+(w=a)),De=r.charCodeAt(s+(A=a+1)),ue=r.charCodeAt(s+(R=a+2)),B=r.charCodeAt(s+(S=a+3)),C=a+=4,f=0;f&lt;Ke;f+=2)<span class="cstat-no" title="statement not covered" >L=pe[f],k=pe[f+1],w=e(L,w,A,M,k),A=e(w,A,R,De,k),R=e(A,R,S,ue,k),C=e(R,S,C,B,k),pe[f]=C,S=R,R=A,A=w,w=L;<span class="cstat-no" title="statement not covered" >f</span></span></span>or(;a&lt;o;)<span class="cstat-no" title="statement not covered" >for(M=r.charCodeAt(s+(w=a)),C=++a,f=0;f&lt;Ke;f+=2)<span class="cstat-no" title="statement not covered" >L=pe[f],pe[f]=C=e(L,w,C,M,pe[f+1]),w=L;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn C}</span>}</span>()}</span>);</span>var Fs=<span class="cstat-no" title="statement not covered" >ye(<span class="fstat-no" title="function not covered" >()</span>=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>()}</span>);</span>var $s=<span class="cstat-no" title="statement not covered" >ye(<span class="fstat-no" title="function not covered" >()</span>=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>()}</span>);</span>var kn,ca=<span class="cstat-no" title="statement not covered" >ye(<span class="fstat-no" title="function not covered" >()</span>=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >k</span>n=class{events=<span class="cstat-no" title="statement not covered" >{};<span class="fstat-no" title="function not covered" ></span>on</span>(t,r){<span class="cstat-no" title="statement not covered" >return this.events[t]||(this.events[t]=[]),this.events[t].push(r),this}<span class="fstat-no" title="function not covered" ></span>em</span>it(t,...r){<span class="cstat-no" title="statement not covered" >return this.events[t]?(this.events[t].forEach(<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >n(...r)}</span>),!0):!1}</span>}}</span>);</span>var Xi=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >rt</span>=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(rt,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >r</span>t.anumber=Zi;<span class="cstat-no" title="statement not covered" >r</span>t.abytes=ol;<span class="cstat-no" title="statement not covered" >r</span>t.ahash=Mm;<span class="cstat-no" title="statement not covered" >r</span>t.aexists=Nm;<span class="cstat-no" title="statement not covered" >r</span>t.aoutput=Lm;f</span>unction <span class="fstat-no" title="function not covered" >Zi(</span>e){<span class="cstat-no" title="statement not covered" >if(!Number.isSafeInteger(e)||e&lt;0)<span class="cstat-no" title="statement not covered" >throw new Error("positive integer expected, got "+e)}</span></span>function <span class="fstat-no" title="function not covered" >_m(</span>e){<span class="cstat-no" title="statement not covered" >return e instanceof Uint8Array||ArrayBuffer.isView(e)&amp;&amp;e.constructor.name==="Uint8Array"}</span>function <span class="fstat-no" title="function not covered" >ol(</span>e,...t){<span class="cstat-no" title="statement not covered" >if(!_m(e))<span class="cstat-no" title="statement not covered" >throw new Error("Uint8Array expected");<span class="cstat-no" title="statement not covered" >i</span></span>f(t.length&gt;0&amp;&amp;!t.includes(e.length))<span class="cstat-no" title="statement not covered" >throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}</span></span>function <span class="fstat-no" title="function not covered" >Mm(</span>e){<span class="cstat-no" title="statement not covered" >if(typeof e!="function"||typeof e.create!="function")<span class="cstat-no" title="statement not covered" >throw new Error("Hash should be wrapped by utils.wrapConstructor");<span class="cstat-no" title="statement not covered" >Z</span></span>i(e.outputLen),Zi(e.blockLen)}</span>function <span class="fstat-no" title="function not covered" >Nm(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{<span class="cstat-no" title="statement not covered" >if(e.destroyed)<span class="cstat-no" title="statement not covered" >throw new Error("Hash instance has been destroyed");<span class="cstat-no" title="statement not covered" >i</span></span>f(t&amp;&amp;e.finished)<span class="cstat-no" title="statement not covered" >throw new Error("Hash#digest() has already been called")}</span></span>function <span class="fstat-no" title="function not covered" >Lm(</span>e,t){<span class="cstat-no" title="statement not covered" >ol(e);l</span>et r=<span class="cstat-no" title="statement not covered" >t.outputLen;<span class="cstat-no" title="statement not covered" ></span>if(e.length&lt;r)<span class="cstat-no" title="statement not covered" >throw new Error("digestInto() expects output buffer of length at least "+r)}</span></span>});</span>var Cl=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >_=</span>&gt;{"use strict";<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(_,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >_</span>.add5L=_.add5H=_.add4H=_.add4L=_.add3H=_.add3L=_.rotlBL=_.rotlBH=_.rotlSL=_.rotlSH=_.rotr32L=_.rotr32H=_.rotrBL=_.rotrBH=_.rotrSL=_.rotrSH=_.shrSL=_.shrSH=_.toBig=void 0;<span class="cstat-no" title="statement not covered" >_</span>.fromBig=to;<span class="cstat-no" title="statement not covered" >_</span>.split=sl;<span class="cstat-no" title="statement not covered" >_</span>.add=El;v</span>ar Fn=<span class="cstat-no" title="statement not covered" >BigInt(2**32-1),</span>eo=<span class="cstat-no" title="statement not covered" >BigInt(32);</span>function <span class="fstat-no" title="function not covered" >to(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >return t?{h:Number(e&amp;Fn),l:Number(e&gt;&gt;eo&amp;Fn)}:{h:Number(e&gt;&gt;eo&amp;Fn)|0,l:Number(e&amp;Fn)|0}}</span>function <span class="fstat-no" title="function not covered" >sl(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{let r=<span class="cstat-no" title="statement not covered" >new Uint32Array(e.length),</span>n=<span class="cstat-no" title="statement not covered" >new Uint32Array(e.length);<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;e.length;i++){let{h:o,l:s}=<span class="cstat-no" title="statement not covered" >to(e[i],t);<span class="cstat-no" title="statement not covered" ></span>[r[i],n[i]]=[o,s]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn[r,n]}</span>var al=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >BigInt(e&gt;&gt;&gt;0)&lt;&lt;eo|BigInt(t&gt;&gt;&gt;0);<span class="cstat-no" title="statement not covered" ></span></span>_.toBig=al;v</span>ar ll=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >e&gt;&gt;&gt;r;<span class="cstat-no" title="statement not covered" ></span></span>_.shrSH=ll;v</span>ar cl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >e&lt;&lt;32-r|t&gt;&gt;&gt;r;<span class="cstat-no" title="statement not covered" ></span></span>_.shrSL=cl;v</span>ar ul=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >e&gt;&gt;&gt;r|t&lt;&lt;32-r;<span class="cstat-no" title="statement not covered" ></span></span>_.rotrSH=ul;v</span>ar pl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >e&lt;&lt;32-r|t&gt;&gt;&gt;r;<span class="cstat-no" title="statement not covered" ></span></span>_.rotrSL=pl;v</span>ar ml=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >e&lt;&lt;64-r|t&gt;&gt;&gt;r-32;<span class="cstat-no" title="statement not covered" ></span></span>_.rotrBH=ml;v</span>ar dl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >e&gt;&gt;&gt;r-32|t&lt;&lt;64-r;<span class="cstat-no" title="statement not covered" ></span></span>_.rotrBL=dl;v</span>ar fl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span></span>_.rotr32H=fl;v</span>ar gl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span></span>_.rotr32L=gl;v</span>ar yl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >e&lt;&lt;r|t&gt;&gt;&gt;32-r;<span class="cstat-no" title="statement not covered" ></span></span>_.rotlSH=yl;v</span>ar hl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >t&lt;&lt;r|e&gt;&gt;&gt;32-r;<span class="cstat-no" title="statement not covered" ></span></span>_.rotlSL=hl;v</span>ar wl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >t&lt;&lt;r-32|e&gt;&gt;&gt;64-r;<span class="cstat-no" title="statement not covered" ></span></span>_.rotlBH=wl;v</span>ar bl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >e&lt;&lt;r-32|t&gt;&gt;&gt;64-r;<span class="cstat-no" title="statement not covered" ></span></span>_.rotlBL=bl;f</span>unction <span class="fstat-no" title="function not covered" >El(</span>e,t,r,n){let i=<span class="cstat-no" title="statement not covered" >(t&gt;&gt;&gt;0)+(n&gt;&gt;&gt;0);<span class="cstat-no" title="statement not covered" ></span>return{h:e+r+(i/2**32|0)|0,l:i|0}}</span>var xl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >(e&gt;&gt;&gt;0)+(t&gt;&gt;&gt;0)+(r&gt;&gt;&gt;0);<span class="cstat-no" title="statement not covered" ></span></span>_.add3L=xl;v</span>ar Pl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r,n)=&gt;<span class="cstat-no" title="statement not covered" >t+r+n+(e/2**32|0)|0;<span class="cstat-no" title="statement not covered" ></span></span>_.add3H=Pl;v</span>ar Tl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r,n)=&gt;<span class="cstat-no" title="statement not covered" >(e&gt;&gt;&gt;0)+(t&gt;&gt;&gt;0)+(r&gt;&gt;&gt;0)+(n&gt;&gt;&gt;0);<span class="cstat-no" title="statement not covered" ></span></span>_.add4L=Tl;v</span>ar vl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r,n,i)=&gt;<span class="cstat-no" title="statement not covered" >t+r+n+i+(e/2**32|0)|0;<span class="cstat-no" title="statement not covered" ></span></span>_.add4H=vl;v</span>ar Al=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r,n,i)=&gt;<span class="cstat-no" title="statement not covered" >(e&gt;&gt;&gt;0)+(t&gt;&gt;&gt;0)+(r&gt;&gt;&gt;0)+(n&gt;&gt;&gt;0)+(i&gt;&gt;&gt;0);<span class="cstat-no" title="statement not covered" ></span></span>_.add5L=Al;v</span>ar Rl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r,n,i,o)=&gt;<span class="cstat-no" title="statement not covered" >t+r+n+i+o+(e/2**32|0)|0;<span class="cstat-no" title="statement not covered" ></span></span>_.add5H=Rl;v</span>ar Um=<span class="cstat-no" title="statement not covered" >{fromBig:to,split:sl,toBig:al,shrSH:ll,shrSL:cl,rotrSH:ul,rotrSL:pl,rotrBH:ml,rotrBL:dl,rotr32H:fl,rotr32L:gl,rotlSH:yl,rotlSL:hl,rotlBH:wl,rotlBL:bl,add:El,add3L:xl,add3H:Pl,add4L:Tl,add4H:vl,add5H:Rl,add5L:Al};<span class="cstat-no" title="statement not covered" ></span>_.default=Um}</span>);</span>var Sl=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >$n</span>=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty($n,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >$</span>n.crypto=void 0;v</span>ar He=(<span class="cstat-no" title="statement not covered" >Xe(),qo(xi))</span>;<span class="cstat-no" title="statement not covered" >$n.crypto=He&amp;&amp;typeof He=="object"&amp;&amp;"webcrypto"in He?He.webcrypto:He&amp;&amp;typeof He=="object"&amp;&amp;"randomBytes"in He?He:void 0}</span>);</span>var Ol=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >U=</span>&gt;{"use strict";<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(U,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >U</span>.Hash=U.nextTick=U.byteSwapIfBE=U.isLE=void 0;<span class="cstat-no" title="statement not covered" >U</span>.isBytes=Fm;<span class="cstat-no" title="statement not covered" >U</span>.u8=$m;<span class="cstat-no" title="statement not covered" >U</span>.u32=Vm;<span class="cstat-no" title="statement not covered" >U</span>.createView=qm;<span class="cstat-no" title="statement not covered" >U</span>.rotr=Bm;<span class="cstat-no" title="statement not covered" >U</span>.rotl=jm;<span class="cstat-no" title="statement not covered" >U</span>.byteSwap=io;<span class="cstat-no" title="statement not covered" >U</span>.byteSwap32=Qm;<span class="cstat-no" title="statement not covered" >U</span>.bytesToHex=Gm;<span class="cstat-no" title="statement not covered" >U</span>.hexToBytes=Jm;<span class="cstat-no" title="statement not covered" >U</span>.asyncLoop=Km;<span class="cstat-no" title="statement not covered" >U</span>.utf8ToBytes=kl;<span class="cstat-no" title="statement not covered" >U</span>.toBytes=Vn;<span class="cstat-no" title="statement not covered" >U</span>.concatBytes=zm;<span class="cstat-no" title="statement not covered" >U</span>.checkOpts=Ym;<span class="cstat-no" title="statement not covered" >U</span>.wrapConstructor=Zm;<span class="cstat-no" title="statement not covered" >U</span>.wrapConstructorWithOpts=Xm;<span class="cstat-no" title="statement not covered" >U</span>.wrapXOFConstructorWithOpts=ed;<span class="cstat-no" title="statement not covered" >U</span>.randomBytes=td;v</span>ar Mt=<span class="cstat-no" title="statement not covered" >Sl(),</span>no=<span class="cstat-no" title="statement not covered" >Xi();</span>function <span class="fstat-no" title="function not covered" >Fm(</span>e){<span class="cstat-no" title="statement not covered" >return e instanceof Uint8Array||ArrayBuffer.isView(e)&amp;&amp;e.constructor.name==="Uint8Array"}</span>function <span class="fstat-no" title="function not covered" >$m(</span>e){<span class="cstat-no" title="statement not covered" >return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}</span>function <span class="fstat-no" title="function not covered" >Vm(</span>e){<span class="cstat-no" title="statement not covered" >return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}</span>function <span class="fstat-no" title="function not covered" >qm(</span>e){<span class="cstat-no" title="statement not covered" >return new DataView(e.buffer,e.byteOffset,e.byteLength)}</span>function <span class="fstat-no" title="function not covered" >Bm(</span>e,t){<span class="cstat-no" title="statement not covered" >return e&lt;&lt;32-t|e&gt;&gt;&gt;t}</span>function <span class="fstat-no" title="function not covered" >jm(</span>e,t){<span class="cstat-no" title="statement not covered" >return e&lt;&lt;t|e&gt;&gt;&gt;32-t&gt;&gt;&gt;0}<span class="cstat-no" title="statement not covered" ></span>U.isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;f</span>unction <span class="fstat-no" title="function not covered" >io(</span>e){<span class="cstat-no" title="statement not covered" >return e&lt;&lt;24&amp;4278190080|e&lt;&lt;8&amp;16711680|e&gt;&gt;&gt;8&amp;65280|e&gt;&gt;&gt;24&amp;255}<span class="cstat-no" title="statement not covered" ></span>U.byteSwapIfBE=U.isLE?<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e:<span class="fstat-no" title="function not covered" ></span>e=</span>&gt;<span class="cstat-no" title="statement not covered" >io(e);</span>f</span>unction <span class="fstat-no" title="function not covered" >Qm(</span>e){<span class="cstat-no" title="statement not covered" >for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;e.length;t++)<span class="cstat-no" title="statement not covered" >e[t]=io(e[t])}</span></span>var Hm=<span class="cstat-no" title="statement not covered" >Array.from({length:256},<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >t.toString(16).padStart(2,"0"))</span>;</span>function <span class="fstat-no" title="function not covered" >Gm(</span>e){<span class="cstat-no" title="statement not covered" >(0,no.abytes)(e);l</span>et t=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;e.length;r++)<span class="cstat-no" title="statement not covered" >t+=Hm[e[r]];<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>var Le=<span class="cstat-no" title="statement not covered" >{_0:48,_9:57,A:65,F:70,a:97,f:102};</span>function <span class="fstat-no" title="function not covered" >Il(</span>e){<span class="cstat-no" title="statement not covered" >if(e&gt;=Le._0&amp;&amp;e&lt;=Le._9)<span class="cstat-no" title="statement not covered" >return e-Le._0;<span class="cstat-no" title="statement not covered" >i</span></span>f(e&gt;=Le.A&amp;&amp;e&lt;=Le.F)<span class="cstat-no" title="statement not covered" >return e-(Le.A-10);<span class="cstat-no" title="statement not covered" >i</span></span>f(e&gt;=Le.a&amp;&amp;e&lt;=Le.f)<span class="cstat-no" title="statement not covered" >return e-(Le.a-10)}</span></span>function <span class="fstat-no" title="function not covered" >Jm(</span>e){<span class="cstat-no" title="statement not covered" >if(typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new Error("hex string expected, got "+typeof e);l</span></span>et t=<span class="cstat-no" title="statement not covered" >e.length,</span>r=<span class="cstat-no" title="statement not covered" >t/2;<span class="cstat-no" title="statement not covered" ></span>if(t%2)<span class="cstat-no" title="statement not covered" >throw new Error("hex string expected, got unpadded hex of length "+t);l</span></span>et n=<span class="cstat-no" title="statement not covered" >new Uint8Array(r);<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;r;i++,o+=2){let s=<span class="cstat-no" title="statement not covered" >Il(e.charCodeAt(o)),</span>a=<span class="cstat-no" title="statement not covered" >Il(e.charCodeAt(o+1));<span class="cstat-no" title="statement not covered" ></span>if(s===void 0||a===void 0){let f=<span class="cstat-no" title="statement not covered" >e[o]+e[o+1];<span class="cstat-no" title="statement not covered" ></span>throw new Error('hex string expected, got non-hex character "'+f+'" at index '+o)}<span class="cstat-no" title="statement not covered" ></span>n</span>[i]=s*16+a}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>var Wm=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{};<span class="cstat-no" title="statement not covered" ></span>U.nextTick=Wm;a</span>sync function <span class="fstat-no" title="function not covered" >Km(</span>e,t,r){let n=<span class="cstat-no" title="statement not covered" >Date.now();<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;e;i++){<span class="cstat-no" title="statement not covered" >r(i);l</span>et o=<span class="cstat-no" title="statement not covered" >Date.now()-n;<span class="cstat-no" title="statement not covered" ></span>o&gt;=0&amp;&amp;o&lt;t||(await(0,U.nextTick)(),n+=o)}</span>}</span>function <span class="fstat-no" title="function not covered" >kl(</span>e){<span class="cstat-no" title="statement not covered" >if(typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new Error("utf8ToBytes expected string, got "+typeof e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn new Uint8Array(new TextEncoder().encode(e))}</span>function <span class="fstat-no" title="function not covered" >Vn(</span>e){<span class="cstat-no" title="statement not covered" >return typeof e=="string"&amp;&amp;(e=kl(e)),(0,no.abytes)(e),e}</span>function <span class="fstat-no" title="function not covered" >zm(</span>...e){let t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e.length;n++){let i=<span class="cstat-no" title="statement not covered" >e[n];<span class="cstat-no" title="statement not covered" ></span>(0,no.abytes)(i),t+=i.length}</span>l</span>et r=<span class="cstat-no" title="statement not covered" >new Uint8Array(t);<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e.length;n++){let o=<span class="cstat-no" title="statement not covered" >e[n];<span class="cstat-no" title="statement not covered" ></span>r.set(o,i),i+=o.length}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>var ro=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >cl</span>one(){<span class="cstat-no" title="statement not covered" >return this._cloneInto()}</span>};<span class="cstat-no" title="statement not covered" ></span>U.Hash=ro;f</span>unction <span class="fstat-no" title="function not covered" >Ym(</span>e,t){<span class="cstat-no" title="statement not covered" >if(t!==void 0&amp;&amp;{}.toString.call(t)!=="[object Object]")<span class="cstat-no" title="statement not covered" >throw new Error("Options should be object or undefined");<span class="cstat-no" title="statement not covered" >r</span></span>eturn Object.assign(e,t)}</span>function <span class="fstat-no" title="function not covered" >Zm(</span>e){let t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >e().update(Vn(n)).digest(),</span></span>r=<span class="cstat-no" title="statement not covered" >e();<span class="cstat-no" title="statement not covered" ></span>return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e(),</span>t}</span>function <span class="fstat-no" title="function not covered" >Xm(</span>e){let t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >e(i).update(Vn(n)).digest(),</span></span>r=<span class="cstat-no" title="statement not covered" >e({});<span class="cstat-no" title="statement not covered" ></span>return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >e(n),</span>t}</span>function <span class="fstat-no" title="function not covered" >ed(</span>e){let t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >e(i).update(Vn(n)).digest(),</span></span>r=<span class="cstat-no" title="statement not covered" >e({});<span class="cstat-no" title="statement not covered" ></span>return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >e(n),</span>t}</span>function <span class="fstat-no" title="function not covered" >td(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >32)</span>{<span class="cstat-no" title="statement not covered" >if(Mt.crypto&amp;&amp;typeof Mt.crypto.getRandomValues=="function")<span class="cstat-no" title="statement not covered" >return Mt.crypto.getRandomValues(new Uint8Array(e));<span class="cstat-no" title="statement not covered" >i</span></span>f(Mt.crypto&amp;&amp;typeof Mt.crypto.randomBytes=="function")<span class="cstat-no" title="statement not covered" >return Mt.crypto.randomBytes(e);<span class="cstat-no" title="statement not covered" >t</span></span>hrow new Error("crypto.getRandomValues must be defined")}</span>});</span>var $l=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >J=</span>&gt;{"use strict";<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(J,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >J</span>.shake256=J.shake128=J.keccak_512=J.keccak_384=J.keccak_256=J.keccak_224=J.sha3_512=J.sha3_384=J.sha3_256=J.sha3_224=J.Keccak=void 0;<span class="cstat-no" title="statement not covered" >J</span>.keccakP=Ul;v</span>ar Nt=<span class="cstat-no" title="statement not covered" >Xi(),</span>Pr=<span class="cstat-no" title="statement not covered" >Cl(),</span>Ue=<span class="cstat-no" title="statement not covered" >Ol(),</span>Ml=<span class="cstat-no" title="statement not covered" >[],</span>Nl=<span class="cstat-no" title="statement not covered" >[],</span>Ll=<span class="cstat-no" title="statement not covered" >[],</span>rd=<span class="cstat-no" title="statement not covered" >BigInt(0),</span>xr=<span class="cstat-no" title="statement not covered" >BigInt(1),</span>nd=<span class="cstat-no" title="statement not covered" >BigInt(2),</span>id=<span class="cstat-no" title="statement not covered" >BigInt(7),</span>od=<span class="cstat-no" title="statement not covered" >BigInt(256),</span>sd=<span class="cstat-no" title="statement not covered" >BigInt(113);<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0,</span>t=<span class="cstat-no" title="statement not covered" >xr,</span>r=<span class="cstat-no" title="statement not covered" >1,</span>n=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;24;e++){<span class="cstat-no" title="statement not covered" >[r,n]=[n,(2*r+3*n)%5],Ml.push(2*(5*n+r)),Nl.push((e+1)*(e+2)/2%64);l</span>et i=<span class="cstat-no" title="statement not covered" >rd;<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;7;o++)<span class="cstat-no" title="statement not covered" >t=(t&lt;&lt;xr^(t&gt;&gt;id)*sd)%od,t&amp;nd&amp;&amp;(i^=xr&lt;&lt;(xr&lt;&lt;BigInt(o))-xr);<span class="cstat-no" title="statement not covered" >L</span></span>l.push(i)}</span>v</span>ar[ad,ld]=<span class="cstat-no" title="statement not covered" >(0,Pr.split)(Ll,!0),</span>Dl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >r&gt;32?(0,Pr.rotlBH)(e,t,r):(0,Pr.rotlSH)(e,t,r),</span></span>_l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >r&gt;32?(0,Pr.rotlBL)(e,t,r):(0,Pr.rotlSL)(e,t,r);</span></span>function <span class="fstat-no" title="function not covered" >Ul(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >24)</span>{let r=<span class="cstat-no" title="statement not covered" >new Uint32Array(10);<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >24-t;</span>n&lt;24;n++){<span class="cstat-no" title="statement not covered" >for(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;10;s++)<span class="cstat-no" title="statement not covered" >r[s]=e[s]^e[s+10]^e[s+20]^e[s+30]^e[s+40];<span class="cstat-no" title="statement not covered" >f</span></span>or(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;10;s+=2){let a=<span class="cstat-no" title="statement not covered" >(s+8)%10,</span>f=<span class="cstat-no" title="statement not covered" >(s+2)%10,</span>w=<span class="cstat-no" title="statement not covered" >r[f],</span>A=<span class="cstat-no" title="statement not covered" >r[f+1],</span>R=<span class="cstat-no" title="statement not covered" >Dl(w,A,1)^r[a],</span>S=<span class="cstat-no" title="statement not covered" >_l(w,A,1)^r[a+1];<span class="cstat-no" title="statement not covered" ></span>for(let C=<span class="cstat-no" title="statement not covered" >0;</span>C&lt;50;C+=10)<span class="cstat-no" title="statement not covered" >e[s+C]^=R,e[s+C+1]^=S}</span></span>l</span>et i=<span class="cstat-no" title="statement not covered" >e[2],</span>o=<span class="cstat-no" title="statement not covered" >e[3];<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;24;s++){let a=<span class="cstat-no" title="statement not covered" >Nl[s],</span>f=<span class="cstat-no" title="statement not covered" >Dl(i,o,a),</span>w=<span class="cstat-no" title="statement not covered" >_l(i,o,a),</span>A=<span class="cstat-no" title="statement not covered" >Ml[s];<span class="cstat-no" title="statement not covered" ></span>i=e[A],o=e[A+1],e[A]=f,e[A+1]=w}<span class="cstat-no" title="statement not covered" ></span>f</span>or(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;50;s+=10){<span class="cstat-no" title="statement not covered" >for(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;10;a++)<span class="cstat-no" title="statement not covered" >r[a]=e[s+a];<span class="cstat-no" title="statement not covered" >f</span></span>or(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;10;a++)<span class="cstat-no" title="statement not covered" >e[s+a]^=~r[(a+2)%10]&amp;r[(a+4)%10]}<span class="cstat-no" title="statement not covered" ></span></span>e</span>[0]^=ad[n],e[1]^=ld[n]}<span class="cstat-no" title="statement not covered" ></span>r</span>.fill(0)}</span>var Tr=<span class="cstat-no" title="statement not covered" >class e extends Ue.Hash{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r,n,i=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>o=<span class="branch-0 cbranch-no" title="branch not covered" >24)</span>{<span class="cstat-no" title="statement not covered" >if(super(),this.blockLen=t,this.suffix=r,this.outputLen=n,this.enableXOF=i,this.rounds=o,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,(0,Nt.anumber)(n),0&gt;=this.blockLen||this.blockLen&gt;=200)<span class="cstat-no" title="statement not covered" >throw new Error("Sha3 supports only keccak-f1600 function");<span class="cstat-no" title="statement not covered" >t</span></span>his.state=new Uint8Array(200),this.state32=(0,Ue.u32)(this.state)}<span class="fstat-no" title="function not covered" ></span>ke</span>ccak(){<span class="cstat-no" title="statement not covered" >Ue.isLE||(0,Ue.byteSwap32)(this.state32),Ul(this.state32,this.rounds),Ue.isLE||(0,Ue.byteSwap32)(this.state32),this.posOut=0,this.pos=0}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){<span class="cstat-no" title="statement not covered" >(0,Nt.aexists)(this);l</span>et{blockLen:r,state:n}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t=(0,Ue.toBytes)(t);l</span>et i=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;i;){let s=<span class="cstat-no" title="statement not covered" >Math.min(r-this.pos,i-o);<span class="cstat-no" title="statement not covered" ></span>for(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;s;a++)<span class="cstat-no" title="statement not covered" >n[this.pos++]^=t[o++];<span class="cstat-no" title="statement not covered" >t</span></span>his.pos===r&amp;&amp;this.keccak()}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}<span class="fstat-no" title="function not covered" ></span>fi</span>nish(){<span class="cstat-no" title="statement not covered" >if(this.finished)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.finished=!0;l</span>et{state:t,suffix:r,pos:n,blockLen:i}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t[n]^=r,(r&amp;128)!==0&amp;&amp;n===i-1&amp;&amp;this.keccak(),t[i-1]^=128,this.keccak()}<span class="fstat-no" title="function not covered" ></span>wr</span>iteInto(t){<span class="cstat-no" title="statement not covered" >(0,Nt.aexists)(this,!1),(0,Nt.abytes)(t),this.finish();l</span>et r=<span class="cstat-no" title="statement not covered" >this.state,</span>{blockLen:n}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >t.length;</span>i&lt;o;){<span class="cstat-no" title="statement not covered" >this.posOut&gt;=n&amp;&amp;this.keccak();l</span>et s=<span class="cstat-no" title="statement not covered" >Math.min(n-this.posOut,o-i);<span class="cstat-no" title="statement not covered" ></span>t.set(r.subarray(this.posOut,this.posOut+s),i),this.posOut+=s,i+=s}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}<span class="fstat-no" title="function not covered" ></span>xo</span>fInto(t){<span class="cstat-no" title="statement not covered" >if(!this.enableXOF)<span class="cstat-no" title="statement not covered" >throw new Error("XOF is not possible for this instance");<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.writeInto(t)}<span class="fstat-no" title="function not covered" ></span>xo</span>f(t){<span class="cstat-no" title="statement not covered" >return(0,Nt.anumber)(t),this.xofInto(new Uint8Array(t))}<span class="fstat-no" title="function not covered" ></span>di</span>gestInto(t){<span class="cstat-no" title="statement not covered" >if((0,Nt.aoutput)(t,this),this.finished)<span class="cstat-no" title="statement not covered" >throw new Error("digest() was already called");<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.writeInto(t),this.destroy(),t}<span class="fstat-no" title="function not covered" ></span>di</span>gest(){<span class="cstat-no" title="statement not covered" >return this.digestInto(new Uint8Array(this.outputLen))}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.destroyed=!0,this.state.fill(0)}<span class="fstat-no" title="function not covered" ></span>_c</span>loneInto(t){let{blockLen:r,suffix:n,outputLen:i,rounds:o,enableXOF:s}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return t||(t=new e(r,n,i,s,o)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=o,t.suffix=n,t.outputLen=i,t.enableXOF=s,t.destroyed=this.destroyed,t}</span>};<span class="cstat-no" title="statement not covered" ></span>J.Keccak=Tr;v</span>ar Ge=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >(0,Ue.wrapConstructor)(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >new Tr(t,e,r))</span>;<span class="cstat-no" title="statement not covered" ></span></span>J.sha3_224=Ge(6,144,224/8);<span class="cstat-no" title="statement not covered" >J</span>.sha3_256=Ge(6,136,256/8);<span class="cstat-no" title="statement not covered" >J</span>.sha3_384=Ge(6,104,384/8);<span class="cstat-no" title="statement not covered" >J</span>.sha3_512=Ge(6,72,512/8);<span class="cstat-no" title="statement not covered" >J</span>.keccak_224=Ge(1,144,224/8);<span class="cstat-no" title="statement not covered" >J</span>.keccak_256=Ge(1,136,256/8);<span class="cstat-no" title="statement not covered" >J</span>.keccak_384=Ge(1,104,384/8);<span class="cstat-no" title="statement not covered" >J</span>.keccak_512=Ge(1,72,512/8);v</span>ar Fl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >(0,Ue.wrapXOFConstructorWithOpts)(<span class="fstat-no" title="function not covered" >(n</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" >new Tr(t,e,n.dkLen===void 0?r:n.dkLen,!0))</span>;<span class="cstat-no" title="statement not covered" ></span></span>J.shake128=Fl(31,168,128/8);<span class="cstat-no" title="statement not covered" >J</span>.shake256=Fl(31,136,256/8)}</span>);</span>var Jl=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >(A</span>1,Je)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar{sha3_512:cd}=<span class="cstat-no" title="statement not covered" >$l(),</span>ql=<span class="cstat-no" title="statement not covered" >24,</span>vr=<span class="cstat-no" title="statement not covered" >32,</span>oo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >4,</span>t=<span class="branch-0 cbranch-no" title="branch not covered" >Math.random)</span>=&gt;{let r=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>for(;r.length&lt;e;)<span class="cstat-no" title="statement not covered" >r=r+Math.floor(t()*36).toString(36);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>;</span>function <span class="fstat-no" title="function not covered" >Bl(</span>e){let t=<span class="cstat-no" title="statement not covered" >8n,</span>r=<span class="cstat-no" title="statement not covered" >0n;<span class="cstat-no" title="statement not covered" ></span>for(let n of e.values()){let i=<span class="cstat-no" title="statement not covered" >BigInt(n);<span class="cstat-no" title="statement not covered" ></span>r=(r&lt;&lt;t)+i}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>var jl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >"")</span>=&gt;<span class="cstat-no" title="statement not covered" >Bl(cd(e)).toString(36).slice(1),</span></span>Vl=<span class="cstat-no" title="statement not covered" >Array.from({length:26},<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >String.fromCharCode(t+97))</span>,</span>ud=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >Vl[Math.floor(e()*Vl.length)],</span></span>Ql=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>globalObj:e=<span class="branch-0 cbranch-no" title="branch not covered" >typeof globalThis&lt;"u"?globalThis:typeof window&lt;"u"?window:{},</span>random:t=<span class="branch-0 cbranch-no" title="branch not covered" >Math.random}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let r=<span class="cstat-no" title="statement not covered" >Object.keys(e).toString(),</span>n=<span class="cstat-no" title="statement not covered" >r.length?r+oo(vr,t):oo(vr,t);<span class="cstat-no" title="statement not covered" ></span>return jl(n).substring(0,vr)}</span>,</span>Hl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e++,</span></span></span>pd=<span class="cstat-no" title="statement not covered" >476782367,</span>Gl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>random:e=<span class="branch-0 cbranch-no" title="branch not covered" >Math.random,</span>counter:t=<span class="branch-0 cbranch-no" title="branch not covered" >Hl(Math.floor(e()*pd)),</span>length:r=<span class="branch-0 cbranch-no" title="branch not covered" >ql,</span>fingerprint:n=<span class="branch-0 cbranch-no" title="branch not covered" >Ql({random:e})}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){let o=<span class="cstat-no" title="statement not covered" >ud(e),</span>s=<span class="cstat-no" title="statement not covered" >Date.now().toString(36),</span>a=<span class="cstat-no" title="statement not covered" >t().toString(36),</span>f=<span class="cstat-no" title="statement not covered" >oo(r,e),</span>w=<span class="cstat-no" title="statement not covered" >`${s+f+a+n}`;<span class="cstat-no" title="statement not covered" ></span>return`${o+jl(w).substring(1,r)}`}</span>,</span></span>md=<span class="cstat-no" title="statement not covered" >Gl(),</span>dd=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,{minLength:t=<span class="branch-0 cbranch-no" title="branch not covered" >2,</span>maxLength:r=<span class="branch-0 cbranch-no" title="branch not covered" >vr}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let n=<span class="cstat-no" title="statement not covered" >e.length,</span>i=<span class="cstat-no" title="statement not covered" >/^[0-9a-z]+$/;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >if(typeof e=="string"&amp;&amp;n&gt;=t&amp;&amp;n&lt;=r&amp;&amp;i.test(e))<span class="cstat-no" title="statement not covered" >return!0}</span></span>finally{}<span class="cstat-no" title="statement not covered" >r</span>eturn!1}</span>;<span class="cstat-no" title="statement not covered" ></span>Je.exports.getConstants=<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >{defaultLength:ql,bigLength:vr})</span>;<span class="cstat-no" title="statement not covered" >J</span>e.exports.init=Gl;<span class="cstat-no" title="statement not covered" >J</span>e.exports.createId=md;<span class="cstat-no" title="statement not covered" >J</span>e.exports.bufToBigInt=Bl;<span class="cstat-no" title="statement not covered" >J</span>e.exports.createCounter=Hl;<span class="cstat-no" title="statement not covered" >J</span>e.exports.createFingerprint=Ql;<span class="cstat-no" title="statement not covered" >J</span>e.exports.isCuid=dd}</span>);</span>var Wl=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >(D</span>1,Ar)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar{createId:fd,init:gd,getConstants:yd,isCuid:hd}=<span class="cstat-no" title="statement not covered" >Jl();<span class="cstat-no" title="statement not covered" ></span>Ar.exports.createId=fd;<span class="cstat-no" title="statement not covered" >A</span>r.exports.init=gd;<span class="cstat-no" title="statement not covered" >A</span>r.exports.getConstants=yd;<span class="cstat-no" title="statement not covered" >A</span>r.exports.isCuid=hd}</span>);</span>var Ff=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>pt(Ff,{DMMF:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >or,</span>Debug:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >K,</span>Decimal:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >se,</span>Extensions:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >gi,</span>MetricsClient:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >St,</span>PrismaClientInitializationError:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >F,</span>PrismaClientKnownRequestError:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >X,</span>PrismaClientRustPanicError:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >ae,</span>PrismaClientUnknownRequestError:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >ne,</span>PrismaClientValidationError:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >ie,</span>Public:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >yi,</span>Sql:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >fe,</span>createParam:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >ta,</span>defineDmmfProperty:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >aa,</span>deserializeJsonResponse:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Qe,</span>deserializeRawResult:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >ai,</span>dmmfToRuntimeDataModel:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Ds,</span>empty:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >pa,</span>getPrismaClient:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >eu,</span>getRuntime:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >ti,</span>join:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >ua,</span>makeStrictEnum:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >tu,</span>makeTypedQueryFactory:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >la,</span>objectEnumValues:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >En,</span>raw:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Fi,</span>serializeJsonQuery:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Cn,</span>skip:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Rn,</span>sqltag:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >$i,</span>warnEnvConflicts:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >void 0,</span>warnOnce:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >rr}</span>);<span class="cstat-no" title="statement not covered" >m</span>odule.exports=qo(Ff);<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar gi=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>pt(gi,{defineExtension:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Zo,</span>getExtensionContext:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Xo}</span>);<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Zo(</span>e){<span class="cstat-no" title="statement not covered" >return typeof e=="function"?e:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.$extends(e)}<span class="cstat-no" title="statement not covered" ></span></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Xo(</span>e){<span class="cstat-no" title="statement not covered" >return e}</span>var yi=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>pt(yi,{validator:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >es}</span>);<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >es(</span>...e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t}<span class="cstat-no" title="statement not covered" ></span></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar hi,ts,rs,ns,is=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>typeof g&lt;"u"&amp;&amp;({FORCE_COLOR:hi,NODE_DISABLE_COLORS:ts,NO_COLOR:rs,TERM:ns}=g.env||{},is=g.stdout&amp;&amp;g.stdout.isTTY);v</span>ar Eu=<span class="cstat-no" title="statement not covered" >{enabled:!ts&amp;&amp;rs==null&amp;&amp;ns!=="dumb"&amp;&amp;(hi!=null&amp;&amp;hi!=="0"||is)};</span>function <span class="fstat-no" title="function not covered" >j(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >new RegExp(`\\x1b\\[${t}m`,"g"),</span>n=<span class="cstat-no" title="statement not covered" >`\x1B[${e}m`,</span>i=<span class="cstat-no" title="statement not covered" >`\x1B[${t}m`;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(o){<span class="cstat-no" title="statement not covered" >return!Eu.enabled||o==null?o:n+(~(""+o).indexOf(i)?o.replace(r,i+n):o)+i}</span>}</span>var Lg=<span class="cstat-no" title="statement not covered" >j(0,0),</span>Xr=<span class="cstat-no" title="statement not covered" >j(1,22),</span>en=<span class="cstat-no" title="statement not covered" >j(2,22),</span>Ug=<span class="cstat-no" title="statement not covered" >j(3,23),</span>tn=<span class="cstat-no" title="statement not covered" >j(4,24),</span>Fg=<span class="cstat-no" title="statement not covered" >j(7,27),</span>$g=<span class="cstat-no" title="statement not covered" >j(8,28),</span>Vg=<span class="cstat-no" title="statement not covered" >j(9,29),</span>qg=<span class="cstat-no" title="statement not covered" >j(30,39),</span>ft=<span class="cstat-no" title="statement not covered" >j(31,39),</span>os=<span class="cstat-no" title="statement not covered" >j(32,39),</span>ss=<span class="cstat-no" title="statement not covered" >j(33,39),</span>as=<span class="cstat-no" title="statement not covered" >j(34,39),</span>Bg=<span class="cstat-no" title="statement not covered" >j(35,39),</span>ls=<span class="cstat-no" title="statement not covered" >j(36,39),</span>jg=<span class="cstat-no" title="statement not covered" >j(37,39),</span>cs=<span class="cstat-no" title="statement not covered" >j(90,39),</span>Qg=<span class="cstat-no" title="statement not covered" >j(90,39),</span>Hg=<span class="cstat-no" title="statement not covered" >j(40,49),</span>Gg=<span class="cstat-no" title="statement not covered" >j(41,49),</span>Jg=<span class="cstat-no" title="statement not covered" >j(42,49),</span>Wg=<span class="cstat-no" title="statement not covered" >j(43,49),</span>Kg=<span class="cstat-no" title="statement not covered" >j(44,49),</span>zg=<span class="cstat-no" title="statement not covered" >j(45,49),</span>Yg=<span class="cstat-no" title="statement not covered" >j(46,49),</span>Zg=<span class="cstat-no" title="statement not covered" >j(47,49);<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar xu=<span class="cstat-no" title="statement not covered" >100,</span>us=<span class="cstat-no" title="statement not covered" >["green","yellow","blue","magenta","cyan","red"],</span>zt=<span class="cstat-no" title="statement not covered" >[],</span>ps=<span class="cstat-no" title="statement not covered" >Date.now(),</span>Pu=<span class="cstat-no" title="statement not covered" >0,</span>wi=<span class="cstat-no" title="statement not covered" >typeof g&lt;"u"?g.env:{};<span class="cstat-no" title="statement not covered" ></span>globalThis.DEBUG??=wi.DEBUG??"";<span class="cstat-no" title="statement not covered" >g</span>lobalThis.DEBUG_COLORS??=wi.DEBUG_COLORS?wi.DEBUG_COLORS==="true":!0;v</span>ar Yt=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >en</span>able(e){<span class="cstat-no" title="statement not covered" >typeof e=="string"&amp;&amp;(globalThis.DEBUG=e)}</span>,<span class="fstat-no" title="function not covered" >di</span>sable(){let e=<span class="cstat-no" title="statement not covered" >globalThis.DEBUG;<span class="cstat-no" title="statement not covered" ></span>return globalThis.DEBUG="",e}</span>,<span class="fstat-no" title="function not covered" >en</span>abled(e){let t=<span class="cstat-no" title="statement not covered" >globalThis.DEBUG.split(",").map(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >i.replace(/[.+?^${}()|[\]\\]/g,"\\$&amp;"))</span>,</span>r=<span class="cstat-no" title="statement not covered" >t.some(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >i===""||i[0]==="-"?!1:e.match(RegExp(i.split("*").join(".*")+"$")))</span>,</span>n=<span class="cstat-no" title="statement not covered" >t.some(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >i===""||i[0]!=="-"?!1:e.match(RegExp(i.slice(1).split("*").join(".*")+"$")))</span>;<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;!n}</span>,log:<span class="fstat-no" title="function not covered" >(.</span>..e)=&gt;{let[t,r,...n]=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>(console.warn??console.log)(`${t} ${r}`,...n)}</span>,formatters:{}};</span>function <span class="fstat-no" title="function not covered" >Tu(</span>e){let t=<span class="cstat-no" title="statement not covered" >{color:us[Pu++%us.length],enabled:Yt.enabled(e),namespace:e,log:Yt.log,extend:<span class="fstat-no" title="function not covered" >()</span>=&gt;{}},</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(.</span>..n)=&gt;{let{enabled:i,namespace:o,color:s,log:a}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(n.length!==0&amp;&amp;zt.push([o,...n]),zt.length&gt;xu&amp;&amp;zt.shift(),Yt.enabled(o)||i){let f=<span class="cstat-no" title="statement not covered" >n.map(<span class="fstat-no" title="function not covered" >A=</span>&gt;<span class="cstat-no" title="statement not covered" >typeof A=="string"?A:vu(A))</span>,</span>w=<span class="cstat-no" title="statement not covered" >`+${Date.now()-ps}ms`;<span class="cstat-no" title="statement not covered" ></span>ps=Date.now(),a(o,...f,w)}</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>return new Proxy(r,{get:<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >t[i],</span>set:<span class="fstat-no" title="function not covered" >(n</span>,i,o)=&gt;<span class="cstat-no" title="statement not covered" >t[i]=o}</span>)}</span>var K=<span class="cstat-no" title="statement not covered" >new Proxy(Tu,{get:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >Yt[t],</span>set:<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >Yt[t]=r}</span>);</span>function <span class="fstat-no" title="function not covered" >vu(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >2)</span>{let r=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" ></span>return JSON.stringify(e,<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >if(typeof i=="object"&amp;&amp;i!==null){<span class="cstat-no" title="statement not covered" >if(r.has(i))<span class="cstat-no" title="statement not covered" >return"[Circular *]";<span class="cstat-no" title="statement not covered" >r</span></span>.add(i)}</span>else <span class="cstat-no" title="statement not covered" >if(typeof i=="bigint")<span class="cstat-no" title="statement not covered" >return i.toString();<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn i}</span>,t)}</span>function <span class="fstat-no" title="function not covered" >ms(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >7500)</span>{let t=<span class="cstat-no" title="statement not covered" >zt.map(<span class="fstat-no" title="function not covered" >([</span>r,...n])=&gt;<span class="cstat-no" title="statement not covered" >`${r} ${n.map(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >typeof i=="string"?i:JSON.stringify(i))</span>.join(" ")}`)</span>.join(`</span>
`);<span class="cstat-no" title="statement not covered" >return t.length&lt;e?t:t.slice(-e)}</span>function <span class="fstat-no" title="function not covered" >ds(</span>){<span class="cstat-no" title="statement not covered" >zt.length=0}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Qu=<span class="cstat-no" title="statement not covered" >hs(),</span>Ei=<span class="cstat-no" title="statement not covered" >Qu.version;<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >gt(</span>e){let t=<span class="cstat-no" title="statement not covered" >Zu();<span class="cstat-no" title="statement not covered" ></span>return t||(e?.config.engineType==="library"?"library":e?.config.engineType==="binary"?"binary":e?.config.engineType==="client"?"client":Xu())}</span>function <span class="fstat-no" title="function not covered" >Zu(</span>){let e=<span class="cstat-no" title="statement not covered" >g.env.PRISMA_CLIENT_ENGINE_TYPE;<span class="cstat-no" title="statement not covered" ></span>return e==="library"?"library":e==="binary"?"binary":e==="client"?"client":void 0}</span>function <span class="fstat-no" title="function not covered" >Xu(</span>){<span class="cstat-no" title="statement not covered" >return"library"}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >nn(</span>e){<span class="cstat-no" title="statement not covered" >return e.name==="DriverAdapterError"&amp;&amp;typeof e.cause=="object"}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar O=<span class="cstat-no" title="statement not covered" >{Int32:0,Int64:1,Float:2,Double:3,Numeric:4,Boolean:5,Character:6,Text:7,Date:8,Time:9,DateTime:10,Json:11,Enum:12,Bytes:13,Set:14,Uuid:15,Int32Array:64,Int64Array:65,FloatArray:66,DoubleArray:67,NumericArray:68,BooleanArray:69,CharacterArray:70,TextArray:71,DateArray:72,TimeArray:73,DateTimeArray:74,JsonArray:75,EnumArray:76,BytesArray:77,UuidArray:78,UnknownNumber:128};<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar vs=<span class="cstat-no" title="statement not covered" >"prisma+postgres",</span>ln=<span class="cstat-no" title="statement not covered" >`${vs}:`;</span>function <span class="fstat-no" title="function not covered" >cn(</span>e){<span class="cstat-no" title="statement not covered" >return e?.toString().startsWith(`${ln}//`)??!1}</span>function <span class="fstat-no" title="function not covered" >Ti(</span>e){<span class="cstat-no" title="statement not covered" >if(!cn(e))<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et{host:t}=<span class="cstat-no" title="statement not covered" >new URL(e);<span class="cstat-no" title="statement not covered" ></span>return t.includes("localhost")||t.includes("127.0.0.1")||t.includes("[::1]")}</span>var tr=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>pt(tr,{error:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >np,</span>info:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >rp,</span>log:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >tp,</span>query:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >ip,</span>should:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Cs,</span>tags:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >er,</span>warn:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >vi}</span>);<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar er=<span class="cstat-no" title="statement not covered" >{error:ft("prisma:error"),warn:ss("prisma:warn"),info:ls("prisma:info"),query:as("prisma:query")},</span>Cs=<span class="cstat-no" title="statement not covered" >{warn:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!g.env.PRISMA_DISABLE_WARNINGS}</span>;</span>function <span class="fstat-no" title="function not covered" >tp(</span>...e){<span class="cstat-no" title="statement not covered" >console.log(...e)}</span>function <span class="fstat-no" title="function not covered" >vi(</span>e,...t){<span class="cstat-no" title="statement not covered" >Cs.warn()&amp;&amp;console.warn(`${er.warn} ${e}`,...t)}</span>function <span class="fstat-no" title="function not covered" >rp(</span>e,...t){<span class="cstat-no" title="statement not covered" >console.info(`${er.info} ${e}`,...t)}</span>function <span class="fstat-no" title="function not covered" >np(</span>e,...t){<span class="cstat-no" title="statement not covered" >console.error(`${er.error} ${e}`,...t)}</span>function <span class="fstat-no" title="function not covered" >ip(</span>e,...t){<span class="cstat-no" title="statement not covered" >console.log(`${er.query} ${e}`,...t)}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Me(</span>e,t){<span class="cstat-no" title="statement not covered" >throw new Error(t)}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ai(</span>{onlyFirst:e=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let r=<span class="cstat-no" title="statement not covered" >["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&amp;.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&amp;.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=&gt;&lt;~]))"].join("|");<span class="cstat-no" title="statement not covered" ></span>return new RegExp(r,e?void 0:"g")}</span>var op=<span class="cstat-no" title="statement not covered" >Ai();</span>function <span class="fstat-no" title="function not covered" >ht(</span>e){<span class="cstat-no" title="statement not covered" >if(typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.replace(op,"")}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ri(</span>e,t){<span class="cstat-no" title="statement not covered" >return Object.prototype.hasOwnProperty.call(e,t)}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >pn(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let n of Object.keys(e))<span class="cstat-no" title="statement not covered" >r[n]=t(e[n],n);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ci(</span>e,t){<span class="cstat-no" title="statement not covered" >if(e.length===0)<span class="cstat-no" title="statement not covered" >return;l</span></span>et r=<span class="cstat-no" title="statement not covered" >e[0];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >1;</span>n&lt;e.length;n++)<span class="cstat-no" title="statement not covered" >t(r,e[n])&lt;0&amp;&amp;(r=e[n]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >D(</span>e,t){<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"name",{value:t,configurable:!0})}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Is=<span class="cstat-no" title="statement not covered" >new Set,</span>rr=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,...r)=&gt;{<span class="cstat-no" title="statement not covered" >Is.has(e)||(Is.add(e),vi(t,...r))}</span>;</span>var F=<span class="cstat-no" title="statement not covered" >class e extends Error{clientVersion;errorCode;retryable;<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r,n){<span class="cstat-no" title="statement not covered" >super(t),this.name="PrismaClientInitializationError",this.clientVersion=r,this.errorCode=n,Error.captureStackTrace(e)}<span class="fstat-no" title="function not covered" ></span>ge</span>t[Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientInitializationError"}</span>};<span class="cstat-no" title="statement not covered" ></span>D(F,"PrismaClientInitializationError");<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar X=<span class="cstat-no" title="statement not covered" >class extends Error{code;meta;clientVersion;batchRequestIdx;<span class="fstat-no" title="function not covered" >co</span>nstructor(t,{code:r,clientVersion:n,meta:i,batchRequestIdx:o}){<span class="cstat-no" title="statement not covered" >super(t),this.name="PrismaClientKnownRequestError",this.code=r,this.clientVersion=n,this.meta=i,Object.defineProperty(this,"batchRequestIdx",{value:o,enumerable:!1,writable:!0})}<span class="fstat-no" title="function not covered" ></span>ge</span>t[Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientKnownRequestError"}</span>};<span class="cstat-no" title="statement not covered" ></span>D(X,"PrismaClientKnownRequestError");<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar ae=<span class="cstat-no" title="statement not covered" >class extends Error{clientVersion;<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >super(t),this.name="PrismaClientRustPanicError",this.clientVersion=r}<span class="fstat-no" title="function not covered" ></span>ge</span>t[Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientRustPanicError"}</span>};<span class="cstat-no" title="statement not covered" ></span>D(ae,"PrismaClientRustPanicError");<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar ne=<span class="cstat-no" title="statement not covered" >class extends Error{clientVersion;batchRequestIdx;<span class="fstat-no" title="function not covered" >co</span>nstructor(t,{clientVersion:r,batchRequestIdx:n}){<span class="cstat-no" title="statement not covered" >super(t),this.name="PrismaClientUnknownRequestError",this.clientVersion=r,Object.defineProperty(this,"batchRequestIdx",{value:n,writable:!0,enumerable:!1})}<span class="fstat-no" title="function not covered" ></span>ge</span>t[Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientUnknownRequestError"}</span>};<span class="cstat-no" title="statement not covered" ></span>D(ne,"PrismaClientUnknownRequestError");<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar ie=<span class="cstat-no" title="statement not covered" >class extends Error{name=<span class="cstat-no" title="statement not covered" >"PrismaClientValidationError";</span>clientVersion;<span class="fstat-no" title="function not covered" >co</span>nstructor(t,{clientVersion:r}){<span class="cstat-no" title="statement not covered" >super(t),this.clientVersion=r}<span class="fstat-no" title="function not covered" ></span>ge</span>t[Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientValidationError"}</span>};<span class="cstat-no" title="statement not covered" ></span>D(ie,"PrismaClientValidationError");<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Ce=<span class="cstat-no" title="statement not covered" >class{_map=<span class="cstat-no" title="statement not covered" >new Map;<span class="fstat-no" title="function not covered" ></span>ge</span>t(t){<span class="cstat-no" title="statement not covered" >return this._map.get(t)?.value}<span class="fstat-no" title="function not covered" ></span>se</span>t(t,r){<span class="cstat-no" title="statement not covered" >this._map.set(t,{value:r})}<span class="fstat-no" title="function not covered" ></span>ge</span>tOrCreate(t,r){let n=<span class="cstat-no" title="statement not covered" >this._map.get(t);<span class="cstat-no" title="statement not covered" ></span>if(n)<span class="cstat-no" title="statement not covered" >return n.value;l</span></span>et i=<span class="cstat-no" title="statement not covered" >r();<span class="cstat-no" title="statement not covered" ></span>return this.set(t,i),i}</span>};<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >qe(</span>e){<span class="cstat-no" title="statement not covered" >return e.substring(0,1).toLowerCase()+e.substring(1)}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Os(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let n of e){let i=<span class="cstat-no" title="statement not covered" >n[t];<span class="cstat-no" title="statement not covered" ></span>r[i]=n}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >nr(</span>e){let t;<span class="cstat-no" title="statement not covered" >return{<span class="fstat-no" title="function not covered" >ge</span>t(){<span class="cstat-no" title="statement not covered" >return t||(t={value:e()}),t.value}</span>}}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ds(</span>e){<span class="cstat-no" title="statement not covered" >return{models:Si(e.models),enums:Si(e.enums),types:Si(e.types)}}</span>function <span class="fstat-no" title="function not covered" >Si(</span>e){let t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let{name:r,...n}of e)<span class="cstat-no" title="statement not covered" >t[r]=n;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >wt(</span>e){<span class="cstat-no" title="statement not covered" >return e instanceof Date||Object.prototype.toString.call(e)==="[object Date]"}</span>function <span class="fstat-no" title="function not covered" >mn(</span>e){<span class="cstat-no" title="statement not covered" >return e.toString()!=="Invalid Date"}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >bt(</span>e){<span class="cstat-no" title="statement not covered" >return v.isDecimal(e)?!0:e!==null&amp;&amp;typeof e=="object"&amp;&amp;typeof e.s=="number"&amp;&amp;typeof e.e=="number"&amp;&amp;typeof e.toFixed=="function"&amp;&amp;Array.isArray(e.d)}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar or=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>pt(or,{ModelAction:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >ir,</span>datamodelEnumToSchemaEnum:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >sp}</span>);<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >sp(</span>e){<span class="cstat-no" title="statement not covered" >return{name:e.name,values:e.values.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.name)</span>}}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar ir=<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >B=</span>&gt;(<span class="cstat-no" title="statement not covered" >B.findUnique="findUnique",B.findUniqueOrThrow="findUniqueOrThrow",B.findFirst="findFirst",B.findFirstOrThrow="findFirstOrThrow",B.findMany="findMany",B.create="create",B.createMany="createMany",B.createManyAndReturn="createManyAndReturn",B.update="update",B.updateMany="updateMany",B.updateManyAndReturn="updateManyAndReturn",B.upsert="upsert",B.delete="delete",B.deleteMany="deleteMany",B.groupBy="groupBy",B.count="count",B.aggregate="aggregate",B.findRaw="findRaw",B.aggregateRaw="aggregateRaw",B)</span>)(ir||{});</span>var ap=<span class="cstat-no" title="statement not covered" >$e(Rs());</span>var lp=<span class="cstat-no" title="statement not covered" >{red:ft,gray:cs,dim:en,bold:Xr,underline:tn,highlightSource:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.highlight()}</span>,</span>cp=<span class="cstat-no" title="statement not covered" >{red:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e,</span>gray:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e,</span>dim:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e,</span>bold:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e,</span>underline:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e,</span>highlightSource:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e}</span>;</span>function <span class="fstat-no" title="function not covered" >up(</span>{message:e,originalMethod:t,isPanic:r,callArguments:n}){<span class="cstat-no" title="statement not covered" >return{functionName:`prisma.${t}()`,message:e,isPanic:r??!1,callArguments:n}}</span>function <span class="fstat-no" title="function not covered" >pp(</span>{functionName:e,location:t,message:r,isPanic:n,contextLines:i,callArguments:o},s){let a=<span class="cstat-no" title="statement not covered" >[""],</span>f=<span class="cstat-no" title="statement not covered" >t?" in":":";<span class="cstat-no" title="statement not covered" ></span>if(n?(a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)),a.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)} invocation${f}`))):a.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${f}`)),t&amp;&amp;a.push(s.underline(mp(t))),i){<span class="cstat-no" title="statement not covered" >a.push("");l</span>et w=<span class="cstat-no" title="statement not covered" >[i.toString()];<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;(w.push(o),w.push(s.dim(")"))),a.push(w.join("")),o&amp;&amp;a.push("")}</span>else <span class="cstat-no" title="statement not covered" >a.push(""),o&amp;&amp;a.push(o),a.push("");<span class="cstat-no" title="statement not covered" >r</span></span>eturn a.push(r),a.join(`</span>
`)}function <span class="fstat-no" title="function not covered" >mp(</span>e){let t=<span class="cstat-no" title="statement not covered" >[e.fileName];<span class="cstat-no" title="statement not covered" ></span>return e.lineNumber&amp;&amp;t.push(String(e.lineNumber)),e.columnNumber&amp;&amp;t.push(String(e.columnNumber)),t.join(":")}</span>function <span class="fstat-no" title="function not covered" >dn(</span>e){let t=<span class="cstat-no" title="statement not covered" >e.showColors?lp:cp,</span>r;<span class="cstat-no" title="statement not covered" >return typeof $getTemplateParameters&lt;"u"?r=$getTemplateParameters(e,t):r=up(e),pp(r,t)}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar qs=<span class="cstat-no" title="statement not covered" >$e(Ii());<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ls(</span>e,t,r){let n=<span class="cstat-no" title="statement not covered" >Us(e),</span>i=<span class="cstat-no" title="statement not covered" >dp(n),</span>o=<span class="cstat-no" title="statement not covered" >gp(i);<span class="cstat-no" title="statement not covered" ></span>o?fn(o,t,r):t.addErrorMessage(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >"Unknown error")</span>}</span>function <span class="fstat-no" title="function not covered" >Us(</span>e){<span class="cstat-no" title="statement not covered" >return e.errors.flatMap(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.kind==="Union"?Us(t):[t])</span>}</span>function <span class="fstat-no" title="function not covered" >dp(</span>e){let t=<span class="cstat-no" title="statement not covered" >new Map,</span>r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let n of e){<span class="cstat-no" title="statement not covered" >if(n.kind!=="InvalidArgumentType"){<span class="cstat-no" title="statement not covered" >r.push(n);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et i=<span class="cstat-no" title="statement not covered" >`${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`,</span>o=<span class="cstat-no" title="statement not covered" >t.get(i);<span class="cstat-no" title="statement not covered" ></span>o?t.set(i,{...n,argument:{...n.argument,typeNames:fp(o.argument.typeNames,n.argument.typeNames)}}):t.set(i,n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r.push(...t.values()),r}</span>function <span class="fstat-no" title="function not covered" >fp(</span>e,t){<span class="cstat-no" title="statement not covered" >return[...new Set(e.concat(t))]}</span>function <span class="fstat-no" title="function not covered" >gp(</span>e){<span class="cstat-no" title="statement not covered" >return Ci(e,<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >Ms(t),</span>i=<span class="cstat-no" title="statement not covered" >Ms(r);<span class="cstat-no" title="statement not covered" ></span>return n!==i?n-i:Ns(t)-Ns(r)}</span>)}</span>function <span class="fstat-no" title="function not covered" >Ms(</span>e){let t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return Array.isArray(e.selectionPath)&amp;&amp;(t+=e.selectionPath.length),Array.isArray(e.argumentPath)&amp;&amp;(t+=e.argumentPath.length),t}</span>function <span class="fstat-no" title="function not covered" >Ns(</span>e){<span class="cstat-no" title="statement not covered" >switch(e.kind){case"InvalidArgumentValue":case"ValueTooLarge":<span class="cstat-no" title="statement not covered" >return 20;c</span>ase"InvalidArgumentType":<span class="cstat-no" title="statement not covered" >return 10;c</span>ase"RequiredArgumentMissing":<span class="cstat-no" title="statement not covered" >return-10;d</span>efault:<span class="cstat-no" title="statement not covered" >return 0}</span>}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar we=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >this.name=t;<span class="cstat-no" title="statement not covered" >t</span>his.value=r}</span>isRequired=<span class="cstat-no" title="statement not covered" >!1;<span class="fstat-no" title="function not covered" ></span>ma</span>keRequired(){<span class="cstat-no" title="statement not covered" >return this.isRequired=!0,this}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(t){let{colors:{green:r}}=<span class="cstat-no" title="statement not covered" >t.context;<span class="cstat-no" title="statement not covered" ></span>t.addMarginSymbol(r(this.isRequired?"+":"?")),t.write(r(this.name)),this.isRequired||t.write(r("?")),t.write(r(": ")),typeof this.value=="string"?t.write(r(this.value)):t.write(this.value)}</span>};<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >$</span>s();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Et=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>r){<span class="cstat-no" title="statement not covered" >this.context=r;<span class="cstat-no" title="statement not covered" >t</span>his.currentIndent=t}</span>lines=<span class="cstat-no" title="statement not covered" >[];</span>currentLine=<span class="cstat-no" title="statement not covered" >"";</span>currentIndent=<span class="cstat-no" title="statement not covered" >0;</span>marginSymbol;afterNextNewLineCallback;<span class="fstat-no" title="function not covered" >wr</span>ite(t){<span class="cstat-no" title="statement not covered" >return typeof t=="string"?this.currentLine+=t:t.write(this),this}<span class="fstat-no" title="function not covered" ></span>wr</span>iteJoined(t,r,n=<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >(i</span>,o)=&gt;<span class="cstat-no" title="statement not covered" >o.write(i))</span></span>{let i=<span class="cstat-no" title="statement not covered" >r.length-1;<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;r.length;o++)<span class="cstat-no" title="statement not covered" >n(r[o],this),o!==i&amp;&amp;this.write(t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}<span class="fstat-no" title="function not covered" ></span>wr</span>iteLine(t){<span class="cstat-no" title="statement not covered" >return this.write(t).newLine()}<span class="fstat-no" title="function not covered" ></span>ne</span>wLine(){<span class="cstat-no" title="statement not covered" >this.lines.push(this.indentedCurrentLine()),this.currentLine="",this.marginSymbol=void 0;l</span>et t=<span class="cstat-no" title="statement not covered" >this.afterNextNewLineCallback;<span class="cstat-no" title="statement not covered" ></span>return this.afterNextNewLineCallback=void 0,t?.(),this}<span class="fstat-no" title="function not covered" ></span>wi</span>thIndent(t){<span class="cstat-no" title="statement not covered" >return this.indent(),t(this),this.unindent(),this}<span class="fstat-no" title="function not covered" ></span>af</span>terNextNewline(t){<span class="cstat-no" title="statement not covered" >return this.afterNextNewLineCallback=t,this}<span class="fstat-no" title="function not covered" ></span>in</span>dent(){<span class="cstat-no" title="statement not covered" >return this.currentIndent++,this}<span class="fstat-no" title="function not covered" ></span>un</span>indent(){<span class="cstat-no" title="statement not covered" >return this.currentIndent&gt;0&amp;&amp;this.currentIndent--,this}<span class="fstat-no" title="function not covered" ></span>ad</span>dMarginSymbol(t){<span class="cstat-no" title="statement not covered" >return this.marginSymbol=t,this}<span class="fstat-no" title="function not covered" ></span>to</span>String(){<span class="cstat-no" title="statement not covered" >return this.lines.concat(this.indentedCurrentLine()).join(`</span></span>
`)}<span class="fstat-no" title="function not covered" >ge</span>tCurrentLineLength(){<span class="cstat-no" title="statement not covered" >return this.currentLine.length}<span class="fstat-no" title="function not covered" ></span>in</span>dentedCurrentLine(){let t=<span class="cstat-no" title="statement not covered" >this.currentLine.padStart(this.currentLine.length+2*this.currentIndent);<span class="cstat-no" title="statement not covered" ></span>return this.marginSymbol?this.marginSymbol+t.slice(1):t}</span>};<span class="cstat-no" title="statement not covered" >Fs();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar gn=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.value=t}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(t){<span class="cstat-no" title="statement not covered" >t.write(this.value)}<span class="fstat-no" title="function not covered" ></span>ma</span>rkAsError(){<span class="cstat-no" title="statement not covered" >this.value.markAsError()}</span>};<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar yn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e,</span></span>hn=<span class="cstat-no" title="statement not covered" >{bold:yn,red:yn,green:yn,dim:yn,enabled:!1},</span>Vs=<span class="cstat-no" title="statement not covered" >{bold:Xr,red:ft,green:os,dim:en,enabled:!0},</span>xt=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >wr</span>ite(e){<span class="cstat-no" title="statement not covered" >e.writeLine(",")}</span>};<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Se=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.contents=t}</span>isUnderlined=<span class="cstat-no" title="statement not covered" >!1;</span>color=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t;<span class="fstat-no" title="function not covered" ></span></span>un</span>derline(){<span class="cstat-no" title="statement not covered" >return this.isUnderlined=!0,this}<span class="fstat-no" title="function not covered" ></span>se</span>tColor(t){<span class="cstat-no" title="statement not covered" >return this.color=t,this}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(t){let r=<span class="cstat-no" title="statement not covered" >t.getCurrentLineLength();<span class="cstat-no" title="statement not covered" ></span>t.write(this.color(this.contents)),this.isUnderlined&amp;&amp;t.afterNextNewline(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.write(" ".repeat(r)).writeLine(this.color("~".repeat(this.contents.length)))}</span>)}</span>};<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Be=<span class="cstat-no" title="statement not covered" >class{hasError=<span class="cstat-no" title="statement not covered" >!1;<span class="fstat-no" title="function not covered" ></span>ma</span>rkAsError(){<span class="cstat-no" title="statement not covered" >return this.hasError=!0,this}</span>};</span>var Pt=<span class="cstat-no" title="statement not covered" >class extends Be{items=<span class="cstat-no" title="statement not covered" >[];<span class="fstat-no" title="function not covered" ></span>ad</span>dItem(t){<span class="cstat-no" title="statement not covered" >return this.items.push(new gn(t)),this}<span class="fstat-no" title="function not covered" ></span>ge</span>tField(t){<span class="cstat-no" title="statement not covered" >return this.items[t]}<span class="fstat-no" title="function not covered" ></span>ge</span>tPrintWidth(){<span class="cstat-no" title="statement not covered" >return this.items.length===0?2:Math.max(...this.items.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r.value.getPrintWidth())</span>)+2}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(t){<span class="cstat-no" title="statement not covered" >if(this.items.length===0){<span class="cstat-no" title="statement not covered" >this.writeEmpty(t);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>t</span>his.writeWithItems(t)}<span class="fstat-no" title="function not covered" ></span>wr</span>iteEmpty(t){let r=<span class="cstat-no" title="statement not covered" >new Se("[]");<span class="cstat-no" title="statement not covered" ></span>this.hasError&amp;&amp;r.setColor(t.context.colors.red).underline(),t.write(r)}<span class="fstat-no" title="function not covered" ></span>wr</span>iteWithItems(t){let{colors:r}=<span class="cstat-no" title="statement not covered" >t.context;<span class="cstat-no" title="statement not covered" ></span>t.writeLine("[").withIndent(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.writeJoined(xt,this.items).newLine())</span>.write("]"),this.hasError&amp;&amp;t.afterNextNewline(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.writeLine(r.red("~".repeat(this.getPrintWidth())))}</span>)}<span class="fstat-no" title="function not covered" ></span>as</span>Object(){}};</span>var Tt=<span class="cstat-no" title="statement not covered" >class e extends Be{fields=<span class="cstat-no" title="statement not covered" >{};</span>suggestions=<span class="cstat-no" title="statement not covered" >[];<span class="fstat-no" title="function not covered" ></span>ad</span>dField(t){<span class="cstat-no" title="statement not covered" >this.fields[t.name]=t}<span class="fstat-no" title="function not covered" ></span>ad</span>dSuggestion(t){<span class="cstat-no" title="statement not covered" >this.suggestions.push(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>tField(t){<span class="cstat-no" title="statement not covered" >return this.fields[t]}<span class="fstat-no" title="function not covered" ></span>ge</span>tDeepField(t){let[r,...n]=<span class="cstat-no" title="statement not covered" >t,</span>i=<span class="cstat-no" title="statement not covered" >this.getField(r);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return;l</span></span>et o=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>for(let s of n){let a;<span class="cstat-no" title="statement not covered" >if(o.value instanceof e?a=o.value.getField(s):o.value instanceof Pt&amp;&amp;(a=o.value.getField(Number(s))),!a)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >o</span></span>=a}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o}<span class="fstat-no" title="function not covered" ></span>ge</span>tDeepFieldValue(t){<span class="cstat-no" title="statement not covered" >return t.length===0?this:this.getDeepField(t)?.value}<span class="fstat-no" title="function not covered" ></span>ha</span>sField(t){<span class="cstat-no" title="statement not covered" >return!!this.getField(t)}<span class="fstat-no" title="function not covered" ></span>re</span>moveAllFields(){<span class="cstat-no" title="statement not covered" >this.fields={}}<span class="fstat-no" title="function not covered" ></span>re</span>moveField(t){<span class="cstat-no" title="statement not covered" >delete this.fields[t]}<span class="fstat-no" title="function not covered" ></span>ge</span>tFields(){<span class="cstat-no" title="statement not covered" >return this.fields}<span class="fstat-no" title="function not covered" ></span>is</span>Empty(){<span class="cstat-no" title="statement not covered" >return Object.keys(this.fields).length===0}<span class="fstat-no" title="function not covered" ></span>ge</span>tFieldValue(t){<span class="cstat-no" title="statement not covered" >return this.getField(t)?.value}<span class="fstat-no" title="function not covered" ></span>ge</span>tDeepSubSelectionValue(t){let r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(let n of t){<span class="cstat-no" title="statement not covered" >if(!(r instanceof e))<span class="cstat-no" title="statement not covered" >return;l</span></span>et i=<span class="cstat-no" title="statement not covered" >r.getSubSelectionValue(n);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >r</span></span>=i}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}<span class="fstat-no" title="function not covered" ></span>ge</span>tDeepSelectionParent(t){let r=<span class="cstat-no" title="statement not covered" >this.getSelectionParent();<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >return;l</span></span>et n=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>for(let i of t){let o=<span class="cstat-no" title="statement not covered" >n.value.getFieldValue(i);<span class="cstat-no" title="statement not covered" ></span>if(!o||!(o instanceof e))<span class="cstat-no" title="statement not covered" >return;l</span></span>et s=<span class="cstat-no" title="statement not covered" >o.getSelectionParent();<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >n</span></span>=s}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}<span class="fstat-no" title="function not covered" ></span>ge</span>tSelectionParent(){let t=<span class="cstat-no" title="statement not covered" >this.getField("select")?.value.asObject();<span class="cstat-no" title="statement not covered" ></span>if(t)<span class="cstat-no" title="statement not covered" >return{kind:"select",value:t};l</span></span>et r=<span class="cstat-no" title="statement not covered" >this.getField("include")?.value.asObject();<span class="cstat-no" title="statement not covered" ></span>if(r)<span class="cstat-no" title="statement not covered" >return{kind:"include",value:r}}<span class="fstat-no" title="function not covered" ></span></span>ge</span>tSubSelectionValue(t){<span class="cstat-no" title="statement not covered" >return this.getSelectionParent()?.value.fields[t].value}<span class="fstat-no" title="function not covered" ></span>ge</span>tPrintWidth(){let t=<span class="cstat-no" title="statement not covered" >Object.values(this.fields);<span class="cstat-no" title="statement not covered" ></span>return t.length==0?2:Math.max(...t.map(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >n.getPrintWidth())</span>)+2}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(t){let r=<span class="cstat-no" title="statement not covered" >Object.values(this.fields);<span class="cstat-no" title="statement not covered" ></span>if(r.length===0&amp;&amp;this.suggestions.length===0){<span class="cstat-no" title="statement not covered" >this.writeEmpty(t);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>t</span>his.writeWithContents(t,r)}<span class="fstat-no" title="function not covered" ></span>as</span>Object(){<span class="cstat-no" title="statement not covered" >return this}<span class="fstat-no" title="function not covered" ></span>wr</span>iteEmpty(t){let r=<span class="cstat-no" title="statement not covered" >new Se("{}");<span class="cstat-no" title="statement not covered" ></span>this.hasError&amp;&amp;r.setColor(t.context.colors.red).underline(),t.write(r)}<span class="fstat-no" title="function not covered" ></span>wr</span>iteWithContents(t,r){<span class="cstat-no" title="statement not covered" >t.writeLine("{").withIndent(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.writeJoined(xt,[...r,...this.suggestions]).newLine()}</span>),t.write("}"),this.hasError&amp;&amp;t.afterNextNewline(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.writeLine(t.context.colors.red("~".repeat(this.getPrintWidth())))}</span>)}</span>};<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar re=<span class="cstat-no" title="statement not covered" >class extends Be{<span class="fstat-no" title="function not covered" >co</span>nstructor(r){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.text=r}<span class="fstat-no" title="function not covered" ></span>ge</span>tPrintWidth(){<span class="cstat-no" title="statement not covered" >return this.text.length}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(r){let n=<span class="cstat-no" title="statement not covered" >new Se(this.text);<span class="cstat-no" title="statement not covered" ></span>this.hasError&amp;&amp;n.underline().setColor(r.context.colors.red),r.write(n)}<span class="fstat-no" title="function not covered" ></span>as</span>Object(){}};<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar sr=<span class="cstat-no" title="statement not covered" >class{fields=<span class="cstat-no" title="statement not covered" >[];<span class="fstat-no" title="function not covered" ></span>ad</span>dField(t,r){<span class="cstat-no" title="statement not covered" >return this.fields.push({<span class="fstat-no" title="function not covered" >wr</span>ite(n){let{green:i,dim:o}=<span class="cstat-no" title="statement not covered" >n.context.colors;<span class="cstat-no" title="statement not covered" ></span>n.write(i(o(`${t}: ${r}`))).addMarginSymbol(i(o("+")))}</span>}),this}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(t){let{colors:{green:r}}=<span class="cstat-no" title="statement not covered" >t.context;<span class="cstat-no" title="statement not covered" ></span>t.writeLine(r("{")).withIndent(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.writeJoined(xt,this.fields).newLine()}</span>).write(r("}")).addMarginSymbol(r("+"))}</span>};</span>function <span class="fstat-no" title="function not covered" >fn(</span>e,t,r){<span class="cstat-no" title="statement not covered" >switch(e.kind){case"MutuallyExclusiveFields":<span class="cstat-no" title="statement not covered" >yp(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"IncludeOnScalar":<span class="cstat-no" title="statement not covered" >hp(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"EmptySelection":<span class="cstat-no" title="statement not covered" >wp(e,t,r);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"UnknownSelectionField":<span class="cstat-no" title="statement not covered" >Pp(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"InvalidSelectionValue":<span class="cstat-no" title="statement not covered" >Tp(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"UnknownArgument":<span class="cstat-no" title="statement not covered" >vp(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"UnknownInputField":<span class="cstat-no" title="statement not covered" >Ap(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"RequiredArgumentMissing":<span class="cstat-no" title="statement not covered" >Rp(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"InvalidArgumentType":<span class="cstat-no" title="statement not covered" >Cp(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"InvalidArgumentValue":<span class="cstat-no" title="statement not covered" >Sp(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"ValueTooLarge":<span class="cstat-no" title="statement not covered" >Ip(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"SomeFieldsMissing":<span class="cstat-no" title="statement not covered" >kp(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"TooManyFieldsGiven":<span class="cstat-no" title="statement not covered" >Op(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"Union":<span class="cstat-no" title="statement not covered" >Ls(e,t,r);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("not implemented: "+e.kind)}</span>}</span>function <span class="fstat-no" title="function not covered" >yp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;(r.getField(e.firstField)?.markAsError(),r.getField(e.secondField)?.markAsError()),t.addErrorMessage(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >`Please ${n.bold("either")} use ${n.green(`\`${e.firstField}\``)} or ${n.green(`\`${e.secondField}\``)}, but ${n.red("not both")} at the same time.`)</span>}</span>function <span class="fstat-no" title="function not covered" >hp(</span>e,t){let[r,n]=<span class="cstat-no" title="statement not covered" >vt(e.selectionPath),</span>i=<span class="cstat-no" title="statement not covered" >e.outputType,</span>o=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSelectionParent(r)?.value;<span class="cstat-no" title="statement not covered" ></span>if(o&amp;&amp;(o.getField(n)?.markAsError(),i))<span class="cstat-no" title="statement not covered" >for(let s of i.fields)<span class="cstat-no" title="statement not covered" >s.isRelation&amp;&amp;o.addSuggestion(new we(s.name,"true"));<span class="cstat-no" title="statement not covered" >t</span></span></span>.addErrorMessage(<span class="fstat-no" title="function not covered" >s=</span>&gt;{let a=<span class="cstat-no" title="statement not covered" >`Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;<span class="cstat-no" title="statement not covered" ></span>return i?a+=` on model ${s.bold(i.name)}. ${ar(s)}`:a+=".",a+=`</span></span>
Note that ${s.bold("include")} statements only accept relation fields.`,a})}function <span class="fstat-no" title="function not covered" >wp(</span>e,t,r){let n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ></span>if(n){let i=<span class="cstat-no" title="statement not covered" >n.getField("omit")?.value.asObject();<span class="cstat-no" title="statement not covered" ></span>if(i){<span class="cstat-no" title="statement not covered" >bp(e,t,i);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(n.hasField("select")){<span class="cstat-no" title="statement not covered" >Ep(e,t);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r?.[qe(e.outputType.name)]){<span class="cstat-no" title="statement not covered" >xp(e,t);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>t</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >`Unknown field at "${e.selectionPath.join(".")} selection"`)</span>}</span>function <span class="fstat-no" title="function not covered" >bp(</span>e,t,r){<span class="cstat-no" title="statement not covered" >r.removeAllFields();<span class="cstat-no" title="statement not covered" >f</span>or(let n of e.outputType.fields)<span class="cstat-no" title="statement not covered" >r.addSuggestion(new we(n.name,"false"));<span class="cstat-no" title="statement not covered" >t</span></span>.addErrorMessage(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >`The ${n.red("omit")} statement includes every field of the model ${n.bold(e.outputType.name)}. At least one field must be included in the result`)</span>}</span>function <span class="fstat-no" title="function not covered" >Ep(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >e.outputType,</span>n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSelectionParent(e.selectionPath)?.value,</span>i=<span class="cstat-no" title="statement not covered" >n?.isEmpty()??!1;<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;(n.removeAllFields(),Qs(n,r)),t.addErrorMessage(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >i?`The ${o.red("`select`")} statement for type ${o.bold(r.name)} must not be empty. ${ar(o)}`:`The ${o.red("`select`")} statement for type ${o.bold(r.name)} needs ${o.bold("at least one truthy value")}.`)</span>}</span>function <span class="fstat-no" title="function not covered" >xp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >new sr;<span class="cstat-no" title="statement not covered" ></span>for(let i of e.outputType.fields)<span class="cstat-no" title="statement not covered" >i.isRelation||r.addField(i.name,"false");l</span></span>et n=<span class="cstat-no" title="statement not covered" >new we("omit",r).makeRequired();<span class="cstat-no" title="statement not covered" ></span>if(e.selectionPath.length===0)<span class="cstat-no" title="statement not covered" >t.arguments.addSuggestion(n);e</span>lse{let[i,o]=<span class="cstat-no" title="statement not covered" >vt(e.selectionPath),</span>a=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSelectionParent(i)?.value.asObject()?.getField(o);<span class="cstat-no" title="statement not covered" ></span>if(a){let f=<span class="cstat-no" title="statement not covered" >a?.value.asObject()??new Tt;<span class="cstat-no" title="statement not covered" ></span>f.addSuggestion(n),a.value=f}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >`The global ${i.red("omit")} configuration excludes every field of the model ${i.bold(e.outputType.name)}. At least one field must be included in the result`)</span>}</span>function <span class="fstat-no" title="function not covered" >Pp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >Hs(e.selectionPath,t);<span class="cstat-no" title="statement not covered" ></span>if(r.parentKind!=="unknown"){<span class="cstat-no" title="statement not covered" >r.field.markAsError();l</span>et n=<span class="cstat-no" title="statement not covered" >r.parent;<span class="cstat-no" title="statement not covered" ></span>switch(r.parentKind){case"select":<span class="cstat-no" title="statement not covered" >Qs(n,e.outputType);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"include":<span class="cstat-no" title="statement not covered" >Dp(n,e.outputType);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"omit":<span class="cstat-no" title="statement not covered" >_p(n,e.outputType);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >n=</span>&gt;{let i=<span class="cstat-no" title="statement not covered" >[`Unknown field ${n.red(`\`${r.fieldName}\``)}`];<span class="cstat-no" title="statement not covered" ></span>return r.parentKind!=="unknown"&amp;&amp;i.push(`for ${n.bold(r.parentKind)} statement`),i.push(`on model ${n.bold(`\`${e.outputType.name}\``)}.`),i.push(ar(n)),i.join(" ")}</span>)}</span>function <span class="fstat-no" title="function not covered" >Tp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >Hs(e.selectionPath,t);<span class="cstat-no" title="statement not covered" ></span>r.parentKind!=="unknown"&amp;&amp;r.field.value.markAsError(),t.addErrorMessage(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >`Invalid value for selection field \`${n.red(r.fieldName)}\`: ${e.underlyingError}`)</span>}</span>function <span class="fstat-no" title="function not covered" >vp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >e.argumentPath[0],</span>n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;(n.getField(r)?.markAsError(),Mp(n,e.arguments)),t.addErrorMessage(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >Bs(i,r,e.arguments.map(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >o.name)</span>))</span>}</span>function <span class="fstat-no" title="function not covered" >Ap(</span>e,t){let[r,n]=<span class="cstat-no" title="statement not covered" >vt(e.argumentPath),</span>i=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ></span>if(i){<span class="cstat-no" title="statement not covered" >i.getDeepField(e.argumentPath)?.markAsError();l</span>et o=<span class="cstat-no" title="statement not covered" >i.getDeepFieldValue(r)?.asObject();<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;Gs(o,e.inputType)}<span class="cstat-no" title="statement not covered" ></span>t</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >Bs(o,n,e.inputType.fields.map(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >s.name)</span>))</span>}</span>function <span class="fstat-no" title="function not covered" >Bs(</span>e,t,r){let n=<span class="cstat-no" title="statement not covered" >[`Unknown argument \`${e.red(t)}\`.`],</span>i=<span class="cstat-no" title="statement not covered" >Lp(t,r);<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;n.push(`Did you mean \`${e.green(i)}\`?`),r.length&gt;0&amp;&amp;n.push(ar(e)),n.join(" ")}</span>function <span class="fstat-no" title="function not covered" >Rp(</span>e,t){let r;<span class="cstat-no" title="statement not covered" >t.addErrorMessage(<span class="fstat-no" title="function not covered" >f=</span>&gt;<span class="cstat-no" title="statement not covered" >r?.value instanceof re&amp;&amp;r.value.text==="null"?`Argument \`${f.green(o)}\` must not be ${f.red("null")}.`:`Argument \`${f.green(o)}\` is missing.`)</span>;l</span>et n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >return;l</span></span>et[i,o]=<span class="cstat-no" title="statement not covered" >vt(e.argumentPath),</span>s=<span class="cstat-no" title="statement not covered" >new sr,</span>a=<span class="cstat-no" title="statement not covered" >n.getDeepFieldValue(i)?.asObject();<span class="cstat-no" title="statement not covered" ></span>if(a){<span class="cstat-no" title="statement not covered" >if(r=a.getField(o),r&amp;&amp;a.removeField(o),e.inputTypes.length===1&amp;&amp;e.inputTypes[0].kind==="object"){<span class="cstat-no" title="statement not covered" >for(let f of e.inputTypes[0].fields)<span class="cstat-no" title="statement not covered" >s.addField(f.name,f.typeNames.join(" | "));<span class="cstat-no" title="statement not covered" >a</span></span>.addSuggestion(new we(o,s).makeRequired())}</span>else{let f=<span class="cstat-no" title="statement not covered" >e.inputTypes.map(js).join(" | ");<span class="cstat-no" title="statement not covered" ></span>a.addSuggestion(new we(o,f).makeRequired())}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e.dependentArgumentPath){<span class="cstat-no" title="statement not covered" >n.getDeepField(e.dependentArgumentPath)?.markAsError();l</span>et[,f]=<span class="cstat-no" title="statement not covered" >vt(e.dependentArgumentPath);<span class="cstat-no" title="statement not covered" ></span>t.addErrorMessage(<span class="fstat-no" title="function not covered" >w=</span>&gt;<span class="cstat-no" title="statement not covered" >`Argument \`${w.green(o)}\` is required because argument \`${w.green(f)}\` was provided.`)</span>}</span>}</span>}</span>function <span class="fstat-no" title="function not covered" >js(</span>e){<span class="cstat-no" title="statement not covered" >return e.kind==="list"?`${js(e.elementType)}[]`:e.name}</span>function <span class="fstat-no" title="function not covered" >Cp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >e.argument.name,</span>n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;n.getDeepFieldValue(e.argumentPath)?.markAsError(),t.addErrorMessage(<span class="fstat-no" title="function not covered" >i=</span>&gt;{let o=<span class="cstat-no" title="statement not covered" >wn("or",e.argument.typeNames.map(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >i.green(s))</span>);<span class="cstat-no" title="statement not covered" ></span>return`Argument \`${i.bold(r)}\`: Invalid value provided. Expected ${o}, provided ${i.red(e.inferredType)}.`}</span>)}</span>function <span class="fstat-no" title="function not covered" >Sp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >e.argument.name,</span>n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;n.getDeepFieldValue(e.argumentPath)?.markAsError(),t.addErrorMessage(<span class="fstat-no" title="function not covered" >i=</span>&gt;{let o=<span class="cstat-no" title="statement not covered" >[`Invalid value for argument \`${i.bold(r)}\``];<span class="cstat-no" title="statement not covered" ></span>if(e.underlyingError&amp;&amp;o.push(`: ${e.underlyingError}`),o.push("."),e.argument.typeNames.length&gt;0){let s=<span class="cstat-no" title="statement not covered" >wn("or",e.argument.typeNames.map(<span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >i.green(a))</span>);<span class="cstat-no" title="statement not covered" ></span>o.push(` Expected ${s}.`)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o.join("")}</span>)}</span>function <span class="fstat-no" title="function not covered" >Ip(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >e.argument.name,</span>n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),</span>i;<span class="cstat-no" title="statement not covered" >if(n){let s=<span class="cstat-no" title="statement not covered" >n.getDeepField(e.argumentPath)?.value;<span class="cstat-no" title="statement not covered" ></span>s?.markAsError(),s instanceof re&amp;&amp;(i=s.text)}<span class="cstat-no" title="statement not covered" ></span>t</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >o=</span>&gt;{let s=<span class="cstat-no" title="statement not covered" >["Unable to fit value"];<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;s.push(o.red(i)),s.push(`into a 64-bit signed integer for field \`${o.bold(r)}\``),s.join(" ")}</span>)}</span>function <span class="fstat-no" title="function not covered" >kp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >e.argumentPath[e.argumentPath.length-1],</span>n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ></span>if(n){let i=<span class="cstat-no" title="statement not covered" >n.getDeepFieldValue(e.argumentPath)?.asObject();<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;Gs(i,e.inputType)}<span class="cstat-no" title="statement not covered" ></span>t</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >i=</span>&gt;{let o=<span class="cstat-no" title="statement not covered" >[`Argument \`${i.bold(r)}\` of type ${i.bold(e.inputType.name)} needs`];<span class="cstat-no" title="statement not covered" ></span>return e.constraints.minFieldCount===1?e.constraints.requiredFields?o.push(`${i.green("at least one of")} ${wn("or",e.constraints.requiredFields.map(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >`\`${i.bold(s)}\``)</span>)} arguments.`):o.push(`${i.green("at least one")} argument.`):o.push(`${i.green(`at least ${e.constraints.minFieldCount}`)} arguments.`),o.push(ar(i)),o.join(" ")}</span>)}</span>function <span class="fstat-no" title="function not covered" >Op(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >e.argumentPath[e.argumentPath.length-1],</span>n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),</span>i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(n){let o=<span class="cstat-no" title="statement not covered" >n.getDeepFieldValue(e.argumentPath)?.asObject();<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;(o.markAsError(),i=Object.keys(o.getFields()))}<span class="cstat-no" title="statement not covered" ></span>t</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >o=</span>&gt;{let s=<span class="cstat-no" title="statement not covered" >[`Argument \`${o.bold(r)}\` of type ${o.bold(e.inputType.name)} needs`];<span class="cstat-no" title="statement not covered" ></span>return e.constraints.minFieldCount===1&amp;&amp;e.constraints.maxFieldCount==1?s.push(`${o.green("exactly one")} argument,`):e.constraints.maxFieldCount==1?s.push(`${o.green("at most one")} argument,`):s.push(`${o.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`),s.push(`but you provided ${wn("and",i.map(<span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >o.red(a))</span>)}. Please choose`),e.constraints.maxFieldCount===1?s.push("one."):s.push(`${e.constraints.maxFieldCount}.`),s.join(" ")}</span>)}</span>function <span class="fstat-no" title="function not covered" >Qs(</span>e,t){<span class="cstat-no" title="statement not covered" >for(let r of t.fields)<span class="cstat-no" title="statement not covered" >e.hasField(r.name)||e.addSuggestion(new we(r.name,"true"))}</span></span>function <span class="fstat-no" title="function not covered" >Dp(</span>e,t){<span class="cstat-no" title="statement not covered" >for(let r of t.fields)<span class="cstat-no" title="statement not covered" >r.isRelation&amp;&amp;!e.hasField(r.name)&amp;&amp;e.addSuggestion(new we(r.name,"true"))}</span></span>function <span class="fstat-no" title="function not covered" >_p(</span>e,t){<span class="cstat-no" title="statement not covered" >for(let r of t.fields)<span class="cstat-no" title="statement not covered" >!e.hasField(r.name)&amp;&amp;!r.isRelation&amp;&amp;e.addSuggestion(new we(r.name,"true"))}</span></span>function <span class="fstat-no" title="function not covered" >Mp(</span>e,t){<span class="cstat-no" title="statement not covered" >for(let r of t)<span class="cstat-no" title="statement not covered" >e.hasField(r.name)||e.addSuggestion(new we(r.name,r.typeNames.join(" | ")))}</span></span>function <span class="fstat-no" title="function not covered" >Hs(</span>e,t){let[r,n]=<span class="cstat-no" title="statement not covered" >vt(e),</span>i=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(r)?.asObject();<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return{parentKind:"unknown",fieldName:n};l</span></span>et o=<span class="cstat-no" title="statement not covered" >i.getFieldValue("select")?.asObject(),</span>s=<span class="cstat-no" title="statement not covered" >i.getFieldValue("include")?.asObject(),</span>a=<span class="cstat-no" title="statement not covered" >i.getFieldValue("omit")?.asObject(),</span>f=<span class="cstat-no" title="statement not covered" >o?.getField(n);<span class="cstat-no" title="statement not covered" ></span>return o&amp;&amp;f?{parentKind:"select",parent:o,field:f,fieldName:n}:(f=s?.getField(n),s&amp;&amp;f?{parentKind:"include",field:f,parent:s,fieldName:n}:(f=a?.getField(n),a&amp;&amp;f?{parentKind:"omit",field:f,parent:a,fieldName:n}:{parentKind:"unknown",fieldName:n}))}</span>function <span class="fstat-no" title="function not covered" >Gs(</span>e,t){<span class="cstat-no" title="statement not covered" >if(t.kind==="object")<span class="cstat-no" title="statement not covered" >for(let r of t.fields)<span class="cstat-no" title="statement not covered" >e.hasField(r.name)||e.addSuggestion(new we(r.name,r.typeNames.join(" | ")))}</span></span></span>function <span class="fstat-no" title="function not covered" >vt(</span>e){let t=<span class="cstat-no" title="statement not covered" >[...e],</span>r=<span class="cstat-no" title="statement not covered" >t.pop();<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >throw new Error("unexpected empty path");<span class="cstat-no" title="statement not covered" >r</span></span>eturn[t,r]}</span>function <span class="fstat-no" title="function not covered" >ar(</span>{green:e,enabled:t}){<span class="cstat-no" title="statement not covered" >return"Available options are "+(t?`listed in ${e("green")}`:"marked with ?")+"."}</span>function <span class="fstat-no" title="function not covered" >wn(</span>e,t){<span class="cstat-no" title="statement not covered" >if(t.length===1)<span class="cstat-no" title="statement not covered" >return t[0];l</span></span>et r=<span class="cstat-no" title="statement not covered" >[...t],</span>n=<span class="cstat-no" title="statement not covered" >r.pop();<span class="cstat-no" title="statement not covered" ></span>return`${r.join(", ")} ${e} ${n}`}</span>var Np=<span class="cstat-no" title="statement not covered" >3;</span>function <span class="fstat-no" title="function not covered" >Lp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >1/0,</span>n;<span class="cstat-no" title="statement not covered" >for(let i of t){let o=<span class="cstat-no" title="statement not covered" >(0,qs.default)(e,i);<span class="cstat-no" title="statement not covered" ></span>o&gt;Np||o&lt;r&amp;&amp;(r=o,n=i)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar lr=<span class="cstat-no" title="statement not covered" >class{modelName;name;typeName;isList;isEnum;<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r,n,i,o){<span class="cstat-no" title="statement not covered" >this.modelName=t,this.name=r,this.typeName=n,this.isList=i,this.isEnum=o}<span class="fstat-no" title="function not covered" ></span>_t</span>oGraphQLInputType(){let t=<span class="cstat-no" title="statement not covered" >this.isList?"List":"",</span>r=<span class="cstat-no" title="statement not covered" >this.isEnum?"Enum":"";<span class="cstat-no" title="statement not covered" ></span>return`${t}${r}${this.typeName}FieldRefInput&lt;${this.modelName}&gt;`}</span>};</span>function <span class="fstat-no" title="function not covered" >At(</span>e){<span class="cstat-no" title="statement not covered" >return e instanceof lr}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar bn=<span class="cstat-no" title="statement not covered" >Symbol(),</span>Oi=<span class="cstat-no" title="statement not covered" >new WeakMap,</span>Ne=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >t===bn?Oi.set(this,`Prisma.${this._getName()}`):Oi.set(this,`new Prisma.${this._getNamespace()}.${this._getName()}()`)}<span class="fstat-no" title="function not covered" ></span>_g</span>etName(){<span class="cstat-no" title="statement not covered" >return this.constructor.name}<span class="fstat-no" title="function not covered" ></span>to</span>String(){<span class="cstat-no" title="statement not covered" >return Oi.get(this)}</span>},</span>cr=<span class="cstat-no" title="statement not covered" >class extends Ne{<span class="fstat-no" title="function not covered" >_g</span>etNamespace(){<span class="cstat-no" title="statement not covered" >return"NullTypes"}</span>},</span>ur=<span class="cstat-no" title="statement not covered" >class extends cr{#t};<span class="cstat-no" title="statement not covered" ></span>Di(ur,"DbNull");v</span>ar pr=<span class="cstat-no" title="statement not covered" >class extends cr{#t};<span class="cstat-no" title="statement not covered" ></span>Di(pr,"JsonNull");v</span>ar mr=<span class="cstat-no" title="statement not covered" >class extends cr{#t};<span class="cstat-no" title="statement not covered" ></span>Di(mr,"AnyNull");v</span>ar En=<span class="cstat-no" title="statement not covered" >{classes:{DbNull:ur,JsonNull:pr,AnyNull:mr},instances:{DbNull:new ur(bn),JsonNull:new pr(bn),AnyNull:new mr(bn)}};</span>function <span class="fstat-no" title="function not covered" >Di(</span>e,t){<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"name",{value:t,configurable:!0})}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Js=<span class="cstat-no" title="statement not covered" >": ",</span>xn=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >this.name=t;<span class="cstat-no" title="statement not covered" >t</span>his.value=r}</span>hasError=<span class="cstat-no" title="statement not covered" >!1;<span class="fstat-no" title="function not covered" ></span>ma</span>rkAsError(){<span class="cstat-no" title="statement not covered" >this.hasError=!0}<span class="fstat-no" title="function not covered" ></span>ge</span>tPrintWidth(){<span class="cstat-no" title="statement not covered" >return this.name.length+this.value.getPrintWidth()+Js.length}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(t){let r=<span class="cstat-no" title="statement not covered" >new Se(this.name);<span class="cstat-no" title="statement not covered" ></span>this.hasError&amp;&amp;r.underline().setColor(t.context.colors.red),t.write(r).write(Js).write(this.value)}</span>};</span>var _i=<span class="cstat-no" title="statement not covered" >class{arguments;errorMessages=<span class="cstat-no" title="statement not covered" >[];<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.arguments=t}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(t){<span class="cstat-no" title="statement not covered" >t.write(this.arguments)}<span class="fstat-no" title="function not covered" ></span>ad</span>dErrorMessage(t){<span class="cstat-no" title="statement not covered" >this.errorMessages.push(t)}<span class="fstat-no" title="function not covered" ></span>re</span>nderAllMessages(t){<span class="cstat-no" title="statement not covered" >return this.errorMessages.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r(t))</span>.join(`</span></span>
`)}};function <span class="fstat-no" title="function not covered" >Rt(</span>e){<span class="cstat-no" title="statement not covered" >return new _i(Ws(e))}</span>function <span class="fstat-no" title="function not covered" >Ws(</span>e){let t=<span class="cstat-no" title="statement not covered" >new Tt;<span class="cstat-no" title="statement not covered" ></span>for(let[r,n]of Object.entries(e)){let i=<span class="cstat-no" title="statement not covered" >new xn(r,Ks(n));<span class="cstat-no" title="statement not covered" ></span>t.addField(i)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Ks(</span>e){<span class="cstat-no" title="statement not covered" >if(typeof e=="string")<span class="cstat-no" title="statement not covered" >return new re(JSON.stringify(e));<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof e=="number"||typeof e=="boolean")<span class="cstat-no" title="statement not covered" >return new re(String(e));<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof e=="bigint")<span class="cstat-no" title="statement not covered" >return new re(`${e}n`);<span class="cstat-no" title="statement not covered" >i</span></span>f(e===null)<span class="cstat-no" title="statement not covered" >return new re("null");<span class="cstat-no" title="statement not covered" >i</span></span>f(e===void 0)<span class="cstat-no" title="statement not covered" >return new re("undefined");<span class="cstat-no" title="statement not covered" >i</span></span>f(bt(e))<span class="cstat-no" title="statement not covered" >return new re(`new Prisma.Decimal("${e.toFixed()}")`);<span class="cstat-no" title="statement not covered" >i</span></span>f(e instanceof Uint8Array)<span class="cstat-no" title="statement not covered" >return y.isBuffer(e)?new re(`Buffer.alloc(${e.byteLength})`):new re(`new Uint8Array(${e.byteLength})`);<span class="cstat-no" title="statement not covered" >i</span></span>f(e instanceof Date){let t=<span class="cstat-no" title="statement not covered" >mn(e)?e.toISOString():"Invalid Date";<span class="cstat-no" title="statement not covered" ></span>return new re(`new Date("${t}")`)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e instanceof Ne?new re(`Prisma.${e._getName()}`):At(e)?new re(`prisma.${qe(e.modelName)}.$fields.${e.name}`):Array.isArray(e)?Up(e):typeof e=="object"?Ws(e):new re(Object.prototype.toString.call(e))}</span>function <span class="fstat-no" title="function not covered" >Up(</span>e){let t=<span class="cstat-no" title="statement not covered" >new Pt;<span class="cstat-no" title="statement not covered" ></span>for(let r of e)<span class="cstat-no" title="statement not covered" >t.addItem(Ks(r));<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Pn(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >t==="pretty"?Vs:hn,</span>n=<span class="cstat-no" title="statement not covered" >e.renderAllMessages(r),</span>i=<span class="cstat-no" title="statement not covered" >new Et(0,{colors:r}).write(e).toString();<span class="cstat-no" title="statement not covered" ></span>return{message:n,args:i}}</span>function <span class="fstat-no" title="function not covered" >Tn(</span>{args:e,errors:t,errorFormat:r,callsite:n,originalMethod:i,clientVersion:o,globalOmit:s}){let a=<span class="cstat-no" title="statement not covered" >Rt(e);<span class="cstat-no" title="statement not covered" ></span>for(let R of t)<span class="cstat-no" title="statement not covered" >fn(R,a,s);l</span></span>et{message:f,args:w}=<span class="cstat-no" title="statement not covered" >Pn(a,r),</span>A=<span class="cstat-no" title="statement not covered" >dn({message:f,callsite:n,originalMethod:i,showColors:r==="pretty",callArguments:w});<span class="cstat-no" title="statement not covered" ></span>throw new ie(A,{clientVersion:o})}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ie(</span>e){<span class="cstat-no" title="statement not covered" >return e.replace(/^./,<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.toLowerCase())</span>}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ys(</span>e,t,r){let n=<span class="cstat-no" title="statement not covered" >Ie(r);<span class="cstat-no" title="statement not covered" ></span>return!t.result||!(t.result.$allModels||t.result[n])?e:Fp({...e,...zs(t.name,e,t.result.$allModels),...zs(t.name,e,t.result[n])})}</span>function <span class="fstat-no" title="function not covered" >Fp(</span>e){let t=<span class="cstat-no" title="statement not covered" >new Ce,</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >t.getOrCreate(n,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >i.has(n)?[n]:(i.add(n),e[n]?e[n].needs.flatMap(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >r(o,i))</span>:[n]))</span>;<span class="cstat-no" title="statement not covered" ></span></span>return pn(e,<span class="fstat-no" title="function not covered" >n=</span>&gt;(<span class="cstat-no" title="statement not covered" >{...n,needs:r(n.name,new Set)})</span>)}</span>function <span class="fstat-no" title="function not covered" >zs(</span>e,t,r){<span class="cstat-no" title="statement not covered" >return r?pn(r,<span class="fstat-no" title="function not covered" >({</span>needs:n,compute:i},o)=&gt;(<span class="cstat-no" title="statement not covered" >{name:o,needs:n?Object.keys(n).filter(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >n[s])</span>:[],compute:$p(t,o,i)})</span>):{}}</span>function <span class="fstat-no" title="function not covered" >$p(</span>e,t,r){let n=<span class="cstat-no" title="statement not covered" >e?.[t]?.compute;<span class="cstat-no" title="statement not covered" ></span>return n?<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >r({...i,[t]:n(i)}):</span>r}</span>function <span class="fstat-no" title="function not covered" >Zs(</span>e,t){<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return e;l</span></span>et r=<span class="cstat-no" title="statement not covered" >{...e};<span class="cstat-no" title="statement not covered" ></span>for(let n of Object.values(t))<span class="cstat-no" title="statement not covered" >if(e[n.name])<span class="cstat-no" title="statement not covered" >for(let i of n.needs)<span class="cstat-no" title="statement not covered" >r[i]=!0;<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >Xs(</span>e,t){<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return e;l</span></span>et r=<span class="cstat-no" title="statement not covered" >{...e};<span class="cstat-no" title="statement not covered" ></span>for(let n of Object.values(t))<span class="cstat-no" title="statement not covered" >if(!e[n.name])<span class="cstat-no" title="statement not covered" >for(let i of n.needs)<span class="cstat-no" title="statement not covered" >delete r[i];<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn r}</span>var vn=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >this.extension=t;<span class="cstat-no" title="statement not covered" >t</span>his.previous=r}</span>computedFieldsCache=<span class="cstat-no" title="statement not covered" >new Ce;</span>modelExtensionsCache=<span class="cstat-no" title="statement not covered" >new Ce;</span>queryCallbacksCache=<span class="cstat-no" title="statement not covered" >new Ce;</span>clientExtensions=<span class="cstat-no" title="statement not covered" >nr(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.extension.client?{...this.previous?.getAllClientExtensions(),...this.extension.client}:this.previous?.getAllClientExtensions())</span>;</span>batchCallbacks=<span class="cstat-no" title="statement not covered" >nr(<span class="fstat-no" title="function not covered" >()</span>=&gt;{let t=<span class="cstat-no" title="statement not covered" >this.previous?.getAllBatchQueryCallbacks()??[],</span>r=<span class="cstat-no" title="statement not covered" >this.extension.query?.$__internalBatch;<span class="cstat-no" title="statement not covered" ></span>return r?t.concat(r):t}</span>);<span class="fstat-no" title="function not covered" ></span>ge</span>tAllComputedFields(t){<span class="cstat-no" title="statement not covered" >return this.computedFieldsCache.getOrCreate(t,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Ys(this.previous?.getAllComputedFields(t),this.extension,t))</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tAllClientExtensions(){<span class="cstat-no" title="statement not covered" >return this.clientExtensions.get()}<span class="fstat-no" title="function not covered" ></span>ge</span>tAllModelExtensions(t){<span class="cstat-no" title="statement not covered" >return this.modelExtensionsCache.getOrCreate(t,<span class="fstat-no" title="function not covered" >()</span>=&gt;{let r=<span class="cstat-no" title="statement not covered" >Ie(t);<span class="cstat-no" title="statement not covered" ></span>return!this.extension.model||!(this.extension.model[r]||this.extension.model.$allModels)?this.previous?.getAllModelExtensions(t):{...this.previous?.getAllModelExtensions(t),...this.extension.model.$allModels,...this.extension.model[r]}}</span>)}<span class="fstat-no" title="function not covered" ></span>ge</span>tAllQueryCallbacks(t,r){<span class="cstat-no" title="statement not covered" >return this.queryCallbacksCache.getOrCreate(`${t}:${r}`,<span class="fstat-no" title="function not covered" >()</span>=&gt;{let n=<span class="cstat-no" title="statement not covered" >this.previous?.getAllQueryCallbacks(t,r)??[],</span>i=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >this.extension.query;<span class="cstat-no" title="statement not covered" ></span>return!o||!(o[t]||o.$allModels||o[r]||o.$allOperations)?n:(o[t]!==void 0&amp;&amp;(o[t][r]!==void 0&amp;&amp;i.push(o[t][r]),o[t].$allOperations!==void 0&amp;&amp;i.push(o[t].$allOperations)),t!=="$none"&amp;&amp;o.$allModels!==void 0&amp;&amp;(o.$allModels[r]!==void 0&amp;&amp;i.push(o.$allModels[r]),o.$allModels.$allOperations!==void 0&amp;&amp;i.push(o.$allModels.$allOperations)),o[r]!==void 0&amp;&amp;i.push(o[r]),o.$allOperations!==void 0&amp;&amp;i.push(o.$allOperations),n.concat(i))}</span>)}<span class="fstat-no" title="function not covered" ></span>ge</span>tAllBatchQueryCallbacks(){<span class="cstat-no" title="statement not covered" >return this.batchCallbacks.get()}</span>},</span>Ct=<span class="cstat-no" title="statement not covered" >class e{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.head=t}<span class="fstat-no" title="function not covered" ></span>st</span>atic empty(){<span class="cstat-no" title="statement not covered" >return new e}<span class="fstat-no" title="function not covered" ></span>st</span>atic single(t){<span class="cstat-no" title="statement not covered" >return new e(new vn(t))}<span class="fstat-no" title="function not covered" ></span>is</span>Empty(){<span class="cstat-no" title="statement not covered" >return this.head===void 0}<span class="fstat-no" title="function not covered" ></span>ap</span>pend(t){<span class="cstat-no" title="statement not covered" >return new e(new vn(t,this.head))}<span class="fstat-no" title="function not covered" ></span>ge</span>tAllComputedFields(t){<span class="cstat-no" title="statement not covered" >return this.head?.getAllComputedFields(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>tAllClientExtensions(){<span class="cstat-no" title="statement not covered" >return this.head?.getAllClientExtensions()}<span class="fstat-no" title="function not covered" ></span>ge</span>tAllModelExtensions(t){<span class="cstat-no" title="statement not covered" >return this.head?.getAllModelExtensions(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>tAllQueryCallbacks(t,r){<span class="cstat-no" title="statement not covered" >return this.head?.getAllQueryCallbacks(t,r)??[]}<span class="fstat-no" title="function not covered" ></span>ge</span>tAllBatchQueryCallbacks(){<span class="cstat-no" title="statement not covered" >return this.head?.getAllBatchQueryCallbacks()??[]}</span>};<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar An=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.name=t}</span>};</span>function <span class="fstat-no" title="function not covered" >ea(</span>e){<span class="cstat-no" title="statement not covered" >return e instanceof An}</span>function <span class="fstat-no" title="function not covered" >ta(</span>e){<span class="cstat-no" title="statement not covered" >return new An(e)}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar ra=<span class="cstat-no" title="statement not covered" >Symbol(),</span>dr=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >if(t!==ra)<span class="cstat-no" title="statement not covered" >throw new Error("Skip instance can not be constructed directly")}<span class="fstat-no" title="function not covered" ></span></span>if</span>Undefined(t){<span class="cstat-no" title="statement not covered" >return t===void 0?Rn:t}</span>},</span>Rn=<span class="cstat-no" title="statement not covered" >new dr(ra);</span>function <span class="fstat-no" title="function not covered" >ke(</span>e){<span class="cstat-no" title="statement not covered" >return e instanceof dr}</span>var Vp=<span class="cstat-no" title="statement not covered" >{findUnique:"findUnique",findUniqueOrThrow:"findUniqueOrThrow",findFirst:"findFirst",findFirstOrThrow:"findFirstOrThrow",findMany:"findMany",count:"aggregate",create:"createOne",createMany:"createMany",createManyAndReturn:"createManyAndReturn",update:"updateOne",updateMany:"updateMany",updateManyAndReturn:"updateManyAndReturn",upsert:"upsertOne",delete:"deleteOne",deleteMany:"deleteMany",executeRaw:"executeRaw",queryRaw:"queryRaw",aggregate:"aggregate",groupBy:"groupBy",runCommandRaw:"runCommandRaw",findRaw:"findRaw",aggregateRaw:"aggregateRaw"},</span>na=<span class="cstat-no" title="statement not covered" >"explicitly `undefined` values are not allowed";</span>function <span class="fstat-no" title="function not covered" >Cn(</span>{modelName:e,action:t,args:r,runtimeDataModel:n,extensions:i=<span class="branch-0 cbranch-no" title="branch not covered" >Ct.empty(),</span>callsite:o,clientMethod:s,errorFormat:a,clientVersion:f,previewFeatures:w,globalOmit:A}){let R=<span class="cstat-no" title="statement not covered" >new Mi({runtimeDataModel:n,modelName:e,action:t,rootArgs:r,callsite:o,extensions:i,selectionPath:[],argumentPath:[],originalMethod:s,errorFormat:a,clientVersion:f,previewFeatures:w,globalOmit:A});<span class="cstat-no" title="statement not covered" ></span>return{modelName:e,action:Vp[t],query:fr(r,R)}}</span>function <span class="fstat-no" title="function not covered" >fr(</span>{select:e,include:t,...r}=<span class="branch-0 cbranch-no" title="branch not covered" >{},</span>n){let i=<span class="cstat-no" title="statement not covered" >r.omit;<span class="cstat-no" title="statement not covered" ></span>return delete r.omit,{arguments:oa(r,n),selection:qp(e,t,i,n)}}</span>function <span class="fstat-no" title="function not covered" >qp(</span>e,t,r,n){<span class="cstat-no" title="statement not covered" >return e?(t?n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"include",secondField:"select",selectionPath:n.getSelectionPath()}):r&amp;&amp;n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"omit",secondField:"select",selectionPath:n.getSelectionPath()}),Hp(e,n)):Bp(n,t,r)}</span>function <span class="fstat-no" title="function not covered" >Bp(</span>e,t,r){let n=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return e.modelOrType&amp;&amp;!e.isRawAction()&amp;&amp;(n.$composites=!0,n.$scalars=!0),t&amp;&amp;jp(n,t,e),Qp(n,r,e),n}</span>function <span class="fstat-no" title="function not covered" >jp(</span>e,t,r){<span class="cstat-no" title="statement not covered" >for(let[n,i]of Object.entries(t)){<span class="cstat-no" title="statement not covered" >if(ke(i))<span class="cstat-no" title="statement not covered" >continue;l</span></span>et o=<span class="cstat-no" title="statement not covered" >r.nestSelection(n);<span class="cstat-no" title="statement not covered" ></span>if(Ni(i,o),i===!1||i===void 0){<span class="cstat-no" title="statement not covered" >e[n]=!1;<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et s=<span class="cstat-no" title="statement not covered" >r.findField(n);<span class="cstat-no" title="statement not covered" ></span>if(s&amp;&amp;s.kind!=="object"&amp;&amp;r.throwValidationError({kind:"IncludeOnScalar",selectionPath:r.getSelectionPath().concat(n),outputType:r.getOutputTypeDescription()}),s){<span class="cstat-no" title="statement not covered" >e[n]=fr(i===!0?{}:i,o);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(i===!0){<span class="cstat-no" title="statement not covered" >e[n]=!0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>e</span>[n]=fr(i,o)}</span>}</span>function <span class="fstat-no" title="function not covered" >Qp(</span>e,t,r){let n=<span class="cstat-no" title="statement not covered" >r.getComputedFields(),</span>i=<span class="cstat-no" title="statement not covered" >{...r.getGlobalOmit(),...t},</span>o=<span class="cstat-no" title="statement not covered" >Xs(i,n);<span class="cstat-no" title="statement not covered" ></span>for(let[s,a]of Object.entries(o)){<span class="cstat-no" title="statement not covered" >if(ke(a))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >N</span></span>i(a,r.nestSelection(s));l</span>et f=<span class="cstat-no" title="statement not covered" >r.findField(s);<span class="cstat-no" title="statement not covered" ></span>n?.[s]&amp;&amp;!f||(e[s]=!a)}</span>}</span>function <span class="fstat-no" title="function not covered" >Hp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >{},</span>n=<span class="cstat-no" title="statement not covered" >t.getComputedFields(),</span>i=<span class="cstat-no" title="statement not covered" >Zs(e,n);<span class="cstat-no" title="statement not covered" ></span>for(let[o,s]of Object.entries(i)){<span class="cstat-no" title="statement not covered" >if(ke(s))<span class="cstat-no" title="statement not covered" >continue;l</span></span>et a=<span class="cstat-no" title="statement not covered" >t.nestSelection(o);<span class="cstat-no" title="statement not covered" ></span>Ni(s,a);l</span>et f=<span class="cstat-no" title="statement not covered" >t.findField(o);<span class="cstat-no" title="statement not covered" ></span>if(!(n?.[o]&amp;&amp;!f)){<span class="cstat-no" title="statement not covered" >if(s===!1||s===void 0||ke(s)){<span class="cstat-no" title="statement not covered" >r[o]=!1;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s===!0){<span class="cstat-no" title="statement not covered" >f?.kind==="object"?r[o]=fr({},a):r[o]=!0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>r</span>[o]=fr(s,a)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>function <span class="fstat-no" title="function not covered" >ia(</span>e,t){<span class="cstat-no" title="statement not covered" >if(e===null)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof e=="string"||typeof e=="number"||typeof e=="boolean")<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof e=="bigint")<span class="cstat-no" title="statement not covered" >return{$type:"BigInt",value:String(e)};<span class="cstat-no" title="statement not covered" >i</span></span>f(wt(e)){<span class="cstat-no" title="statement not covered" >if(mn(e))<span class="cstat-no" title="statement not covered" >return{$type:"DateTime",value:e.toISOString()};<span class="cstat-no" title="statement not covered" >t</span></span>.throwValidationError({kind:"InvalidArgumentValue",selectionPath:t.getSelectionPath(),argumentPath:t.getArgumentPath(),argument:{name:t.getArgumentName(),typeNames:["Date"]},underlyingError:"Provided Date object is invalid"})}<span class="cstat-no" title="statement not covered" ></span>i</span>f(ea(e))<span class="cstat-no" title="statement not covered" >return{$type:"Param",value:e.name};<span class="cstat-no" title="statement not covered" >i</span></span>f(At(e))<span class="cstat-no" title="statement not covered" >return{$type:"FieldRef",value:{_ref:e.name,_container:e.modelName}};<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(e))<span class="cstat-no" title="statement not covered" >return Gp(e,t);<span class="cstat-no" title="statement not covered" >i</span></span>f(ArrayBuffer.isView(e)){let{buffer:r,byteOffset:n,byteLength:i}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return{$type:"Bytes",value:y.from(r,n,i).toString("base64")}}<span class="cstat-no" title="statement not covered" ></span>i</span>f(Jp(e))<span class="cstat-no" title="statement not covered" >return e.values;<span class="cstat-no" title="statement not covered" >i</span></span>f(bt(e))<span class="cstat-no" title="statement not covered" >return{$type:"Decimal",value:e.toFixed()};<span class="cstat-no" title="statement not covered" >i</span></span>f(e instanceof Ne){<span class="cstat-no" title="statement not covered" >if(e!==En.instances[e._getName()])<span class="cstat-no" title="statement not covered" >throw new Error("Invalid ObjectEnumValue");<span class="cstat-no" title="statement not covered" >r</span></span>eturn{$type:"Enum",value:e._getName()}}<span class="cstat-no" title="statement not covered" ></span>i</span>f(Wp(e))<span class="cstat-no" title="statement not covered" >return e.toJSON();<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof e=="object")<span class="cstat-no" title="statement not covered" >return oa(e,t);<span class="cstat-no" title="statement not covered" >t</span></span>.throwValidationError({kind:"InvalidArgumentValue",selectionPath:t.getSelectionPath(),argumentPath:t.getArgumentPath(),argument:{name:t.getArgumentName(),typeNames:[]},underlyingError:`We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it`})}</span>function <span class="fstat-no" title="function not covered" >oa(</span>e,t){<span class="cstat-no" title="statement not covered" >if(e.$type)<span class="cstat-no" title="statement not covered" >return{$type:"Raw",value:e};l</span></span>et r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let n in e){let i=<span class="cstat-no" title="statement not covered" >e[n],</span>o=<span class="cstat-no" title="statement not covered" >t.nestArgument(n);<span class="cstat-no" title="statement not covered" ></span>ke(i)||(i!==void 0?r[n]=ia(i,o):t.isPreviewFeatureOn("strictUndefinedChecks")&amp;&amp;t.throwValidationError({kind:"InvalidArgumentValue",argumentPath:o.getArgumentPath(),selectionPath:t.getSelectionPath(),argument:{name:t.getArgumentName(),typeNames:[]},underlyingError:na}))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>function <span class="fstat-no" title="function not covered" >Gp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e.length;n++){let i=<span class="cstat-no" title="statement not covered" >t.nestArgument(String(n)),</span>o=<span class="cstat-no" title="statement not covered" >e[n];<span class="cstat-no" title="statement not covered" ></span>if(o===void 0||ke(o)){let s=<span class="cstat-no" title="statement not covered" >o===void 0?"undefined":"Prisma.skip";<span class="cstat-no" title="statement not covered" ></span>t.throwValidationError({kind:"InvalidArgumentValue",selectionPath:i.getSelectionPath(),argumentPath:i.getArgumentPath(),argument:{name:`${t.getArgumentName()}[${n}]`,typeNames:[]},underlyingError:`Can not use \`${s}\` value within array. Use \`null\` or filter out \`${s}\` values`})}<span class="cstat-no" title="statement not covered" ></span>r</span>.push(ia(o,i))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>function <span class="fstat-no" title="function not covered" >Jp(</span>e){<span class="cstat-no" title="statement not covered" >return typeof e=="object"&amp;&amp;e!==null&amp;&amp;e.__prismaRawParameters__===!0}</span>function <span class="fstat-no" title="function not covered" >Wp(</span>e){<span class="cstat-no" title="statement not covered" >return typeof e=="object"&amp;&amp;e!==null&amp;&amp;typeof e.toJSON=="function"}</span>function <span class="fstat-no" title="function not covered" >Ni(</span>e,t){<span class="cstat-no" title="statement not covered" >e===void 0&amp;&amp;t.isPreviewFeatureOn("strictUndefinedChecks")&amp;&amp;t.throwValidationError({kind:"InvalidSelectionValue",selectionPath:t.getSelectionPath(),underlyingError:na})}</span>var Mi=<span class="cstat-no" title="statement not covered" >class e{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.params=t;<span class="cstat-no" title="statement not covered" >t</span>his.params.modelName&amp;&amp;(this.modelOrType=this.params.runtimeDataModel.models[this.params.modelName]??this.params.runtimeDataModel.types[this.params.modelName])}</span>modelOrType;<span class="fstat-no" title="function not covered" >th</span>rowValidationError(t){<span class="cstat-no" title="statement not covered" >Tn({errors:[t],originalMethod:this.params.originalMethod,args:this.params.rootArgs??{},callsite:this.params.callsite,errorFormat:this.params.errorFormat,clientVersion:this.params.clientVersion,globalOmit:this.params.globalOmit})}<span class="fstat-no" title="function not covered" ></span>ge</span>tSelectionPath(){<span class="cstat-no" title="statement not covered" >return this.params.selectionPath}<span class="fstat-no" title="function not covered" ></span>ge</span>tArgumentPath(){<span class="cstat-no" title="statement not covered" >return this.params.argumentPath}<span class="fstat-no" title="function not covered" ></span>ge</span>tArgumentName(){<span class="cstat-no" title="statement not covered" >return this.params.argumentPath[this.params.argumentPath.length-1]}<span class="fstat-no" title="function not covered" ></span>ge</span>tOutputTypeDescription(){<span class="cstat-no" title="statement not covered" >if(!(!this.params.modelName||!this.modelOrType))<span class="cstat-no" title="statement not covered" >return{name:this.params.modelName,fields:this.modelOrType.fields.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{name:t.name,typeName:"boolean",isRelation:t.kind==="object"})</span>)}}<span class="fstat-no" title="function not covered" ></span></span>is</span>RawAction(){<span class="cstat-no" title="statement not covered" >return["executeRaw","queryRaw","runCommandRaw","findRaw","aggregateRaw"].includes(this.params.action)}<span class="fstat-no" title="function not covered" ></span>is</span>PreviewFeatureOn(t){<span class="cstat-no" title="statement not covered" >return this.params.previewFeatures.includes(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>tComputedFields(){<span class="cstat-no" title="statement not covered" >if(this.params.modelName)<span class="cstat-no" title="statement not covered" >return this.params.extensions.getAllComputedFields(this.params.modelName)}<span class="fstat-no" title="function not covered" ></span></span>fi</span>ndField(t){<span class="cstat-no" title="statement not covered" >return this.modelOrType?.fields.find(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r.name===t)</span>}<span class="fstat-no" title="function not covered" ></span>ne</span>stSelection(t){let r=<span class="cstat-no" title="statement not covered" >this.findField(t),</span>n=<span class="cstat-no" title="statement not covered" >r?.kind==="object"?r.type:void 0;<span class="cstat-no" title="statement not covered" ></span>return new e({...this.params,modelName:n,selectionPath:this.params.selectionPath.concat(t)})}<span class="fstat-no" title="function not covered" ></span>ge</span>tGlobalOmit(){<span class="cstat-no" title="statement not covered" >return this.params.modelName&amp;&amp;this.shouldApplyGlobalOmit()?this.params.globalOmit?.[qe(this.params.modelName)]??{}:{}}<span class="fstat-no" title="function not covered" ></span>sh</span>ouldApplyGlobalOmit(){<span class="cstat-no" title="statement not covered" >switch(this.params.action){case"findFirst":case"findFirstOrThrow":case"findUniqueOrThrow":case"findMany":case"upsert":case"findUnique":case"createManyAndReturn":case"create":case"update":case"updateManyAndReturn":case"delete":<span class="cstat-no" title="statement not covered" >return!0;c</span>ase"executeRaw":case"aggregateRaw":case"runCommandRaw":case"findRaw":case"createMany":case"deleteMany":case"groupBy":case"updateMany":case"count":case"aggregate":case"queryRaw":<span class="cstat-no" title="statement not covered" >return!1;d</span>efault:<span class="cstat-no" title="statement not covered" >Me(this.params.action,"Unknown action")}</span>}<span class="fstat-no" title="function not covered" ></span>ne</span>stArgument(t){<span class="cstat-no" title="statement not covered" >return new e({...this.params,argumentPath:this.params.argumentPath.concat(t)})}</span>};<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >sa(</span>e){<span class="cstat-no" title="statement not covered" >if(!e._hasPreviewFlag("metrics"))<span class="cstat-no" title="statement not covered" >throw new ie("`metrics` preview feature must be enabled in order to access metrics API",{clientVersion:e._clientVersion})}</span></span>var St=<span class="cstat-no" title="statement not covered" >class{_client;<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this._client=t}<span class="fstat-no" title="function not covered" ></span>pr</span>ometheus(t){<span class="cstat-no" title="statement not covered" >return sa(this._client),this._client._engine.metrics({format:"prometheus",...t})}<span class="fstat-no" title="function not covered" ></span>js</span>on(t){<span class="cstat-no" title="statement not covered" >return sa(this._client),this._client._engine.metrics({format:"json",...t})}</span>};<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >aa(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >nr(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Kp(t))</span>;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(e,"dmmf",{get:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >r.get()}</span>)}</span>function <span class="fstat-no" title="function not covered" >Kp(</span>e){<span class="cstat-no" title="statement not covered" >throw new Error("Prisma.dmmf is not available when running in edge runtimes.")}</span>function <span class="fstat-no" title="function not covered" >Li(</span>e){<span class="cstat-no" title="statement not covered" >return Object.entries(e).map(<span class="fstat-no" title="function not covered" >([</span>t,r])=&gt;(<span class="cstat-no" title="statement not covered" >{name:t,...r})</span>)}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Ui=<span class="cstat-no" title="statement not covered" >new WeakMap,</span>Sn=<span class="cstat-no" title="statement not covered" >"$$PrismaTypedSql",</span>gr=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >Ui.set(this,{sql:t,values:r}),Object.defineProperty(this,Sn,{value:Sn})}<span class="fstat-no" title="function not covered" ></span>ge</span>t sql(){<span class="cstat-no" title="statement not covered" >return Ui.get(this).sql}<span class="fstat-no" title="function not covered" ></span>ge</span>t values(){<span class="cstat-no" title="statement not covered" >return Ui.get(this).values}</span>};</span>function <span class="fstat-no" title="function not covered" >la(</span>e){<span class="cstat-no" title="statement not covered" >return<span class="fstat-no" title="function not covered" >(.</span>..t)=&gt;<span class="cstat-no" title="statement not covered" >new gr(e,t)}</span></span>function <span class="fstat-no" title="function not covered" >In(</span>e){<span class="cstat-no" title="statement not covered" >return e!=null&amp;&amp;e[Sn]===Sn}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Xc=<span class="cstat-no" title="statement not covered" >$e(Pi());<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>a();<span class="cstat-no" title="statement not covered" >g</span>s();<span class="cstat-no" title="statement not covered" >x</span>s();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar fe=<span class="cstat-no" title="statement not covered" >class e{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >if(t.length-1!==r.length)<span class="cstat-no" title="statement not covered" >throw t.length===0?new TypeError("Expected at least 1 string"):new TypeError(`Expected ${t.length} strings to have ${t.length-1} values`);l</span></span>et n=<span class="cstat-no" title="statement not covered" >r.reduce(<span class="fstat-no" title="function not covered" >(s</span>,a)=&gt;<span class="cstat-no" title="statement not covered" >s+(a instanceof e?a.values.length:1),</span>0);<span class="cstat-no" title="statement not covered" ></span>this.values=new Array(n),this.strings=new Array(n+1),this.strings[0]=t[0];l</span>et i=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;i&lt;r.length;){let s=<span class="cstat-no" title="statement not covered" >r[i++],</span>a=<span class="cstat-no" title="statement not covered" >t[i];<span class="cstat-no" title="statement not covered" ></span>if(s instanceof e){<span class="cstat-no" title="statement not covered" >this.strings[o]+=s.strings[0];l</span>et f=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;f&lt;s.values.length;)<span class="cstat-no" title="statement not covered" >this.values[o++]=s.values[f++],this.strings[o]=s.strings[f];<span class="cstat-no" title="statement not covered" >t</span></span>his.strings[o]+=a}</span>else <span class="cstat-no" title="statement not covered" >this.values[o++]=s,this.strings[o]=a}</span></span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t sql(){let t=<span class="cstat-no" title="statement not covered" >this.strings.length,</span>r=<span class="cstat-no" title="statement not covered" >1,</span>n=<span class="cstat-no" title="statement not covered" >this.strings[0];<span class="cstat-no" title="statement not covered" ></span>for(;r&lt;t;)<span class="cstat-no" title="statement not covered" >n+=`?${this.strings[r++]}`;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>ge</span>t statement(){let t=<span class="cstat-no" title="statement not covered" >this.strings.length,</span>r=<span class="cstat-no" title="statement not covered" >1,</span>n=<span class="cstat-no" title="statement not covered" >this.strings[0];<span class="cstat-no" title="statement not covered" ></span>for(;r&lt;t;)<span class="cstat-no" title="statement not covered" >n+=`:${r}${this.strings[r++]}`;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>ge</span>t text(){let t=<span class="cstat-no" title="statement not covered" >this.strings.length,</span>r=<span class="cstat-no" title="statement not covered" >1,</span>n=<span class="cstat-no" title="statement not covered" >this.strings[0];<span class="cstat-no" title="statement not covered" ></span>for(;r&lt;t;)<span class="cstat-no" title="statement not covered" >n+=`$${r}${this.strings[r++]}`;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>in</span>spect(){<span class="cstat-no" title="statement not covered" >return{sql:this.sql,statement:this.statement,text:this.text,values:this.values}}</span>};</span>function <span class="fstat-no" title="function not covered" >ua(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >",",</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >"",</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >"")</span>{<span class="cstat-no" title="statement not covered" >if(e.length===0)<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new fe([r,...Array(e.length-1).fill(t),n],e)}</span>function <span class="fstat-no" title="function not covered" >Fi(</span>e){<span class="cstat-no" title="statement not covered" >return new fe([e],[])}</span>var pa=<span class="cstat-no" title="statement not covered" >Fi("");</span>function <span class="fstat-no" title="function not covered" >$i(</span>e,...t){<span class="cstat-no" title="statement not covered" >return new fe(e,t)}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >yr(</span>e){<span class="cstat-no" title="statement not covered" >return{<span class="fstat-no" title="function not covered" >ge</span>tKeys(){<span class="cstat-no" title="statement not covered" >return Object.keys(e)}</span>,<span class="fstat-no" title="function not covered" >ge</span>tPropertyValue(t){<span class="cstat-no" title="statement not covered" >return e[t]}</span>}}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >le(</span>e,t){<span class="cstat-no" title="statement not covered" >return{<span class="fstat-no" title="function not covered" >ge</span>tKeys(){<span class="cstat-no" title="statement not covered" >return[e]}</span>,<span class="fstat-no" title="function not covered" >ge</span>tPropertyValue(){<span class="cstat-no" title="statement not covered" >return t()}</span>}}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >et(</span>e){let t=<span class="cstat-no" title="statement not covered" >new Ce;<span class="cstat-no" title="statement not covered" ></span>return{<span class="fstat-no" title="function not covered" >ge</span>tKeys(){<span class="cstat-no" title="statement not covered" >return e.getKeys()}</span>,<span class="fstat-no" title="function not covered" >ge</span>tPropertyValue(r){<span class="cstat-no" title="statement not covered" >return t.getOrCreate(r,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e.getPropertyValue(r))</span>}</span>,<span class="fstat-no" title="function not covered" >ge</span>tPropertyDescriptor(r){<span class="cstat-no" title="statement not covered" >return e.getPropertyDescriptor?.(r)}</span>}}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar On=<span class="cstat-no" title="statement not covered" >{enumerable:!0,configurable:!0,writable:!0};</span>function <span class="fstat-no" title="function not covered" >Dn(</span>e){let t=<span class="cstat-no" title="statement not covered" >new Set(e);<span class="cstat-no" title="statement not covered" ></span>return{getPrototypeOf:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Object.prototype,</span>getOwnPropertyDescriptor:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >On,</span>has:<span class="fstat-no" title="function not covered" >(r</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >t.has(n),</span>set:<span class="fstat-no" title="function not covered" >(r</span>,n,i)=&gt;<span class="cstat-no" title="statement not covered" >t.add(n)&amp;&amp;Reflect.set(r,n,i),</span>ownKeys:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[...t]}</span>}</span>var ma=<span class="cstat-no" title="statement not covered" >Symbol.for("nodejs.util.inspect.custom");</span>function <span class="fstat-no" title="function not covered" >Pe(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >zp(t),</span>n=<span class="cstat-no" title="statement not covered" >new Set,</span>i=<span class="cstat-no" title="statement not covered" >new Proxy(e,{<span class="fstat-no" title="function not covered" >ge</span>t(o,s){<span class="cstat-no" title="statement not covered" >if(n.has(s))<span class="cstat-no" title="statement not covered" >return o[s];l</span></span>et a=<span class="cstat-no" title="statement not covered" >r.get(s);<span class="cstat-no" title="statement not covered" ></span>return a?a.getPropertyValue(s):o[s]}</span>,<span class="fstat-no" title="function not covered" >ha</span>s(o,s){<span class="cstat-no" title="statement not covered" >if(n.has(s))<span class="cstat-no" title="statement not covered" >return!0;l</span></span>et a=<span class="cstat-no" title="statement not covered" >r.get(s);<span class="cstat-no" title="statement not covered" ></span>return a?a.has?.(s)??!0:Reflect.has(o,s)}</span>,<span class="fstat-no" title="function not covered" >ow</span>nKeys(o){let s=<span class="cstat-no" title="statement not covered" >da(Reflect.ownKeys(o),r),</span>a=<span class="cstat-no" title="statement not covered" >da(Array.from(r.keys()),r);<span class="cstat-no" title="statement not covered" ></span>return[...new Set([...s,...a,...n])]}</span>,<span class="fstat-no" title="function not covered" >se</span>t(o,s,a){<span class="cstat-no" title="statement not covered" >return r.get(s)?.getPropertyDescriptor?.(s)?.writable===!1?!1:(n.add(s),Reflect.set(o,s,a))}</span>,<span class="fstat-no" title="function not covered" >ge</span>tOwnPropertyDescriptor(o,s){let a=<span class="cstat-no" title="statement not covered" >Reflect.getOwnPropertyDescriptor(o,s);<span class="cstat-no" title="statement not covered" ></span>if(a&amp;&amp;!a.configurable)<span class="cstat-no" title="statement not covered" >return a;l</span></span>et f=<span class="cstat-no" title="statement not covered" >r.get(s);<span class="cstat-no" title="statement not covered" ></span>return f?f.getPropertyDescriptor?{...On,...f?.getPropertyDescriptor(s)}:On:a}</span>,<span class="fstat-no" title="function not covered" >de</span>fineProperty(o,s,a){<span class="cstat-no" title="statement not covered" >return n.add(s),Reflect.defineProperty(o,s,a)}</span>,getPrototypeOf:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Object.prototype}</span>);<span class="cstat-no" title="statement not covered" ></span>return i[ma]=<span class="fstat-no" title="function not covered" >fu</span>nction(){let o=<span class="cstat-no" title="statement not covered" >{...this};<span class="cstat-no" title="statement not covered" ></span>return delete o[ma],o}</span>,i}</span>function <span class="fstat-no" title="function not covered" >zp(</span>e){let t=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>for(let r of e){let n=<span class="cstat-no" title="statement not covered" >r.getKeys();<span class="cstat-no" title="statement not covered" ></span>for(let i of n)<span class="cstat-no" title="statement not covered" >t.set(i,r)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >da(</span>e,t){<span class="cstat-no" title="statement not covered" >return e.filter(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >t.get(r)?.has?.(r)??!0)</span>}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >It(</span>e){<span class="cstat-no" title="statement not covered" >return{<span class="fstat-no" title="function not covered" >ge</span>tKeys(){<span class="cstat-no" title="statement not covered" >return e}</span>,<span class="fstat-no" title="function not covered" >ha</span>s(){<span class="cstat-no" title="statement not covered" >return!1}</span>,<span class="fstat-no" title="function not covered" >ge</span>tPropertyValue(){}}}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >kt(</span>e,t){<span class="cstat-no" title="statement not covered" >return{batch:e,transaction:t?.kind==="batch"?{isolationLevel:t.options.isolationLevel}:void 0}}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >fa(</span>e){<span class="cstat-no" title="statement not covered" >if(e===void 0)<span class="cstat-no" title="statement not covered" >return"";l</span></span>et t=<span class="cstat-no" title="statement not covered" >Rt(e);<span class="cstat-no" title="statement not covered" ></span>return new Et(0,{colors:hn}).write(t).toString()}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Yp=<span class="cstat-no" title="statement not covered" >"P2037";</span>function <span class="fstat-no" title="function not covered" >_n(</span>{error:e,user_facing_error:t},r,n){<span class="cstat-no" title="statement not covered" >return t.error_code?new X(Zp(t,n),{code:t.error_code,clientVersion:r,meta:t.meta,batchRequestIdx:t.batch_request_idx}):new ne(e,{clientVersion:r,batchRequestIdx:t.batch_request_idx})}</span>function <span class="fstat-no" title="function not covered" >Zp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >e.message;<span class="cstat-no" title="statement not covered" ></span>return(t==="postgresql"||t==="postgres"||t==="mysql")&amp;&amp;e.error_code===Yp&amp;&amp;(r+=`</span>
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`),r}<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Vi=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >ge</span>tLocation(){<span class="cstat-no" title="statement not covered" >return null}</span>};</span>function <span class="fstat-no" title="function not covered" >je(</span>e){<span class="cstat-no" title="statement not covered" >return typeof $EnabledCallSite=="function"&amp;&amp;e!=="minimal"?new $EnabledCallSite:new Vi}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar ga=<span class="cstat-no" title="statement not covered" >{_avg:!0,_count:!0,_sum:!0,_min:!0,_max:!0};</span>function <span class="fstat-no" title="function not covered" >Ot(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let t=<span class="cstat-no" title="statement not covered" >em(e);<span class="cstat-no" title="statement not covered" ></span>return Object.entries(t).reduce(<span class="fstat-no" title="function not covered" >(n</span>,[i,o])=&gt;(<span class="cstat-no" title="statement not covered" >ga[i]!==void 0?n.select[i]={select:o}:n[i]=o,n)</span>,{select:{}})}</span>function <span class="fstat-no" title="function not covered" >em(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return typeof e._count=="boolean"?{...e,_count:{_all:e._count}}:e}</span>function <span class="fstat-no" title="function not covered" >Mn(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >typeof e._count=="boolean"&amp;&amp;(t._count=t._count._all),t)</span>}</span>function <span class="fstat-no" title="function not covered" >ya(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >Mn(e);<span class="cstat-no" title="statement not covered" ></span>return t({action:"aggregate",unpacker:r,argsMapper:Ot})(e)}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >tm(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let{select:t,...r}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return typeof t=="object"?Ot({...r,_count:t}):Ot({...r,_count:{_all:!0}})}</span>function <span class="fstat-no" title="function not covered" >rm(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return typeof e.select=="object"?<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Mn(e)(t)._count:<span class="fstat-no" title="function not covered" ></span>t=</span>&gt;<span class="cstat-no" title="statement not covered" >Mn(e)(t)._count._all}</span></span>function <span class="fstat-no" title="function not covered" >ha(</span>e,t){<span class="cstat-no" title="statement not covered" >return t({action:"count",unpacker:rm(e),argsMapper:tm})(e)}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >nm(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let t=<span class="cstat-no" title="statement not covered" >Ot(e);<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(t.by))<span class="cstat-no" title="statement not covered" >for(let r of t.by)<span class="cstat-no" title="statement not covered" >typeof r=="string"&amp;&amp;(t.select[r]=!0);e</span></span>lse <span class="cstat-no" title="statement not covered" >typeof t.by=="string"&amp;&amp;(t.select[t.by]=!0);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >im(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >typeof e?._count=="boolean"&amp;&amp;t.forEach(<span class="fstat-no" title="function not covered" >r=</span>&gt;{<span class="cstat-no" title="statement not covered" >r._count=r._count._all}</span>),t)</span>}</span>function <span class="fstat-no" title="function not covered" >wa(</span>e,t){<span class="cstat-no" title="statement not covered" >return t({action:"groupBy",unpacker:im(e),argsMapper:nm})(e)}</span>function <span class="fstat-no" title="function not covered" >ba(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if(t==="aggregate")<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >ya(n,r);<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(t==="count")<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >ha(n,r);<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(t==="groupBy")<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >wa(n,r)}<span class="cstat-no" title="statement not covered" ></span></span></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ea(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >t.fields.filter(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >!i.relationName)</span>,</span>n=<span class="cstat-no" title="statement not covered" >Os(r,"name");<span class="cstat-no" title="statement not covered" ></span>return new Proxy({},{<span class="fstat-no" title="function not covered" >ge</span>t(i,o){<span class="cstat-no" title="statement not covered" >if(o in i||typeof o=="symbol")<span class="cstat-no" title="statement not covered" >return i[o];l</span></span>et s=<span class="cstat-no" title="statement not covered" >n[o];<span class="cstat-no" title="statement not covered" ></span>if(s)<span class="cstat-no" title="statement not covered" >return new lr(e,o,s.type,s.isList,s.kind==="enum")}</span></span>,...Dn(Object.keys(n))})}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar xa=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >Array.isArray(e)?e:e.split("."),</span></span>qi=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >xa(t).reduce(<span class="fstat-no" title="function not covered" >(r</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >r&amp;&amp;r[n],</span>e),</span></span>Pa=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >xa(t).reduceRight(<span class="fstat-no" title="function not covered" >(n</span>,i,o,s)=&gt;<span class="cstat-no" title="statement not covered" >Object.assign({},qi(e,s.slice(0,o)),{[i]:n}),</span>r);</span></span>function <span class="fstat-no" title="function not covered" >om(</span>e,t){<span class="cstat-no" title="statement not covered" >return e===void 0||t===void 0?[]:[...t,"select",e]}</span>function <span class="fstat-no" title="function not covered" >sm(</span>e,t,r){<span class="cstat-no" title="statement not covered" >return t===void 0?e??{}:Pa(t,r,e||!0)}</span>function <span class="fstat-no" title="function not covered" >Bi(</span>e,t,r,n,i,o){let a=<span class="cstat-no" title="statement not covered" >e._runtimeDataModel.models[t].fields.reduce(<span class="fstat-no" title="function not covered" >(f</span>,w)=&gt;(<span class="cstat-no" title="statement not covered" >{...f,[w.name]:w})</span>,{});<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >f=</span>&gt;{let w=<span class="cstat-no" title="statement not covered" >je(e._errorFormat),</span>A=<span class="cstat-no" title="statement not covered" >om(n,i),</span>R=<span class="cstat-no" title="statement not covered" >sm(f,o,A),</span>S=<span class="cstat-no" title="statement not covered" >r({dataPath:A,callsite:w})(R),</span>C=<span class="cstat-no" title="statement not covered" >am(e,t);<span class="cstat-no" title="statement not covered" ></span>return new Proxy(S,{<span class="fstat-no" title="function not covered" >ge</span>t(L,k){<span class="cstat-no" title="statement not covered" >if(!C.includes(k))<span class="cstat-no" title="statement not covered" >return L[k];l</span></span>et De=<span class="cstat-no" title="statement not covered" >[a[k].type,r,k],</span>ue=<span class="cstat-no" title="statement not covered" >[A,R];<span class="cstat-no" title="statement not covered" ></span>return Bi(e,...De,...ue)}</span>,...Dn([...C,...Object.getOwnPropertyNames(S)])})}</span>}</span>function <span class="fstat-no" title="function not covered" >am(</span>e,t){<span class="cstat-no" title="statement not covered" >return e._runtimeDataModel.models[t].fields.filter(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r.kind==="object")</span>.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r.name)</span>}</span>var lm=<span class="cstat-no" title="statement not covered" >["findUnique","findUniqueOrThrow","findFirst","findFirstOrThrow","create","update","upsert","delete"],</span>cm=<span class="cstat-no" title="statement not covered" >["aggregate","count","groupBy"];</span>function <span class="fstat-no" title="function not covered" >ji(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >e._extensions.getAllModelExtensions(t)??{},</span>n=<span class="cstat-no" title="statement not covered" >[um(e,t),mm(e,t),yr(r),le("name",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t)</span>,le("$name",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t)</span>,le("$parent",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e._appliedParent)</span>];<span class="cstat-no" title="statement not covered" ></span>return Pe({},n)}</span>function <span class="fstat-no" title="function not covered" >um(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >Ie(t),</span>n=<span class="cstat-no" title="statement not covered" >Object.keys(ir).concat("count");<span class="cstat-no" title="statement not covered" ></span>return{<span class="fstat-no" title="function not covered" >ge</span>tKeys(){<span class="cstat-no" title="statement not covered" >return n}</span>,<span class="fstat-no" title="function not covered" >ge</span>tPropertyValue(i){let o=<span class="cstat-no" title="statement not covered" >i,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >f=</span>&gt;{let w=<span class="cstat-no" title="statement not covered" >je(e._errorFormat);<span class="cstat-no" title="statement not covered" ></span>return e._createPrismaPromise(<span class="fstat-no" title="function not covered" >A=</span>&gt;{let R=<span class="cstat-no" title="statement not covered" >{args:f,dataPath:[],action:o,model:t,clientMethod:`${r}.${i}`,jsModelName:r,transaction:A,callsite:w};<span class="cstat-no" title="statement not covered" ></span>return e._request({...R,...a})}</span>,{action:o,args:f,model:t})}</span>;<span class="cstat-no" title="statement not covered" ></span></span>return lm.includes(o)?Bi(e,t,s):pm(i)?ba(e,i,s):s({})}</span>}}</span>function <span class="fstat-no" title="function not covered" >pm(</span>e){<span class="cstat-no" title="statement not covered" >return cm.includes(e)}</span>function <span class="fstat-no" title="function not covered" >mm(</span>e,t){<span class="cstat-no" title="statement not covered" >return et(le("fields",<span class="fstat-no" title="function not covered" >()</span>=&gt;{let r=<span class="cstat-no" title="statement not covered" >e._runtimeDataModel.models[t];<span class="cstat-no" title="statement not covered" ></span>return Ea(t,r)}</span>))}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ta(</span>e){<span class="cstat-no" title="statement not covered" >return e.replace(/^./,<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.toUpperCase())</span>}</span>var Qi=<span class="cstat-no" title="statement not covered" >Symbol();</span>function <span class="fstat-no" title="function not covered" >hr(</span>e){let t=<span class="cstat-no" title="statement not covered" >[dm(e),fm(e),le(Qi,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e)</span>,le("$parent",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e._appliedParent)</span>],</span>r=<span class="cstat-no" title="statement not covered" >e._extensions.getAllClientExtensions();<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;t.push(yr(r)),Pe(e,t)}</span>function <span class="fstat-no" title="function not covered" >dm(</span>e){let t=<span class="cstat-no" title="statement not covered" >Object.getPrototypeOf(e._originalClient),</span>r=<span class="cstat-no" title="statement not covered" >[...new Set(Object.getOwnPropertyNames(t))];<span class="cstat-no" title="statement not covered" ></span>return{<span class="fstat-no" title="function not covered" >ge</span>tKeys(){<span class="cstat-no" title="statement not covered" >return r}</span>,<span class="fstat-no" title="function not covered" >ge</span>tPropertyValue(n){<span class="cstat-no" title="statement not covered" >return e[n]}</span>}}</span>function <span class="fstat-no" title="function not covered" >fm(</span>e){let t=<span class="cstat-no" title="statement not covered" >Object.keys(e._runtimeDataModel.models),</span>r=<span class="cstat-no" title="statement not covered" >t.map(Ie),</span>n=<span class="cstat-no" title="statement not covered" >[...new Set(t.concat(r))];<span class="cstat-no" title="statement not covered" ></span>return et({<span class="fstat-no" title="function not covered" >ge</span>tKeys(){<span class="cstat-no" title="statement not covered" >return n}</span>,<span class="fstat-no" title="function not covered" >ge</span>tPropertyValue(i){let o=<span class="cstat-no" title="statement not covered" >Ta(i);<span class="cstat-no" title="statement not covered" ></span>if(e._runtimeDataModel.models[o]!==void 0)<span class="cstat-no" title="statement not covered" >return ji(e,o);<span class="cstat-no" title="statement not covered" >i</span></span>f(e._runtimeDataModel.models[i]!==void 0)<span class="cstat-no" title="statement not covered" >return ji(e,i)}</span></span>,<span class="fstat-no" title="function not covered" >ge</span>tPropertyDescriptor(i){<span class="cstat-no" title="statement not covered" >if(!r.includes(i))<span class="cstat-no" title="statement not covered" >return{enumerable:!1}}</span></span>})}</span>function <span class="fstat-no" title="function not covered" >va(</span>e){<span class="cstat-no" title="statement not covered" >return e[Qi]?e[Qi]:e}</span>function <span class="fstat-no" title="function not covered" >Aa(</span>e){<span class="cstat-no" title="statement not covered" >if(typeof e=="function")<span class="cstat-no" title="statement not covered" >return e(this);<span class="cstat-no" title="statement not covered" >i</span></span>f(e.client?.__AccelerateEngine){let r=<span class="cstat-no" title="statement not covered" >e.client.__AccelerateEngine;<span class="cstat-no" title="statement not covered" ></span>this._originalClient._engine=new r(this._originalClient._accelerateEngineConfig)}</span>l</span>et t=<span class="cstat-no" title="statement not covered" >Object.create(this._originalClient,{_extensions:{value:this._extensions.append(e)},_appliedParent:{value:this,configurable:!0},$on:{value:void 0}});<span class="cstat-no" title="statement not covered" ></span>return hr(t)}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ra(</span>{result:e,modelName:t,select:r,omit:n,extensions:i}){let o=<span class="cstat-no" title="statement not covered" >i.getAllComputedFields(t);<span class="cstat-no" title="statement not covered" ></span>if(!o)<span class="cstat-no" title="statement not covered" >return e;l</span></span>et s=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let f of Object.values(o)){<span class="cstat-no" title="statement not covered" >if(n){<span class="cstat-no" title="statement not covered" >if(n[f.name])<span class="cstat-no" title="statement not covered" >continue;l</span></span>et w=<span class="cstat-no" title="statement not covered" >f.needs.filter(<span class="fstat-no" title="function not covered" >A=</span>&gt;<span class="cstat-no" title="statement not covered" >n[A])</span>;<span class="cstat-no" title="statement not covered" ></span>w.length&gt;0&amp;&amp;a.push(It(w))}</span>else <span class="cstat-no" title="statement not covered" >if(r){<span class="cstat-no" title="statement not covered" >if(!r[f.name])<span class="cstat-no" title="statement not covered" >continue;l</span></span>et w=<span class="cstat-no" title="statement not covered" >f.needs.filter(<span class="fstat-no" title="function not covered" >A=</span>&gt;<span class="cstat-no" title="statement not covered" >!r[A])</span>;<span class="cstat-no" title="statement not covered" ></span>w.length&gt;0&amp;&amp;a.push(It(w))}<span class="cstat-no" title="statement not covered" ></span>g</span></span>m(e,f.needs)&amp;&amp;s.push(ym(f,Pe(e,s)))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s.length&gt;0||a.length&gt;0?Pe(e,[...s,...a]):e}</span>function <span class="fstat-no" title="function not covered" >gm(</span>e,t){<span class="cstat-no" title="statement not covered" >return t.every(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >Ri(e,r))</span>}</span>function <span class="fstat-no" title="function not covered" >ym(</span>e,t){<span class="cstat-no" title="statement not covered" >return et(le(e.name,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e.compute(t))</span>)}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Nn(</span>{visitor:e,result:t,args:r,runtimeDataModel:n,modelName:i}){<span class="cstat-no" title="statement not covered" >if(Array.isArray(t)){<span class="cstat-no" title="statement not covered" >for(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;t.length;s++)<span class="cstat-no" title="statement not covered" >t[s]=Nn({result:t[s],args:r,modelName:i,runtimeDataModel:n,visitor:e});<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>l</span>et o=<span class="cstat-no" title="statement not covered" >e(t,i,r)??t;<span class="cstat-no" title="statement not covered" ></span>return r.include&amp;&amp;Ca({includeOrSelect:r.include,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),r.select&amp;&amp;Ca({includeOrSelect:r.select,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),o}</span>function <span class="fstat-no" title="function not covered" >Ca(</span>{includeOrSelect:e,result:t,parentModelName:r,runtimeDataModel:n,visitor:i}){<span class="cstat-no" title="statement not covered" >for(let[o,s]of Object.entries(e)){<span class="cstat-no" title="statement not covered" >if(!s||t[o]==null||ke(s))<span class="cstat-no" title="statement not covered" >continue;l</span></span>et f=<span class="cstat-no" title="statement not covered" >n.models[r].fields.find(<span class="fstat-no" title="function not covered" >A=</span>&gt;<span class="cstat-no" title="statement not covered" >A.name===o)</span>;<span class="cstat-no" title="statement not covered" ></span>if(!f||f.kind!=="object"||!f.relationName)<span class="cstat-no" title="statement not covered" >continue;l</span></span>et w=<span class="cstat-no" title="statement not covered" >typeof s=="object"?s:{};<span class="cstat-no" title="statement not covered" ></span>t[o]=Nn({visitor:i,result:t[o],args:w,modelName:f.type,runtimeDataModel:n})}</span>}</span>function <span class="fstat-no" title="function not covered" >Sa(</span>{result:e,modelName:t,args:r,extensions:n,runtimeDataModel:i,globalOmit:o}){<span class="cstat-no" title="statement not covered" >return n.isEmpty()||e==null||typeof e!="object"||!i.models[t]?e:Nn({result:e,args:r??{},modelName:t,runtimeDataModel:i,visitor:<span class="fstat-no" title="function not covered" >(a</span>,f,w)=&gt;{let A=<span class="cstat-no" title="statement not covered" >Ie(f);<span class="cstat-no" title="statement not covered" ></span>return Ra({result:a,modelName:A,select:w.select,omit:w.select?void 0:{...o?.[A],...w.omit},extensions:n})}</span>})}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar hm=<span class="cstat-no" title="statement not covered" >["$connect","$disconnect","$on","$transaction","$extends"],</span>Ia=<span class="cstat-no" title="statement not covered" >hm;</span>function <span class="fstat-no" title="function not covered" >ka(</span>e){<span class="cstat-no" title="statement not covered" >if(e instanceof fe)<span class="cstat-no" title="statement not covered" >return wm(e);<span class="cstat-no" title="statement not covered" >i</span></span>f(In(e))<span class="cstat-no" title="statement not covered" >return bm(e);<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(e)){let r=<span class="cstat-no" title="statement not covered" >[e[0]];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >1;</span>n&lt;e.length;n++)<span class="cstat-no" title="statement not covered" >r[n]=wr(e[n]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>l</span>et t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let r in e)<span class="cstat-no" title="statement not covered" >t[r]=wr(e[r]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >wm(</span>e){<span class="cstat-no" title="statement not covered" >return new fe(e.strings,e.values)}</span>function <span class="fstat-no" title="function not covered" >bm(</span>e){<span class="cstat-no" title="statement not covered" >return new gr(e.sql,e.values)}</span>function <span class="fstat-no" title="function not covered" >wr(</span>e){<span class="cstat-no" title="statement not covered" >if(typeof e!="object"||e==null||e instanceof Ne||At(e))<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f(bt(e))<span class="cstat-no" title="statement not covered" >return new se(e.toFixed());<span class="cstat-no" title="statement not covered" >i</span></span>f(wt(e))<span class="cstat-no" title="statement not covered" >return new Date(+e);<span class="cstat-no" title="statement not covered" >i</span></span>f(ArrayBuffer.isView(e))<span class="cstat-no" title="statement not covered" >return e.slice(0);<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(e)){let t=<span class="cstat-no" title="statement not covered" >e.length,</span>r;<span class="cstat-no" title="statement not covered" >for(r=Array(t);t--;)<span class="cstat-no" title="statement not covered" >r[t]=wr(e[t]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof e=="object"){let t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let r in e)<span class="cstat-no" title="statement not covered" >r==="__proto__"?Object.defineProperty(t,r,{value:wr(e[r]),configurable:!0,enumerable:!0,writable:!0}):t[r]=wr(e[r]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}<span class="cstat-no" title="statement not covered" ></span>M</span>e(e,"Unknown value")}</span>function <span class="fstat-no" title="function not covered" >Da(</span>e,t,r,n=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return e._createPrismaPromise(<span class="fstat-no" title="function not covered" >i=</span>&gt;{let o=<span class="cstat-no" title="statement not covered" >t.customDataProxyFetch;<span class="cstat-no" title="statement not covered" ></span>return"transaction"in t&amp;&amp;i!==void 0&amp;&amp;(t.transaction?.kind==="batch"&amp;&amp;t.transaction.lock.then(),t.transaction=i),n===r.length?e._executeRequest(t):r[n]({model:t.model,operation:t.model?t.action:t.clientMethod,args:ka(t.args??{}),__internalParams:t,query:<span class="fstat-no" title="function not covered" >(s</span>,a=<span class="branch-0 cbranch-no" title="branch not covered" >t)</span>=&gt;{let f=<span class="cstat-no" title="statement not covered" >a.customDataProxyFetch;<span class="cstat-no" title="statement not covered" ></span>return a.customDataProxyFetch=La(o,f),a.args=s,Da(e,a,r,n+1)}</span>})}</span>)}</span>function <span class="fstat-no" title="function not covered" >_a(</span>e,t){let{jsModelName:r,action:n,clientMethod:i}=<span class="cstat-no" title="statement not covered" >t,</span>o=<span class="cstat-no" title="statement not covered" >r?n:i;<span class="cstat-no" title="statement not covered" ></span>if(e._extensions.isEmpty())<span class="cstat-no" title="statement not covered" >return e._executeRequest(t);l</span></span>et s=<span class="cstat-no" title="statement not covered" >e._extensions.getAllQueryCallbacks(r??"$none",o);<span class="cstat-no" title="statement not covered" ></span>return Da(e,t,s)}</span>function <span class="fstat-no" title="function not covered" >Ma(</span>e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >t=</span>&gt;{let r=<span class="cstat-no" title="statement not covered" >{requests:t},</span>n=<span class="cstat-no" title="statement not covered" >t[0].extensions.getAllBatchQueryCallbacks();<span class="cstat-no" title="statement not covered" ></span>return n.length?Na(r,n,0,e):e(r)}</span>}</span>function <span class="fstat-no" title="function not covered" >Na(</span>e,t,r,n){<span class="cstat-no" title="statement not covered" >if(r===t.length)<span class="cstat-no" title="statement not covered" >return n(e);l</span></span>et i=<span class="cstat-no" title="statement not covered" >e.customDataProxyFetch,</span>o=<span class="cstat-no" title="statement not covered" >e.requests[0].transaction;<span class="cstat-no" title="statement not covered" ></span>return t[r]({args:{queries:e.requests.map(<span class="fstat-no" title="function not covered" >s=</span>&gt;(<span class="cstat-no" title="statement not covered" >{model:s.modelName,operation:s.action,args:s.args})</span>),transaction:o?{isolationLevel:o.kind==="batch"?o.isolationLevel:void 0}:void 0},__internalParams:e,<span class="fstat-no" title="function not covered" >qu</span>ery(s,a=<span class="branch-0 cbranch-no" title="branch not covered" >e)</span>{let f=<span class="cstat-no" title="statement not covered" >a.customDataProxyFetch;<span class="cstat-no" title="statement not covered" ></span>return a.customDataProxyFetch=La(i,f),Na(a,t,r+1,n)}</span>})}</span>var Oa=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e;</span></span>function <span class="fstat-no" title="function not covered" >La(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >Oa,</span>t=<span class="branch-0 cbranch-no" title="branch not covered" >Oa)</span>{<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >e(t(r))}<span class="cstat-no" title="statement not covered" ></span></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Ua=<span class="cstat-no" title="statement not covered" >K("prisma:client"),</span>Fa=<span class="cstat-no" title="statement not covered" >{Vercel:"vercel","Netlify CI":"netlify"};</span>function <span class="fstat-no" title="function not covered" >$a(</span>{postinstall:e,ciName:t,clientVersion:r,generator:n}){<span class="cstat-no" title="statement not covered" >if(Ua("checkPlatformCaching:postinstall",e),Ua("checkPlatformCaching:ciName",t),e===!0&amp;&amp;!(n?.output&amp;&amp;typeof(n.output.fromEnvVar??n.output.value)=="string")&amp;&amp;t&amp;&amp;t in Fa){let i=<span class="cstat-no" title="statement not covered" >`Prisma has detected that this project was built on ${t}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.</span></span>
&nbsp;
Learn how: https://pris.ly/d/${Fa[t]}-build`;<span class="cstat-no" title="statement not covered" >throw console.error(i),new F(i,r)}</span>}<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Va(</span>e,t){<span class="cstat-no" title="statement not covered" >return e?e.datasources?e.datasources:e.datasourceUrl?{[t[0]]:{url:e.datasourceUrl}}:{}:{}}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >qa(</span>e){<span class="cstat-no" title="statement not covered" >return e?e.replace(/".*"/g,'"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g,<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >`${t[0]}5`)</span>:""}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ba(</span>e){<span class="cstat-no" title="statement not covered" >return e.split(`</span>
`).map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/,"").replace(/\+\d+\s*ms$/,""))</span>.join(`
`)}<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar ja=<span class="cstat-no" title="statement not covered" >$e(Ss());</span>function <span class="fstat-no" title="function not covered" >Qa(</span>{title:e,user:t=<span class="branch-0 cbranch-no" title="branch not covered" >"prisma",</span>repo:r=<span class="branch-0 cbranch-no" title="branch not covered" >"prisma",</span>template:n=<span class="branch-0 cbranch-no" title="branch not covered" >"bug_report.yml",</span>body:i}){<span class="cstat-no" title="statement not covered" >return(0,ja.default)({user:t,repo:r,template:n,title:e,body:i})}</span>function <span class="fstat-no" title="function not covered" >Ha(</span>{version:e,binaryTarget:t,title:r,description:n,engineVersion:i,database:o,query:s}){let a=<span class="cstat-no" title="statement not covered" >ms(6e3-(s?.length??0)),</span>f=<span class="cstat-no" title="statement not covered" >Ba(ht(a)),</span>w=<span class="cstat-no" title="statement not covered" >n?`# Description</span>
\`\`\`
${n}
\`\`\``:"",A=<span class="cstat-no" title="statement not covered" >ht(`Hi Prisma Team! My Prisma Client just crashed. This is the report:</span>
## Versions
&nbsp;
| Name            | Version            |
|-----------------|--------------------|
| Node            | ${g.version?.padEnd(19)}| 
| OS              | ${t?.padEnd(19)}|
| Prisma Client   | ${e?.padEnd(19)}|
| Query Engine    | ${i?.padEnd(19)}|
| Database        | ${o?.padEnd(19)}|
&nbsp;
${w}
&nbsp;
## Logs
\`\`\`
${f}
\`\`\`
&nbsp;
## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`
&nbsp;
## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`
&nbsp;
## Prisma Engine Query
\`\`\`
${s?qa(s):""}
\`\`\`
`),R=<span class="cstat-no" title="statement not covered" >Qa({title:r,body:A});<span class="cstat-no" title="statement not covered" ></span>return`${r}</span>
&nbsp;
This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.
&nbsp;
${tn(R)}
&nbsp;
If you want the Prisma team to look into it, please open the link above \u{1F64F}
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`}<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >$(</span>e,t){<span class="cstat-no" title="statement not covered" >throw new Error(t)}</span>function <span class="fstat-no" title="function not covered" >Hi(</span>e,t){<span class="cstat-no" title="statement not covered" >return e===t||e!==null&amp;&amp;t!==null&amp;&amp;typeof e=="object"&amp;&amp;typeof t=="object"&amp;&amp;Object.keys(e).length===Object.keys(t).length&amp;&amp;Object.keys(e).every(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >Hi(e[r],t[r]))</span>}</span>function <span class="fstat-no" title="function not covered" >Dt(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >Object.keys(e),</span>n=<span class="cstat-no" title="statement not covered" >Object.keys(t);<span class="cstat-no" title="statement not covered" ></span>return(r.length&lt;n.length?r:n).every(<span class="fstat-no" title="function not covered" >o=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(typeof e[o]==typeof t[o]&amp;&amp;typeof e[o]!="object")<span class="cstat-no" title="statement not covered" >return e[o]===t[o];<span class="cstat-no" title="statement not covered" >i</span></span>f(se.isDecimal(e[o])||se.isDecimal(t[o])){let s=<span class="cstat-no" title="statement not covered" >Ga(e[o]),</span>a=<span class="cstat-no" title="statement not covered" >Ga(t[o]);<span class="cstat-no" title="statement not covered" ></span>return s&amp;&amp;a&amp;&amp;s.equals(a)}</span>else <span class="cstat-no" title="statement not covered" >if(e[o]instanceof Uint8Array||t[o]instanceof Uint8Array){let s=<span class="cstat-no" title="statement not covered" >Ja(e[o]),</span>a=<span class="cstat-no" title="statement not covered" >Ja(t[o]);<span class="cstat-no" title="statement not covered" ></span>return s&amp;&amp;a&amp;&amp;s.equals(a)}</span>else{<span class="cstat-no" title="statement not covered" >if(e[o]instanceof Date||t[o]instanceof Date)<span class="cstat-no" title="statement not covered" >return Wa(e[o])?.getTime()===Wa(t[o])?.getTime();<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof e[o]=="bigint"||typeof t[o]=="bigint")<span class="cstat-no" title="statement not covered" >return Ka(e[o])===Ka(t[o]);<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof e[o]=="number"||typeof t[o]=="number")<span class="cstat-no" title="statement not covered" >return za(e[o])===za(t[o])}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn Hi(e[o],t[o])}</span>)}</span>function <span class="fstat-no" title="function not covered" >Ga(</span>e){<span class="cstat-no" title="statement not covered" >return se.isDecimal(e)?e:typeof e=="number"||typeof e=="string"?new se(e):void 0}</span>function <span class="fstat-no" title="function not covered" >Ja(</span>e){<span class="cstat-no" title="statement not covered" >return y.isBuffer(e)?e:e instanceof Uint8Array?y.from(e.buffer,e.byteOffset,e.byteLength):typeof e=="string"?y.from(e,"base64"):void 0}</span>function <span class="fstat-no" title="function not covered" >Wa(</span>e){<span class="cstat-no" title="statement not covered" >return e instanceof Date?e:typeof e=="string"||typeof e=="number"?new Date(e):void 0}</span>function <span class="fstat-no" title="function not covered" >Ka(</span>e){<span class="cstat-no" title="statement not covered" >return typeof e=="bigint"?e:typeof e=="number"||typeof e=="string"?BigInt(e):void 0}</span>function <span class="fstat-no" title="function not covered" >za(</span>e){<span class="cstat-no" title="statement not covered" >return typeof e=="number"?e:typeof e=="string"?Number(e):void 0}</span>function <span class="fstat-no" title="function not covered" >br(</span>e){<span class="cstat-no" title="statement not covered" >return JSON.stringify(e,<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >typeof r=="bigint"?r.toString():ArrayBuffer.isView(r)?y.from(r.buffer,r.byteOffset,r.byteLength).toString("base64"):r)</span>}</span>function <span class="fstat-no" title="function not covered" >Em(</span>e){<span class="cstat-no" title="statement not covered" >return e!==null&amp;&amp;typeof e=="object"&amp;&amp;typeof e.$type=="string"}</span>function <span class="fstat-no" title="function not covered" >xm(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let n of Object.keys(e))<span class="cstat-no" title="statement not covered" >r[n]=t(e[n],n);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >Qe(</span>e){<span class="cstat-no" title="statement not covered" >return e===null?e:Array.isArray(e)?e.map(Qe):typeof e=="object"?Em(e)?Pm(e):e.constructor!==null&amp;&amp;e.constructor.name!=="Object"?e:xm(e,Qe):e}</span>function <span class="fstat-no" title="function not covered" >Pm(</span>{$type:e,value:t}){<span class="cstat-no" title="statement not covered" >switch(e){case"BigInt":<span class="cstat-no" title="statement not covered" >return BigInt(t);c</span>ase"Bytes":{let{buffer:r,byteOffset:n,byteLength:i}=<span class="cstat-no" title="statement not covered" >y.from(t,"base64");<span class="cstat-no" title="statement not covered" ></span>return new Uint8Array(r,n,i)}</span>case"DateTime":<span class="cstat-no" title="statement not covered" >return new Date(t);c</span>ase"Decimal":<span class="cstat-no" title="statement not covered" >return new v(t);c</span>ase"Json":<span class="cstat-no" title="statement not covered" >return JSON.parse(t);d</span>efault:<span class="cstat-no" title="statement not covered" >$(t,"Unknown tagged value")}</span>}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar ce=<span class="cstat-no" title="statement not covered" >class extends Error{name=<span class="cstat-no" title="statement not covered" >"UserFacingError";</span>code;meta;<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r,n){<span class="cstat-no" title="statement not covered" >super(t),this.code=r,this.meta=n??{}}<span class="fstat-no" title="function not covered" ></span>to</span>QueryResponseErrorObject(){<span class="cstat-no" title="statement not covered" >return{error:this.message,user_facing_error:{is_panic:!1,message:this.message,meta:this.meta,error_code:this.code}}}</span>};</span>function <span class="fstat-no" title="function not covered" >_t(</span>e){<span class="cstat-no" title="statement not covered" >if(!nn(e))<span class="cstat-no" title="statement not covered" >throw e;l</span></span>et t=<span class="cstat-no" title="statement not covered" >Tm(e),</span>r=<span class="cstat-no" title="statement not covered" >Ya(e);<span class="cstat-no" title="statement not covered" ></span>throw!t||!r?e:new ce(r,t,{driverAdapterError:e})}</span>function <span class="fstat-no" title="function not covered" >Ji(</span>e){<span class="cstat-no" title="statement not covered" >throw nn(e)?new ce(`Raw query failed. Code: \`${e.cause.originalCode??"N/A"}\`. Message: \`${e.cause.originalMessage??Ya(e)}\``,"P2010",{driverAdapterError:e}):e}</span>function <span class="fstat-no" title="function not covered" >Tm(</span>e){<span class="cstat-no" title="statement not covered" >switch(e.cause.kind){case"AuthenticationFailed":<span class="cstat-no" title="statement not covered" >return"P1000";c</span>ase"DatabaseNotReachable":<span class="cstat-no" title="statement not covered" >return"P1001";c</span>ase"DatabaseDoesNotExist":<span class="cstat-no" title="statement not covered" >return"P1003";c</span>ase"SocketTimeout":<span class="cstat-no" title="statement not covered" >return"P1008";c</span>ase"DatabaseAlreadyExists":<span class="cstat-no" title="statement not covered" >return"P1009";c</span>ase"DatabaseAccessDenied":<span class="cstat-no" title="statement not covered" >return"P1010";c</span>ase"TlsConnectionError":<span class="cstat-no" title="statement not covered" >return"P1011";c</span>ase"ConnectionClosed":<span class="cstat-no" title="statement not covered" >return"P1017";c</span>ase"TransactionAlreadyClosed":<span class="cstat-no" title="statement not covered" >return"P1018";c</span>ase"LengthMismatch":<span class="cstat-no" title="statement not covered" >return"P2000";c</span>ase"UniqueConstraintViolation":<span class="cstat-no" title="statement not covered" >return"P2002";c</span>ase"ForeignKeyConstraintViolation":<span class="cstat-no" title="statement not covered" >return"P2003";c</span>ase"UnsupportedNativeDataType":<span class="cstat-no" title="statement not covered" >return"P2010";c</span>ase"NullConstraintViolation":<span class="cstat-no" title="statement not covered" >return"P2011";c</span>ase"ValueOutOfRange":<span class="cstat-no" title="statement not covered" >return"P2020";c</span>ase"TableDoesNotExist":<span class="cstat-no" title="statement not covered" >return"P2021";c</span>ase"ColumnNotFound":<span class="cstat-no" title="statement not covered" >return"P2022";c</span>ase"InvalidIsolationLevel":case"InconsistentColumnData":<span class="cstat-no" title="statement not covered" >return"P2023";c</span>ase"MissingFullTextSearchIndex":<span class="cstat-no" title="statement not covered" >return"P2030";c</span>ase"TransactionWriteConflict":<span class="cstat-no" title="statement not covered" >return"P2034";c</span>ase"GenericJs":<span class="cstat-no" title="statement not covered" >return"P2036";c</span>ase"TooManyConnections":<span class="cstat-no" title="statement not covered" >return"P2037";c</span>ase"postgres":case"sqlite":case"mysql":case"mssql":<span class="cstat-no" title="statement not covered" >return;d</span>efault:<span class="cstat-no" title="statement not covered" >$(e.cause,`Unknown error: ${e.cause}`)}</span>}</span>function <span class="fstat-no" title="function not covered" >Ya(</span>e){<span class="cstat-no" title="statement not covered" >switch(e.cause.kind){case"AuthenticationFailed":<span class="cstat-no" title="statement not covered" >return`Authentication failed against the database server, the provided database credentials for \`${e.cause.user??"(not available)"}\` are not valid`;c</span>ase"DatabaseNotReachable":{let t=<span class="cstat-no" title="statement not covered" >e.cause.host&amp;&amp;e.cause.port?`${e.cause.host}:${e.cause.port}`:e.cause.host;<span class="cstat-no" title="statement not covered" ></span>return`Can't reach database server${t?` at ${t}`:""}`}</span>case"DatabaseDoesNotExist":<span class="cstat-no" title="statement not covered" >return`Database \`${e.cause.db??"(not available)"}\` does not exist on the database server`;c</span>ase"SocketTimeout":<span class="cstat-no" title="statement not covered" >return"Operation has timed out";c</span>ase"DatabaseAlreadyExists":<span class="cstat-no" title="statement not covered" >return`Database \`${e.cause.db??"(not available)"}\` already exists on the database server`;c</span>ase"DatabaseAccessDenied":<span class="cstat-no" title="statement not covered" >return`User was denied access on the database \`${e.cause.db??"(not available)"}\``;c</span>ase"TlsConnectionError":<span class="cstat-no" title="statement not covered" >return`Error opening a TLS connection: ${e.cause.reason}`;c</span>ase"ConnectionClosed":<span class="cstat-no" title="statement not covered" >return"Server has closed the connection.";c</span>ase"TransactionAlreadyClosed":<span class="cstat-no" title="statement not covered" >return e.cause.cause;c</span>ase"LengthMismatch":<span class="cstat-no" title="statement not covered" >return`The provided value for the column is too long for the column's type. Column: ${e.cause.column??"(not available)"}`;c</span>ase"UniqueConstraintViolation":<span class="cstat-no" title="statement not covered" >return`Unique constraint failed on the ${Gi(e.cause.constraint)}`;c</span>ase"ForeignKeyConstraintViolation":<span class="cstat-no" title="statement not covered" >return`Foreign key constraint violated on the ${Gi(e.cause.constraint)}`;c</span>ase"UnsupportedNativeDataType":<span class="cstat-no" title="statement not covered" >return`Failed to deserialize column of type '${e.cause.type}'. If you're using $queryRaw and this column is explicitly marked as \`Unsupported\` in your Prisma schema, try casting this column to any supported Prisma type such as \`String\`.`;c</span>ase"NullConstraintViolation":<span class="cstat-no" title="statement not covered" >return`Null constraint violation on the ${Gi(e.cause.constraint)}`;c</span>ase"ValueOutOfRange":<span class="cstat-no" title="statement not covered" >return`Value out of range for the type: ${e.cause.cause}`;c</span>ase"TableDoesNotExist":<span class="cstat-no" title="statement not covered" >return`The table \`${e.cause.table??"(not available)"}\` does not exist in the current database.`;c</span>ase"ColumnNotFound":<span class="cstat-no" title="statement not covered" >return`The column \`${e.cause.column??"(not available)"}\` does not exist in the current database.`;c</span>ase"InvalidIsolationLevel":<span class="cstat-no" title="statement not covered" >return`Error in connector: Conversion error: ${e.cause.level}`;c</span>ase"InconsistentColumnData":<span class="cstat-no" title="statement not covered" >return`Inconsistent column data: ${e.cause.cause}`;c</span>ase"MissingFullTextSearchIndex":<span class="cstat-no" title="statement not covered" >return"Cannot find a fulltext index to use for the native search, try adding a @@fulltext([Fields...]) to your schema";c</span>ase"TransactionWriteConflict":<span class="cstat-no" title="statement not covered" >return"Transaction failed due to a write conflict or a deadlock. Please retry your transaction";c</span>ase"GenericJs":<span class="cstat-no" title="statement not covered" >return`Error in external connector (id ${e.cause.id})`;c</span>ase"TooManyConnections":<span class="cstat-no" title="statement not covered" >return`Too many database connections opened: ${e.cause.cause}`;c</span>ase"sqlite":case"postgres":case"mysql":case"mssql":<span class="cstat-no" title="statement not covered" >return;d</span>efault:<span class="cstat-no" title="statement not covered" >$(e.cause,`Unknown error: ${e.cause}`)}</span>}</span>function <span class="fstat-no" title="function not covered" >Gi(</span>e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;"fields"in e?`fields: (${e.fields.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >`\`${t}\``)</span>.join(", ")})`:e&amp;&amp;"index"in e?`constraint: \`${e.index}\``:e&amp;&amp;"foreignKey"in e?"foreign key":"(not available)"}</span>function <span class="fstat-no" title="function not covered" >Za(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >e.map(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >t.keys.reduce(<span class="fstat-no" title="function not covered" >(o</span>,s)=&gt;(<span class="cstat-no" title="statement not covered" >o[s]=Qe(i[s]),o)</span>,{}))</span>,</span>n=<span class="cstat-no" title="statement not covered" >new Set(t.nestedSelection);<span class="cstat-no" title="statement not covered" ></span>return t.arguments.map(<span class="fstat-no" title="function not covered" >i=</span>&gt;{let o=<span class="cstat-no" title="statement not covered" >r.findIndex(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >Dt(s,i))</span>;<span class="cstat-no" title="statement not covered" ></span>if(o===-1)<span class="cstat-no" title="statement not covered" >return t.expectNonEmpty?new ce("An operation failed because it depends on one or more records that were required but not found","P2025"):null;{</span></span>let s=<span class="cstat-no" title="statement not covered" >Object.entries(e[o]).filter(<span class="fstat-no" title="function not covered" >([</span>a])=&gt;<span class="cstat-no" title="statement not covered" >n.has(a))</span>;<span class="cstat-no" title="statement not covered" ></span>return Object.fromEntries(s)}</span>})}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar G=<span class="cstat-no" title="statement not covered" >class extends Error{name=<span class="cstat-no" title="statement not covered" >"DataMapperError"}</span>;</span>function <span class="fstat-no" title="function not covered" >el(</span>e,t,r){<span class="cstat-no" title="statement not covered" >switch(t.type){case"affectedRows":<span class="cstat-no" title="statement not covered" >if(typeof e!="number")<span class="cstat-no" title="statement not covered" >throw new G(`Expected an affected rows count, got: ${typeof e} (${e})`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{count:e};c</span>ase"object":<span class="cstat-no" title="statement not covered" >return Ki(e,t.fields,r,t.skipNulls);c</span>ase"field":<span class="cstat-no" title="statement not covered" >return Wi(e,"&lt;result&gt;",t.fieldType,r);d</span>efault:<span class="cstat-no" title="statement not covered" >$(t,`Invalid data mapping type: '${t.type}'`)}</span>}</span>function <span class="fstat-no" title="function not covered" >Ki(</span>e,t,r,n){<span class="cstat-no" title="statement not covered" >if(e===null)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(e)){let i=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;(i=i.filter(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >o!==null)</span>),i.map(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >Xa(o,t,r))</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof e=="object")<span class="cstat-no" title="statement not covered" >return Xa(e,t,r);<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof e=="string"){let i;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >i=JSON.parse(e)}</span>catch(o){<span class="cstat-no" title="statement not covered" >throw new G("Expected an array or object, got a string that is not valid JSON",{cause:o})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Ki(i,t,r,n)}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow new G(`Expected an array or an object, got: ${typeof e}`)}</span>function <span class="fstat-no" title="function not covered" >Xa(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if(typeof e!="object")<span class="cstat-no" title="statement not covered" >throw new G(`Expected an object, but got '${typeof e}'`);l</span></span>et n=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let[i,o]of Object.entries(t))<span class="cstat-no" title="statement not covered" >switch(o.type){case"affectedRows":<span class="cstat-no" title="statement not covered" >throw new G(`Unexpected 'AffectedRows' node in data mapping for field '${i}'`);c</span>ase"object":{<span class="cstat-no" title="statement not covered" >if(o.serializedName!==null&amp;&amp;!Object.hasOwn(e,o.serializedName))<span class="cstat-no" title="statement not covered" >throw new G(`Missing data field (Object): '${i}'; node: ${JSON.stringify(o)}; data: ${JSON.stringify(e)}`);l</span></span>et s=<span class="cstat-no" title="statement not covered" >o.serializedName!==null?e[o.serializedName]:e;<span class="cstat-no" title="statement not covered" ></span>n[i]=Ki(s,o.fields,r,o.skipNulls);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"field":{let s=<span class="cstat-no" title="statement not covered" >o.dbName;<span class="cstat-no" title="statement not covered" ></span>if(Object.hasOwn(e,s))<span class="cstat-no" title="statement not covered" >n[i]=vm(e[s],s,o.fieldType,r);e</span>lse <span class="cstat-no" title="statement not covered" >throw new G(`Missing data field (Value): '${s}'; node: ${JSON.stringify(o)}; data: ${JSON.stringify(e)}`)}<span class="cstat-no" title="statement not covered" ></span></span>break;d</span>efault:<span class="cstat-no" title="statement not covered" >$(o,`DataMapper: Invalid data mapping node type: '${o.type}'`)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn n}</span>function <span class="fstat-no" title="function not covered" >vm(</span>e,t,r,n){<span class="cstat-no" title="statement not covered" >return e===null?r.arity==="list"?[]:null:r.arity==="list"?e.map(<span class="fstat-no" title="function not covered" >(o</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >Wi(o,`${t}[${s}]`,r,n))</span>:Wi(e,t,r,n)}</span>function <span class="fstat-no" title="function not covered" >Wi(</span>e,t,r,n){<span class="cstat-no" title="statement not covered" >switch(r.type){case"unsupported":<span class="cstat-no" title="statement not covered" >return e;c</span>ase"string":{<span class="cstat-no" title="statement not covered" >if(typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new G(`Expected a string in column '${t}', got ${typeof e}: ${e}`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>case"int":<span class="cstat-no" title="statement not covered" >switch(typeof e){case"number":<span class="cstat-no" title="statement not covered" >return Math.trunc(e);c</span>ase"string":{let i=<span class="cstat-no" title="statement not covered" >Math.trunc(Number(e));<span class="cstat-no" title="statement not covered" ></span>if(Number.isNaN(i)||!Number.isFinite(i))<span class="cstat-no" title="statement not covered" >throw new G(`Expected an integer in column '${t}', got string: ${e}`);<span class="cstat-no" title="statement not covered" >i</span></span>f(!Number.isSafeInteger(i))<span class="cstat-no" title="statement not covered" >throw new G(`Integer value in column '${t}' is too large to represent as a JavaScript number without loss of precision, got: ${e}. Consider using BigInt type.`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>default:<span class="cstat-no" title="statement not covered" >throw new G(`Expected an integer in column '${t}', got ${typeof e}: ${e}`)}</span>c</span>ase"bigint":{<span class="cstat-no" title="statement not covered" >if(typeof e!="number"&amp;&amp;typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new G(`Expected a bigint in column '${t}', got ${typeof e}: ${e}`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{$type:"BigInt",value:e}}</span>case"float":{<span class="cstat-no" title="statement not covered" >if(typeof e=="number")<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof e=="string"){let i=<span class="cstat-no" title="statement not covered" >Number(e);<span class="cstat-no" title="statement not covered" ></span>if(Number.isNaN(i)&amp;&amp;!/^[-+]?nan$/.test(e.toLowerCase()))<span class="cstat-no" title="statement not covered" >throw new G(`Expected a float in column '${t}', got string: ${e}`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow new G(`Expected a float in column '${t}', got ${typeof e}: ${e}`)}</span>case"boolean":{<span class="cstat-no" title="statement not covered" >if(typeof e=="boolean")<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof e=="number")<span class="cstat-no" title="statement not covered" >return e===1;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof e=="string"){<span class="cstat-no" title="statement not covered" >if(e==="true"||e==="TRUE"||e==="1")<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(e==="false"||e==="FALSE"||e==="0")<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >t</span></span>hrow new G(`Expected a boolean in column '${t}', got ${typeof e}: ${e}`)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(Array.isArray(e)){<span class="cstat-no" title="statement not covered" >for(let i of e)<span class="cstat-no" title="statement not covered" >if(i!==0)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow new G(`Expected a boolean in column '${t}', got ${typeof e}: ${e}`)}</span>case"decimal":<span class="cstat-no" title="statement not covered" >if(typeof e!="number"&amp;&amp;typeof e!="string"&amp;&amp;!se.isDecimal(e))<span class="cstat-no" title="statement not covered" >throw new G(`Expected a decimal in column '${t}', got ${typeof e}: ${e}`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{$type:"Decimal",value:e};c</span>ase"datetime":{<span class="cstat-no" title="statement not covered" >if(typeof e=="string")<span class="cstat-no" title="statement not covered" >return{$type:"DateTime",value:Rm(e)};<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof e=="number"||e instanceof Date)<span class="cstat-no" title="statement not covered" >return{$type:"DateTime",value:e};<span class="cstat-no" title="statement not covered" >t</span></span>hrow new G(`Expected a date in column '${t}', got ${typeof e}: ${e}`)}</span>case"object":<span class="cstat-no" title="statement not covered" >return{$type:"Json",value:br(e)};c</span>ase"json":<span class="cstat-no" title="statement not covered" >return{$type:"Json",value:`${e}`};c</span>ase"bytes":{<span class="cstat-no" title="statement not covered" >switch(r.encoding){case"base64":<span class="cstat-no" title="statement not covered" >if(typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new G(`Expected a base64-encoded byte array in column '${t}', got ${typeof e}: ${e}`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{$type:"Bytes",value:e};c</span>ase"hex":<span class="cstat-no" title="statement not covered" >if(typeof e!="string"||!e.startsWith("\\x"))<span class="cstat-no" title="statement not covered" >throw new G(`Expected a hex-encoded byte array in column '${t}', got ${typeof e}: ${e}`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{$type:"Bytes",value:y.from(e.slice(2),"hex").toString("base64")};c</span>ase"array":<span class="cstat-no" title="statement not covered" >if(Array.isArray(e))<span class="cstat-no" title="statement not covered" >return{$type:"Bytes",value:y.from(e).toString("base64")};<span class="cstat-no" title="statement not covered" >i</span></span>f(e instanceof Uint8Array)<span class="cstat-no" title="statement not covered" >return{$type:"Bytes",value:y.from(e).toString("base64")};<span class="cstat-no" title="statement not covered" >t</span></span>hrow new G(`Expected a byte array in column '${t}', got ${typeof e}: ${e}`);d</span>efault:<span class="cstat-no" title="statement not covered" >$(r.encoding,`DataMapper: Unknown bytes encoding: ${r.encoding}`)}<span class="cstat-no" title="statement not covered" ></span>b</span>reak}</span>case"enum":{let i=<span class="cstat-no" title="statement not covered" >n[r.name];<span class="cstat-no" title="statement not covered" ></span>if(i===void 0)<span class="cstat-no" title="statement not covered" >throw new G(`Unknown enum '${r.name}'`);l</span></span>et o=<span class="cstat-no" title="statement not covered" >i[`${e}`];<span class="cstat-no" title="statement not covered" ></span>if(o===void 0)<span class="cstat-no" title="statement not covered" >throw new G(`Value '${e}' not found in enum '${r.name}'`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn o}</span>default:<span class="cstat-no" title="statement not covered" >$(r,`DataMapper: Unknown result type: ${r.type}`)}</span>}</span>var Am=<span class="cstat-no" title="statement not covered" >/\d{2}:\d{2}:\d{2}(?:\.\d+)?(Z|[+-]\d{2}(:?\d{2})?)?$/;</span>function <span class="fstat-no" title="function not covered" >Rm(</span>e){let t=<span class="cstat-no" title="statement not covered" >Am.exec(e);<span class="cstat-no" title="statement not covered" ></span>if(t===null)<span class="cstat-no" title="statement not covered" >return`${e}Z`;l</span></span>et r=<span class="cstat-no" title="statement not covered" >e,</span>[n,i,o]=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return i!==void 0&amp;&amp;i!=="Z"&amp;&amp;o===void 0?r=`${e}:00`:i===void 0&amp;&amp;(r=`${e}Z`),n.length===e.length?`1970-01-01T${r}`:r}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Er;<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e[e.INTERNAL=0]="INTERNAL",e[e.SERVER=1]="SERVER",e[e.CLIENT=2]="CLIENT",e[e.PRODUCER=3]="PRODUCER",e[e.CONSUMER=4]="CONSUMER"}</span>)(Er||(Er={}));f</span>unction <span class="fstat-no" title="function not covered" >Cm(</span>e){<span class="cstat-no" title="statement not covered" >switch(e){case"postgresql":case"postgres":case"prisma+postgres":<span class="cstat-no" title="statement not covered" >return"postgresql";c</span>ase"sqlserver":<span class="cstat-no" title="statement not covered" >return"mssql";c</span>ase"mysql":case"sqlite":case"cockroachdb":case"mongodb":<span class="cstat-no" title="statement not covered" >return e;d</span>efault:<span class="cstat-no" title="statement not covered" >$(e,`Unknown provider: ${e}`)}</span>}</span>async function <span class="fstat-no" title="function not covered" >Ln(</span>{query:e,tracingHelper:t,provider:r,onQuery:n,execute:i}){<span class="cstat-no" title="statement not covered" >return await t.runInChildSpan({name:"db_query",kind:Er.CLIENT,attributes:{"db.query.text":e.sql,"db.system.name":Cm(r)}},<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{let o=<span class="cstat-no" title="statement not covered" >new Date,</span>s=<span class="cstat-no" title="statement not covered" >b.now(),</span>a=<span class="cstat-no" title="statement not covered" >await i(),</span>f=<span class="cstat-no" title="statement not covered" >b.now();<span class="cstat-no" title="statement not covered" ></span>return n?.({timestamp:o,duration:f-s,query:e.sql,params:e.args}),a}</span>)}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >tt(</span>e,t){var r=<span class="cstat-no" title="statement not covered" >"000000000"+e;<span class="cstat-no" title="statement not covered" ></span>return r.substr(r.length-t)}</span>var tl=<span class="cstat-no" title="statement not covered" >$e(ys(),1);</span>function <span class="fstat-no" title="function not covered" >Sm(</span>){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return tl.default.hostname()}</span>catch{<span class="cstat-no" title="statement not covered" >return g.env._CLUSTER_NETWORK_NAME_||g.env.COMPUTERNAME||"hostname"}</span>}</span>var rl=<span class="cstat-no" title="statement not covered" >2,</span>Im=<span class="cstat-no" title="statement not covered" >tt(g.pid.toString(36),rl),</span>nl=<span class="cstat-no" title="statement not covered" >Sm(),</span>km=<span class="cstat-no" title="statement not covered" >nl.length,</span>Om=<span class="cstat-no" title="statement not covered" >tt(nl.split("").reduce(<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return+e+t.charCodeAt(0)}</span>,+km+36).toString(36),rl);</span>function <span class="fstat-no" title="function not covered" >zi(</span>){<span class="cstat-no" title="statement not covered" >return Im+Om}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Un(</span>e){<span class="cstat-no" title="statement not covered" >return typeof e=="string"&amp;&amp;/^c[a-z0-9]{20,32}$/.test(e)}</span>function <span class="fstat-no" title="function not covered" >Yi(</span>e){let n=<span class="cstat-no" title="statement not covered" >Math.pow(36,4),</span>i=<span class="cstat-no" title="statement not covered" >0;</span>function <span class="fstat-no" title="function not covered" >o(</span>){<span class="cstat-no" title="statement not covered" >return tt((Math.random()*n&lt;&lt;0).toString(36),4)}</span>function <span class="fstat-no" title="function not covered" >s(</span>){<span class="cstat-no" title="statement not covered" >return i=i&lt;n?i:0,i++,i-1}</span>function <span class="fstat-no" title="function not covered" >a(</span>){var f=<span class="cstat-no" title="statement not covered" >"c",</span>w=<span class="cstat-no" title="statement not covered" >new Date().getTime().toString(36),</span>A=<span class="cstat-no" title="statement not covered" >tt(s().toString(36),4),</span>R=<span class="cstat-no" title="statement not covered" >e(),</span>S=<span class="cstat-no" title="statement not covered" >o()+o();<span class="cstat-no" title="statement not covered" ></span>return f+w+A+R+S}<span class="cstat-no" title="statement not covered" ></span>return a.fingerprint=e,a.isCuid=Un,a}</span>var Dm=<span class="cstat-no" title="statement not covered" >Yi(zi);</span>var il=<span class="cstat-no" title="statement not covered" >Dm;</span>var tc=<span class="cstat-no" title="statement not covered" >$e(Wl());<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >X</span>e();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Kl=<span class="cstat-no" title="statement not covered" >"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";</span>var wd=<span class="cstat-no" title="statement not covered" >128,</span>nt,Lt;function <span class="fstat-no" title="function not covered" >bd(</span>e){<span class="cstat-no" title="statement not covered" >!nt||nt.length&lt;e?(nt=y.allocUnsafe(e*wd),Xt.getRandomValues(nt),Lt=0):Lt+e&gt;nt.length&amp;&amp;(Xt.getRandomValues(nt),Lt=0),Lt+=e}</span>function <span class="fstat-no" title="function not covered" >so(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >21)</span>{<span class="cstat-no" title="statement not covered" >bd(e|=0);l</span>et t=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >Lt-e;</span>r&lt;Lt;r++)<span class="cstat-no" title="statement not covered" >t+=Kl[nt[r]&amp;63];<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >X</span>e();v</span>ar Yl=<span class="cstat-no" title="statement not covered" >"0123456789ABCDEFGHJKMNPQRSTVWXYZ",</span>Rr=<span class="cstat-no" title="statement not covered" >32;</span>var Ed=<span class="cstat-no" title="statement not covered" >16,</span>Zl=<span class="cstat-no" title="statement not covered" >10,</span>zl=<span class="cstat-no" title="statement not covered" >0xffffffffffff;</span>var it;<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.Base32IncorrectEncoding="B32_ENC_INVALID",e.DecodeTimeInvalidCharacter="DEC_TIME_CHAR",e.DecodeTimeValueMalformed="DEC_TIME_MALFORMED",e.EncodeTimeNegative="ENC_TIME_NEG",e.EncodeTimeSizeExceeded="ENC_TIME_SIZE_EXCEED",e.EncodeTimeValueMalformed="ENC_TIME_MALFORMED",e.PRNGDetectFailure="PRNG_DETECT",e.ULIDInvalid="ULID_INVALID",e.Unexpected="UNEXPECTED",e.UUIDInvalid="UUID_INVALID"}</span>)(it||(it={}));v</span>ar ot=<span class="cstat-no" title="statement not covered" >class extends Error{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >super(`${r} (${t})`),this.name="ULIDError",this.code=t}</span>};</span>function <span class="fstat-no" title="function not covered" >xd(</span>e){let t=<span class="cstat-no" title="statement not covered" >Math.floor(e()*Rr);<span class="cstat-no" title="statement not covered" ></span>return t===Rr&amp;&amp;(t=Rr-1),Yl.charAt(t)}</span>function <span class="fstat-no" title="function not covered" >Pd(</span>e){let t=<span class="cstat-no" title="statement not covered" >Td(),</span>r=<span class="cstat-no" title="statement not covered" >t&amp;&amp;(t.crypto||t.msCrypto)||(typeof yt&lt;"u"?yt:null);<span class="cstat-no" title="statement not covered" ></span>if(typeof r?.getRandomValues=="function")<span class="cstat-no" title="statement not covered" >return<span class="fstat-no" title="function not covered" >()</span>=&gt;{let n=<span class="cstat-no" title="statement not covered" >new Uint8Array(1);<span class="cstat-no" title="statement not covered" ></span>return r.getRandomValues(n),n[0]/255}</span>;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof r?.randomBytes=="function")<span class="cstat-no" title="statement not covered" >return<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >r.randomBytes(1).readUInt8()/255;<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(yt?.randomBytes)<span class="cstat-no" title="statement not covered" >return<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >yt.randomBytes(1).readUInt8()/255;<span class="cstat-no" title="statement not covered" ></span>t</span></span>hrow new ot(it.PRNGDetectFailure,"Failed to find a reliable PRNG")}</span>function <span class="fstat-no" title="function not covered" >Td(</span>){<span class="cstat-no" title="statement not covered" >return Rd()?self:typeof window&lt;"u"?window:typeof globalThis&lt;"u"||typeof globalThis&lt;"u"?globalThis:null}</span>function <span class="fstat-no" title="function not covered" >vd(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>for(;e&gt;0;e--)<span class="cstat-no" title="statement not covered" >r=xd(t)+r;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >Ad(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >Zl)</span>{<span class="cstat-no" title="statement not covered" >if(isNaN(e))<span class="cstat-no" title="statement not covered" >throw new ot(it.EncodeTimeValueMalformed,`Time must be a number: ${e}`);<span class="cstat-no" title="statement not covered" >i</span></span>f(e&gt;zl)<span class="cstat-no" title="statement not covered" >throw new ot(it.EncodeTimeSizeExceeded,`Cannot encode a time larger than ${zl}: ${e}`);<span class="cstat-no" title="statement not covered" >i</span></span>f(e&lt;0)<span class="cstat-no" title="statement not covered" >throw new ot(it.EncodeTimeNegative,`Time must be positive: ${e}`);<span class="cstat-no" title="statement not covered" >i</span></span>f(Number.isInteger(e)===!1)<span class="cstat-no" title="statement not covered" >throw new ot(it.EncodeTimeValueMalformed,`Time must be an integer: ${e}`);l</span></span>et r,n=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >t;</span>i&gt;0;i--)<span class="cstat-no" title="statement not covered" >r=e%Rr,n=Yl.charAt(r)+n,e=(e-r)/Rr;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>function <span class="fstat-no" title="function not covered" >Rd(</span>){<span class="cstat-no" title="statement not covered" >return typeof WorkerGlobalScope&lt;"u"&amp;&amp;self instanceof WorkerGlobalScope}</span>function <span class="fstat-no" title="function not covered" >Xl(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >t||Pd(),</span>n=<span class="cstat-no" title="statement not covered" >!e||isNaN(e)?Date.now():e;<span class="cstat-no" title="statement not covered" ></span>return Ad(n,Zl)+vd(Ed,r)}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar oe=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;256;++e)<span class="cstat-no" title="statement not covered" >oe.push((e+256).toString(16).slice(1));f</span></span>unction <span class="fstat-no" title="function not covered" >qn(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return(oe[e[t+0]]+oe[e[t+1]]+oe[e[t+2]]+oe[e[t+3]]+"-"+oe[e[t+4]]+oe[e[t+5]]+"-"+oe[e[t+6]]+oe[e[t+7]]+"-"+oe[e[t+8]]+oe[e[t+9]]+"-"+oe[e[t+10]]+oe[e[t+11]]+oe[e[t+12]]+oe[e[t+13]]+oe[e[t+14]]+oe[e[t+15]]).toLowerCase()}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >X</span>e();v</span>ar jn=<span class="cstat-no" title="statement not covered" >new Uint8Array(256),</span>Bn=<span class="cstat-no" title="statement not covered" >jn.length;</span>function <span class="fstat-no" title="function not covered" >Ut(</span>){<span class="cstat-no" title="statement not covered" >return Bn&gt;jn.length-16&amp;&amp;(sn(jn),Bn=0),jn.slice(Bn,Bn+=16)}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >X</span>e();v</span>ar ao=<span class="cstat-no" title="statement not covered" >{randomUUID:on};</span>function <span class="fstat-no" title="function not covered" >Cd(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if(ao.randomUUID&amp;&amp;!t&amp;&amp;!e)<span class="cstat-no" title="statement not covered" >return ao.randomUUID();<span class="cstat-no" title="statement not covered" >e</span></span>=e||{};l</span>et n=<span class="cstat-no" title="statement not covered" >e.random??e.rng?.()??Ut();<span class="cstat-no" title="statement not covered" ></span>if(n.length&lt;16)<span class="cstat-no" title="statement not covered" >throw new Error("Random bytes length must be &gt;= 16");<span class="cstat-no" title="statement not covered" >i</span></span>f(n[6]=n[6]&amp;15|64,n[8]=n[8]&amp;63|128,t){<span class="cstat-no" title="statement not covered" >if(r=r||0,r&lt;0||r+16&gt;t.length)<span class="cstat-no" title="statement not covered" >throw new RangeError(`UUID byte range ${r}:${r+15} is out of buffer bounds`);<span class="cstat-no" title="statement not covered" >f</span></span>or(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;16;++i)<span class="cstat-no" title="statement not covered" >t[r+i]=n[i];<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn qn(n)}</span>var lo=<span class="cstat-no" title="statement not covered" >Cd;<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar co=<span class="cstat-no" title="statement not covered" >{};</span>function <span class="fstat-no" title="function not covered" >Sd(</span>e,t,r){let n;<span class="cstat-no" title="statement not covered" >if(e)<span class="cstat-no" title="statement not covered" >n=ec(e.random??e.rng?.()??Ut(),e.msecs,e.seq,t,r);e</span>lse{let i=<span class="cstat-no" title="statement not covered" >Date.now(),</span>o=<span class="cstat-no" title="statement not covered" >Ut();<span class="cstat-no" title="statement not covered" ></span>Id(co,i,o),n=ec(o,co.msecs,co.seq,t,r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t??qn(n)}</span>function <span class="fstat-no" title="function not covered" >Id(</span>e,t,r){<span class="cstat-no" title="statement not covered" >return e.msecs??=-1/0,e.seq??=0,t&gt;e.msecs?(e.seq=r[6]&lt;&lt;23|r[7]&lt;&lt;16|r[8]&lt;&lt;8|r[9],e.msecs=t):(e.seq=e.seq+1|0,e.seq===0&amp;&amp;e.msecs++),e}</span>function <span class="fstat-no" title="function not covered" >ec(</span>e,t,r,n,i=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >if(e.length&lt;16)<span class="cstat-no" title="statement not covered" >throw new Error("Random bytes length must be &gt;= 16");<span class="cstat-no" title="statement not covered" >i</span></span>f(!n)<span class="cstat-no" title="statement not covered" >n=new Uint8Array(16),i=0;e</span>lse <span class="cstat-no" title="statement not covered" >if(i&lt;0||i+16&gt;n.length)<span class="cstat-no" title="statement not covered" >throw new RangeError(`UUID byte range ${i}:${i+15} is out of buffer bounds`);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t??=Date.now(),r??=e[6]*127&lt;&lt;24|e[7]&lt;&lt;16|e[8]&lt;&lt;8|e[9],n[i++]=t/1099511627776&amp;255,n[i++]=t/4294967296&amp;255,n[i++]=t/16777216&amp;255,n[i++]=t/65536&amp;255,n[i++]=t/256&amp;255,n[i++]=t&amp;255,n[i++]=112|r&gt;&gt;&gt;28&amp;15,n[i++]=r&gt;&gt;&gt;20&amp;255,n[i++]=128|r&gt;&gt;&gt;14&amp;63,n[i++]=r&gt;&gt;&gt;6&amp;255,n[i++]=r&lt;&lt;2&amp;255|e[10]&amp;3,n[i++]=e[11],n[i++]=e[12],n[i++]=e[13],n[i++]=e[14],n[i++]=e[15],n}</span>var uo=<span class="cstat-no" title="statement not covered" >Sd;</span>var Qn=<span class="cstat-no" title="statement not covered" >class{#t=<span class="cstat-no" title="statement not covered" >{};<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.register("uuid",new mo),this.register("cuid",new fo),this.register("ulid",new go),this.register("nanoid",new yo),this.register("product",new ho)}<span class="fstat-no" title="function not covered" ></span>sn</span>apshot(){<span class="cstat-no" title="statement not covered" >return Object.create(this.#t,{now:{value:new po}})}<span class="fstat-no" title="function not covered" ></span>re</span>gister(t,r){<span class="cstat-no" title="statement not covered" >this.#t[t]=r}</span>},</span>po=<span class="cstat-no" title="statement not covered" >class{#t=<span class="cstat-no" title="statement not covered" >new Date;<span class="fstat-no" title="function not covered" ></span>ge</span>nerate(){<span class="cstat-no" title="statement not covered" >return this.#t.toISOString()}</span>},</span>mo=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >ge</span>nerate(t){<span class="cstat-no" title="statement not covered" >if(t===4)<span class="cstat-no" title="statement not covered" >return lo();<span class="cstat-no" title="statement not covered" >i</span></span>f(t===7)<span class="cstat-no" title="statement not covered" >return uo();<span class="cstat-no" title="statement not covered" >t</span></span>hrow new Error("Invalid UUID generator arguments")}</span>},</span>fo=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >ge</span>nerate(t){<span class="cstat-no" title="statement not covered" >if(t===1)<span class="cstat-no" title="statement not covered" >return il();<span class="cstat-no" title="statement not covered" >i</span></span>f(t===2)<span class="cstat-no" title="statement not covered" >return(0,tc.createId)();<span class="cstat-no" title="statement not covered" >t</span></span>hrow new Error("Invalid CUID generator arguments")}</span>},</span>go=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >ge</span>nerate(){<span class="cstat-no" title="statement not covered" >return Xl()}</span>},</span>yo=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >ge</span>nerate(t){<span class="cstat-no" title="statement not covered" >if(typeof t=="number")<span class="cstat-no" title="statement not covered" >return so(t);<span class="cstat-no" title="statement not covered" >i</span></span>f(t===void 0)<span class="cstat-no" title="statement not covered" >return so();<span class="cstat-no" title="statement not covered" >t</span></span>hrow new Error("Invalid Nanoid generator arguments")}</span>},</span>ho=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >ge</span>nerate(t,r){<span class="cstat-no" title="statement not covered" >if(t===void 0||r===void 0)<span class="cstat-no" title="statement not covered" >throw new Error("Invalid Product generator arguments");<span class="cstat-no" title="statement not covered" >r</span></span>eturn Array.isArray(t)&amp;&amp;Array.isArray(r)?t.flatMap(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >r.map(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >[n,i])</span>)</span>:Array.isArray(t)?t.map(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >[n,r])</span>:Array.isArray(r)?r.map(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >[t,n])</span>:[[t,r]]}</span>};<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Hn(</span>e,t){<span class="cstat-no" title="statement not covered" >return e==null?e:typeof e=="string"?Hn(JSON.parse(e),t):Array.isArray(e)?Od(e,t):kd(e,t)}</span>function <span class="fstat-no" title="function not covered" >kd(</span>e,t){<span class="cstat-no" title="statement not covered" >if(t.pagination){let{skip:r,take:n,cursor:i}=<span class="cstat-no" title="statement not covered" >t.pagination;<span class="cstat-no" title="statement not covered" ></span>if(r!==null&amp;&amp;r&gt;0||n===0||i!==null&amp;&amp;!Dt(e,i))<span class="cstat-no" title="statement not covered" >return null}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn nc(e,t.nested)}</span>function <span class="fstat-no" title="function not covered" >nc(</span>e,t){<span class="cstat-no" title="statement not covered" >for(let[r,n]of Object.entries(t))<span class="cstat-no" title="statement not covered" >e[r]=Hn(e[r],n);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >Od(</span>e,t){<span class="cstat-no" title="statement not covered" >if(t.distinct!==null){let r=<span class="cstat-no" title="statement not covered" >t.linkingFields!==null?[...t.distinct,...t.linkingFields]:t.distinct;<span class="cstat-no" title="statement not covered" ></span>e=Dd(e,r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.pagination&amp;&amp;(e=_d(e,t.pagination,t.linkingFields)),t.reverse&amp;&amp;e.reverse(),Object.keys(t.nested).length===0?e:e.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >nc(r,t.nested))</span>}</span>function <span class="fstat-no" title="function not covered" >Dd(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >new Set,</span>n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i of e){let o=<span class="cstat-no" title="statement not covered" >Ft(i,t);<span class="cstat-no" title="statement not covered" ></span>r.has(o)||(r.add(o),n.push(i))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>function <span class="fstat-no" title="function not covered" >_d(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if(r===null)<span class="cstat-no" title="statement not covered" >return rc(e,t);l</span></span>et n=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>for(let o of e){let s=<span class="cstat-no" title="statement not covered" >Ft(o,r);<span class="cstat-no" title="statement not covered" ></span>n.has(s)||n.set(s,[]),n.get(s).push(o)}</span>l</span>et i=<span class="cstat-no" title="statement not covered" >Array.from(n.entries());<span class="cstat-no" title="statement not covered" ></span>return i.sort(<span class="fstat-no" title="function not covered" >([</span>o],[s])=&gt;<span class="cstat-no" title="statement not covered" >o&lt;s?-1:o&gt;s?1:0)</span>,i.flatMap(<span class="fstat-no" title="function not covered" >([</span>,o])=&gt;<span class="cstat-no" title="statement not covered" >rc(o,t))</span>}</span>function <span class="fstat-no" title="function not covered" >rc(</span>e,{cursor:t,skip:r,take:n}){let i=<span class="cstat-no" title="statement not covered" >t!==null?e.findIndex(<span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >Dt(a,t))</span>:0;<span class="cstat-no" title="statement not covered" ></span>if(i===-1)<span class="cstat-no" title="statement not covered" >return[];l</span></span>et o=<span class="cstat-no" title="statement not covered" >i+(r??0),</span>s=<span class="cstat-no" title="statement not covered" >n!==null?o+n:e.length;<span class="cstat-no" title="statement not covered" ></span>return e.slice(o,s)}</span>function <span class="fstat-no" title="function not covered" >Ft(</span>e,t){<span class="cstat-no" title="statement not covered" >return JSON.stringify(t.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >e[r])</span>)}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >wo(</span>e){<span class="cstat-no" title="statement not covered" >return typeof e=="object"&amp;&amp;e!==null&amp;&amp;e.prisma__type==="param"}</span>function <span class="fstat-no" title="function not covered" >bo(</span>e){<span class="cstat-no" title="statement not covered" >return typeof e=="object"&amp;&amp;e!==null&amp;&amp;e.prisma__type==="generatorCall"}</span>function <span class="fstat-no" title="function not covered" >Po(</span>e,t,r,n){let i=<span class="cstat-no" title="statement not covered" >e.args.map(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >Te(o,t,r))</span>;<span class="cstat-no" title="statement not covered" ></span>switch(e.type){case"rawSql":<span class="cstat-no" title="statement not covered" >return[Ld(e.sql,i,e.argTypes)];c</span>ase"templateSql":<span class="cstat-no" title="statement not covered" >return(e.chunkable?Fd(e.fragments,i,n):[i]).map(<span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(n!==void 0&amp;&amp;s.length&gt;n)<span class="cstat-no" title="statement not covered" >throw new ce("The query parameter limit supported by your database is exceeded.","P2029");<span class="cstat-no" title="statement not covered" >r</span></span>eturn Md(e.fragments,e.placeholderFormat,s,e.argTypes)}</span>);d</span>efault:<span class="cstat-no" title="statement not covered" >$(e.type,"Invalid query type")}</span>}</span>function <span class="fstat-no" title="function not covered" >Te(</span>e,t,r){<span class="cstat-no" title="statement not covered" >for(;Ud(e);)<span class="cstat-no" title="statement not covered" >if(wo(e)){let n=<span class="cstat-no" title="statement not covered" >t[e.prisma__value.name];<span class="cstat-no" title="statement not covered" ></span>if(n===void 0)<span class="cstat-no" title="statement not covered" >throw new Error(`Missing value for query variable ${e.prisma__value.name}`);<span class="cstat-no" title="statement not covered" >e</span></span>=n}</span>else <span class="cstat-no" title="statement not covered" >if(bo(e)){let{name:n,args:i}=<span class="cstat-no" title="statement not covered" >e.prisma__value,</span>o=<span class="cstat-no" title="statement not covered" >r[n];<span class="cstat-no" title="statement not covered" ></span>if(!o)<span class="cstat-no" title="statement not covered" >throw new Error(`Encountered an unknown generator '${n}'`);<span class="cstat-no" title="statement not covered" >e</span></span>=o.generate(...i.map(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >Te(s,t,r))</span>)}</span>else <span class="cstat-no" title="statement not covered" >$(e,`Unexpected unevaluated value type: ${e}`);<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn Array.isArray(e)&amp;&amp;(e=e.map(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >Te(n,t,r))</span>),e}</span>function <span class="fstat-no" title="function not covered" >Md(</span>e,t,r,n){let i=<span class="cstat-no" title="statement not covered" >"",</span>o=<span class="cstat-no" title="statement not covered" >{placeholderNumber:1},</span>s=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let f of xo(e,r,n)){<span class="cstat-no" title="statement not covered" >if(i+=Nd(f,t,o),f.type==="stringChunk")<span class="cstat-no" title="statement not covered" >continue;l</span></span>et w=<span class="cstat-no" title="statement not covered" >s.length,</span>A=<span class="cstat-no" title="statement not covered" >s.push(...ic(f))-w;<span class="cstat-no" title="statement not covered" ></span>if(f.argType.arity==="tuple"){<span class="cstat-no" title="statement not covered" >if(A%f.argType.elements.length!==0)<span class="cstat-no" title="statement not covered" >throw new Error(`Malformed query template. Expected the number of parameters to match the tuple arity, but got ${A} parameters for a tuple of arity ${f.argType.elements.length}.`);<span class="cstat-no" title="statement not covered" >f</span></span>or(let R=<span class="cstat-no" title="statement not covered" >0;</span>R&lt;A/f.argType.elements.length;R++)<span class="cstat-no" title="statement not covered" >a.push(...f.argType.elements)}</span></span>else <span class="cstat-no" title="statement not covered" >for(let R=<span class="cstat-no" title="statement not covered" >0;</span>R&lt;A;R++)<span class="cstat-no" title="statement not covered" >a.push(f.argType)}<span class="cstat-no" title="statement not covered" ></span></span></span>r</span>eturn{sql:i,args:s,argTypes:a}}</span>function <span class="fstat-no" title="function not covered" >Nd(</span>e,t,r){let n=<span class="cstat-no" title="statement not covered" >e.type;<span class="cstat-no" title="statement not covered" ></span>switch(n){case"parameter":<span class="cstat-no" title="statement not covered" >return Eo(t,r.placeholderNumber++);c</span>ase"stringChunk":<span class="cstat-no" title="statement not covered" >return e.chunk;c</span>ase"parameterTuple":<span class="cstat-no" title="statement not covered" >return`(${e.value.length==0?"NULL":e.value.map(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Eo(t,r.placeholderNumber++))</span>.join(",")})`;c</span>ase"parameterTupleList":<span class="cstat-no" title="statement not covered" >return e.value.map(<span class="fstat-no" title="function not covered" >i=</span>&gt;{let o=<span class="cstat-no" title="statement not covered" >i.map(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Eo(t,r.placeholderNumber++))</span>.join(e.itemSeparator);<span class="cstat-no" title="statement not covered" ></span>return`${e.itemPrefix}${o}${e.itemSuffix}`}</span>).join(e.groupSeparator);d</span>efault:<span class="cstat-no" title="statement not covered" >$(n,"Invalid fragment type")}</span>}</span>function <span class="fstat-no" title="function not covered" >Eo(</span>e,t){<span class="cstat-no" title="statement not covered" >return e.hasNumbering?`${e.prefix}${t}`:e.prefix}</span>function <span class="fstat-no" title="function not covered" >Ld(</span>e,t,r){<span class="cstat-no" title="statement not covered" >return{sql:e,args:t,argTypes:r}}</span>function <span class="fstat-no" title="function not covered" >Ud(</span>e){<span class="cstat-no" title="statement not covered" >return wo(e)||bo(e)}</span>function*<span class="fstat-no" title="function not covered" >xo(</span>e,t,r){let n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i of e)<span class="cstat-no" title="statement not covered" >switch(i.type){case"parameter":{<span class="cstat-no" title="statement not covered" >if(n&gt;=t.length)<span class="cstat-no" title="statement not covered" >throw new Error(`Malformed query template. Fragments attempt to read over ${t.length} parameters.`);<span class="cstat-no" title="statement not covered" >y</span></span>ield{...i,value:t[n],argType:r?.[n]},n++;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"stringChunk":{<span class="cstat-no" title="statement not covered" >yield i;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"parameterTuple":{<span class="cstat-no" title="statement not covered" >if(n&gt;=t.length)<span class="cstat-no" title="statement not covered" >throw new Error(`Malformed query template. Fragments attempt to read over ${t.length} parameters.`);l</span></span>et o=<span class="cstat-no" title="statement not covered" >t[n];<span class="cstat-no" title="statement not covered" ></span>yield{...i,value:Array.isArray(o)?o:[o],argType:r?.[n]},n++;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"parameterTupleList":{<span class="cstat-no" title="statement not covered" >if(n&gt;=t.length)<span class="cstat-no" title="statement not covered" >throw new Error(`Malformed query template. Fragments attempt to read over ${t.length} parameters.`);l</span></span>et o=<span class="cstat-no" title="statement not covered" >t[n];<span class="cstat-no" title="statement not covered" ></span>if(!Array.isArray(o))<span class="cstat-no" title="statement not covered" >throw new Error("Malformed query template. Tuple list expected.");<span class="cstat-no" title="statement not covered" >i</span></span>f(o.length===0)<span class="cstat-no" title="statement not covered" >throw new Error("Malformed query template. Tuple list cannot be empty.");<span class="cstat-no" title="statement not covered" >f</span></span>or(let s of o)<span class="cstat-no" title="statement not covered" >if(!Array.isArray(s))<span class="cstat-no" title="statement not covered" >throw new Error("Malformed query template. Tuple expected.");<span class="cstat-no" title="statement not covered" >y</span></span></span>ield{...i,value:o,argType:r?.[n]},n++;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}}</span></span>function*<span class="fstat-no" title="function not covered" >ic(</span>e){<span class="cstat-no" title="statement not covered" >switch(e.type){case"parameter":<span class="cstat-no" title="statement not covered" >yield e.value;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"stringChunk":<span class="cstat-no" title="statement not covered" >break;c</span>ase"parameterTuple":<span class="cstat-no" title="statement not covered" >yield*e.value;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"parameterTupleList":<span class="cstat-no" title="statement not covered" >for(let t of e.value)<span class="cstat-no" title="statement not covered" >yield*t;<span class="cstat-no" title="statement not covered" >b</span></span>reak}</span>}</span>function <span class="fstat-no" title="function not covered" >Fd(</span>e,t,r){let n=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let s of xo(e,t,void 0)){let a=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let f of ic(s))<span class="cstat-no" title="statement not covered" >a++;<span class="cstat-no" title="statement not covered" >i</span></span>=Math.max(i,a),n+=a}</span>l</span>et o=<span class="cstat-no" title="statement not covered" >[[]];<span class="cstat-no" title="statement not covered" ></span>for(let s of xo(e,t,void 0))<span class="cstat-no" title="statement not covered" >switch(s.type){case"parameter":{<span class="cstat-no" title="statement not covered" >for(let a of o)<span class="cstat-no" title="statement not covered" >a.push(s.value);<span class="cstat-no" title="statement not covered" >b</span></span>reak}</span>case"stringChunk":<span class="cstat-no" title="statement not covered" >break;c</span>ase"parameterTuple":{let a=<span class="cstat-no" title="statement not covered" >s.value.length,</span>f=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(r&amp;&amp;o.length===1&amp;&amp;a===i&amp;&amp;n&gt;r&amp;&amp;n-a&lt;r){let w=<span class="cstat-no" title="statement not covered" >r-(n-a);<span class="cstat-no" title="statement not covered" ></span>f=$d(s.value,w)}</span>else <span class="cstat-no" title="statement not covered" >f=[s.value];<span class="cstat-no" title="statement not covered" >o</span></span>=o.flatMap(<span class="fstat-no" title="function not covered" >w=</span>&gt;<span class="cstat-no" title="statement not covered" >f.map(<span class="fstat-no" title="function not covered" >A=</span>&gt;<span class="cstat-no" title="statement not covered" >[...w,A])</span>)</span>;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"parameterTupleList":{let a=<span class="cstat-no" title="statement not covered" >s.value.reduce(<span class="fstat-no" title="function not covered" >(R</span>,S)=&gt;<span class="cstat-no" title="statement not covered" >R+S.length,</span>0),</span>f=<span class="cstat-no" title="statement not covered" >[],</span>w=<span class="cstat-no" title="statement not covered" >[],</span>A=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let R of s.value)<span class="cstat-no" title="statement not covered" >r&amp;&amp;o.length===1&amp;&amp;a===i&amp;&amp;w.length&gt;0&amp;&amp;n-a+A+R.length&gt;r&amp;&amp;(f.push(w),w=[],A=0),w.push(R),A+=R.length;<span class="cstat-no" title="statement not covered" >w</span></span>.length&gt;0&amp;&amp;f.push(w),o=o.flatMap(<span class="fstat-no" title="function not covered" >R=</span>&gt;<span class="cstat-no" title="statement not covered" >f.map(<span class="fstat-no" title="function not covered" >S=</span>&gt;<span class="cstat-no" title="statement not covered" >[...R,S])</span>)</span>;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" >r</span></span>eturn o}</span>function <span class="fstat-no" title="function not covered" >$d(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e.length;n+=t)<span class="cstat-no" title="statement not covered" >r.push(e.slice(n,n+t));<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >oc(</span>e){<span class="cstat-no" title="statement not covered" >return e.rows.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.reduce(<span class="fstat-no" title="function not covered" >(r</span>,n,i)=&gt;(<span class="cstat-no" title="statement not covered" >r[e.columnNames[i]]=n,r)</span>,{}))</span>}</span>function <span class="fstat-no" title="function not covered" >sc(</span>e){<span class="cstat-no" title="statement not covered" >return{columns:e.columnNames,types:e.columnTypes.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Vd(t))</span>,rows:e.rows.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.map(<span class="fstat-no" title="function not covered" >(r</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >$t(r,e.columnTypes[n]))</span>)</span>}}</span>function <span class="fstat-no" title="function not covered" >$t(</span>e,t){<span class="cstat-no" title="statement not covered" >if(e===null)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >s</span></span>witch(t){case O.Int32:<span class="cstat-no" title="statement not covered" >switch(typeof e){case"number":<span class="cstat-no" title="statement not covered" >return Math.trunc(e);c</span>ase"string":<span class="cstat-no" title="statement not covered" >return Math.trunc(Number(e));d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error(`Cannot serialize value of type ${typeof e} as Int32`)}</span>c</span>ase O.Int32Array:<span class="cstat-no" title="statement not covered" >if(!Array.isArray(e))<span class="cstat-no" title="statement not covered" >throw new Error(`Cannot serialize value of type ${typeof e} as Int32Array`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >$t(r,O.Int32))</span>;c</span>ase O.Int64:<span class="cstat-no" title="statement not covered" >switch(typeof e){case"number":<span class="cstat-no" title="statement not covered" >return BigInt(Math.trunc(e));c</span>ase"string":<span class="cstat-no" title="statement not covered" >return e;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error(`Cannot serialize value of type ${typeof e} as Int64`)}</span>c</span>ase O.Int64Array:<span class="cstat-no" title="statement not covered" >if(!Array.isArray(e))<span class="cstat-no" title="statement not covered" >throw new Error(`Cannot serialize value of type ${typeof e} as Int64Array`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >$t(r,O.Int64))</span>;c</span>ase O.Json:<span class="cstat-no" title="statement not covered" >switch(typeof e){case"string":<span class="cstat-no" title="statement not covered" >return JSON.parse(e);d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error(`Cannot serialize value of type ${typeof e} as Json`)}</span>c</span>ase O.JsonArray:<span class="cstat-no" title="statement not covered" >if(!Array.isArray(e))<span class="cstat-no" title="statement not covered" >throw new Error(`Cannot serialize value of type ${typeof e} as JsonArray`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >$t(r,O.Json))</span>;c</span>ase O.Bytes:<span class="cstat-no" title="statement not covered" >if(Array.isArray(e))<span class="cstat-no" title="statement not covered" >return new Uint8Array(e);<span class="cstat-no" title="statement not covered" >t</span></span>hrow new Error(`Cannot serialize value of type ${typeof e} as Bytes`);c</span>ase O.BytesArray:<span class="cstat-no" title="statement not covered" >if(!Array.isArray(e))<span class="cstat-no" title="statement not covered" >throw new Error(`Cannot serialize value of type ${typeof e} as BytesArray`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >$t(r,O.Bytes))</span>;c</span>ase O.Boolean:<span class="cstat-no" title="statement not covered" >switch(typeof e){case"boolean":<span class="cstat-no" title="statement not covered" >return e;c</span>ase"string":<span class="cstat-no" title="statement not covered" >return e==="true"||e==="1";c</span>ase"number":<span class="cstat-no" title="statement not covered" >return e===1;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error(`Cannot serialize value of type ${typeof e} as Boolean`)}</span>c</span>ase O.BooleanArray:<span class="cstat-no" title="statement not covered" >if(!Array.isArray(e))<span class="cstat-no" title="statement not covered" >throw new Error(`Cannot serialize value of type ${typeof e} as BooleanArray`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >$t(r,O.Boolean))</span>;d</span>efault:<span class="cstat-no" title="statement not covered" >return e}</span>}</span>function <span class="fstat-no" title="function not covered" >Vd(</span>e){<span class="cstat-no" title="statement not covered" >switch(e){case O.Int32:<span class="cstat-no" title="statement not covered" >return"int";c</span>ase O.Int64:<span class="cstat-no" title="statement not covered" >return"bigint";c</span>ase O.Float:<span class="cstat-no" title="statement not covered" >return"float";c</span>ase O.Double:<span class="cstat-no" title="statement not covered" >return"double";c</span>ase O.Text:<span class="cstat-no" title="statement not covered" >return"string";c</span>ase O.Enum:<span class="cstat-no" title="statement not covered" >return"enum";c</span>ase O.Bytes:<span class="cstat-no" title="statement not covered" >return"bytes";c</span>ase O.Boolean:<span class="cstat-no" title="statement not covered" >return"bool";c</span>ase O.Character:<span class="cstat-no" title="statement not covered" >return"char";c</span>ase O.Numeric:<span class="cstat-no" title="statement not covered" >return"decimal";c</span>ase O.Json:<span class="cstat-no" title="statement not covered" >return"json";c</span>ase O.Uuid:<span class="cstat-no" title="statement not covered" >return"uuid";c</span>ase O.DateTime:<span class="cstat-no" title="statement not covered" >return"datetime";c</span>ase O.Date:<span class="cstat-no" title="statement not covered" >return"date";c</span>ase O.Time:<span class="cstat-no" title="statement not covered" >return"time";c</span>ase O.Int32Array:<span class="cstat-no" title="statement not covered" >return"int-array";c</span>ase O.Int64Array:<span class="cstat-no" title="statement not covered" >return"bigint-array";c</span>ase O.FloatArray:<span class="cstat-no" title="statement not covered" >return"float-array";c</span>ase O.DoubleArray:<span class="cstat-no" title="statement not covered" >return"double-array";c</span>ase O.TextArray:<span class="cstat-no" title="statement not covered" >return"string-array";c</span>ase O.EnumArray:<span class="cstat-no" title="statement not covered" >return"string-array";c</span>ase O.BytesArray:<span class="cstat-no" title="statement not covered" >return"bytes-array";c</span>ase O.BooleanArray:<span class="cstat-no" title="statement not covered" >return"bool-array";c</span>ase O.CharacterArray:<span class="cstat-no" title="statement not covered" >return"char-array";c</span>ase O.NumericArray:<span class="cstat-no" title="statement not covered" >return"decimal-array";c</span>ase O.JsonArray:<span class="cstat-no" title="statement not covered" >return"json-array";c</span>ase O.UuidArray:<span class="cstat-no" title="statement not covered" >return"uuid-array";c</span>ase O.DateTimeArray:<span class="cstat-no" title="statement not covered" >return"datetime-array";c</span>ase O.DateArray:<span class="cstat-no" title="statement not covered" >return"date-array";c</span>ase O.TimeArray:<span class="cstat-no" title="statement not covered" >return"time-array";c</span>ase O.UnknownNumber:<span class="cstat-no" title="statement not covered" >return"unknown";c</span>ase O.Set:<span class="cstat-no" title="statement not covered" >return"string";d</span>efault:<span class="cstat-no" title="statement not covered" >$(e,`Unexpected column type: ${e}`)}</span>}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >ac(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if(!t.every(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >To(e,n))</span>){let n=<span class="cstat-no" title="statement not covered" >qd(e,r),</span>i=<span class="cstat-no" title="statement not covered" >Bd(r);<span class="cstat-no" title="statement not covered" ></span>throw new ce(n,i,r.context)}</span>}</span>function <span class="fstat-no" title="function not covered" >To(</span>e,t){<span class="cstat-no" title="statement not covered" >switch(t.type){case"rowCountEq":<span class="cstat-no" title="statement not covered" >return Array.isArray(e)?e.length===t.args:e===null?t.args===0:t.args===1;c</span>ase"rowCountNeq":<span class="cstat-no" title="statement not covered" >return Array.isArray(e)?e.length!==t.args:e===null?t.args!==0:t.args!==1;c</span>ase"affectedRowCountEq":<span class="cstat-no" title="statement not covered" >return e===t.args;c</span>ase"never":<span class="cstat-no" title="statement not covered" >return!1;d</span>efault:<span class="cstat-no" title="statement not covered" >$(t,`Unknown rule type: ${t.type}`)}</span>}</span>function <span class="fstat-no" title="function not covered" >qd(</span>e,t){<span class="cstat-no" title="statement not covered" >switch(t.error_identifier){case"RELATION_VIOLATION":<span class="cstat-no" title="statement not covered" >return`The change you are trying to make would violate the required relation '${t.context.relation}' between the \`${t.context.modelA}\` and \`${t.context.modelB}\` models.`;c</span>ase"MISSING_RECORD":<span class="cstat-no" title="statement not covered" >return`An operation failed because it depends on one or more records that were required but not found. No record was found for ${t.context.operation}.`;c</span>ase"MISSING_RELATED_RECORD":{let r=<span class="cstat-no" title="statement not covered" >t.context.neededFor?` (needed to ${t.context.neededFor})`:"";<span class="cstat-no" title="statement not covered" ></span>return`An operation failed because it depends on one or more records that were required but not found. No '${t.context.model}' record${r} was found for ${t.context.operation} on ${t.context.relationType} relation '${t.context.relation}'.`}</span>case"INCOMPLETE_CONNECT_INPUT":<span class="cstat-no" title="statement not covered" >return`An operation failed because it depends on one or more records that were required but not found. Expected ${t.context.expectedRows} records to be connected, found only ${Array.isArray(e)?e.length:e}.`;c</span>ase"INCOMPLETE_CONNECT_OUTPUT":<span class="cstat-no" title="statement not covered" >return`The required connected records were not found. Expected ${t.context.expectedRows} records to be connected after connect operation on ${t.context.relationType} relation '${t.context.relation}', found ${Array.isArray(e)?e.length:e}.`;c</span>ase"RECORDS_NOT_CONNECTED":<span class="cstat-no" title="statement not covered" >return`The records for relation \`${t.context.relation}\` between the \`${t.context.parent}\` and \`${t.context.child}\` models are not connected.`;d</span>efault:<span class="cstat-no" title="statement not covered" >$(t,`Unknown error identifier: ${t}`)}</span>}</span>function <span class="fstat-no" title="function not covered" >Bd(</span>e){<span class="cstat-no" title="statement not covered" >switch(e.error_identifier){case"RELATION_VIOLATION":<span class="cstat-no" title="statement not covered" >return"P2014";c</span>ase"RECORDS_NOT_CONNECTED":<span class="cstat-no" title="statement not covered" >return"P2017";c</span>ase"INCOMPLETE_CONNECT_OUTPUT":<span class="cstat-no" title="statement not covered" >return"P2018";c</span>ase"MISSING_RECORD":case"MISSING_RELATED_RECORD":case"INCOMPLETE_CONNECT_INPUT":<span class="cstat-no" title="statement not covered" >return"P2025";d</span>efault:<span class="cstat-no" title="statement not covered" >$(e,`Unknown error identifier: ${e}`)}</span>}</span>var Cr=<span class="cstat-no" title="statement not covered" >class e{#t;#e;#r;#n=<span class="cstat-no" title="statement not covered" >new Qn;</span>#s;#i;#a;#o;#c;<span class="fstat-no" title="function not covered" >co</span>nstructor({transactionManager:t,placeholderValues:r,onQuery:n,tracingHelper:i,serializer:o,rawSerializer:s,provider:a,connectionInfo:f}){<span class="cstat-no" title="statement not covered" >this.#t=t,this.#e=r,this.#r=n,this.#s=i,this.#i=o,this.#a=s??o,this.#o=a,this.#c=f}<span class="fstat-no" title="function not covered" ></span>st</span>atic forSql(t){<span class="cstat-no" title="statement not covered" >return new e({transactionManager:t.transactionManager,placeholderValues:t.placeholderValues,onQuery:t.onQuery,tracingHelper:t.tracingHelper,serializer:oc,rawSerializer:sc,provider:t.provider,connectionInfo:t.connectionInfo})}<span class="fstat-no" title="function not covered" ></span>as</span>ync run(t,r){let{value:n}=<span class="cstat-no" title="statement not covered" >await this.interpretNode(t,r,this.#e,this.#n.snapshot()).catch(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >_t(i))</span>;<span class="cstat-no" title="statement not covered" ></span>return n}<span class="fstat-no" title="function not covered" ></span>as</span>ync interpretNode(t,r,n,i){<span class="cstat-no" title="statement not covered" >switch(t.type){case"value":<span class="cstat-no" title="statement not covered" >return{value:Te(t.args,n,i)};c</span>ase"seq":{let o;<span class="cstat-no" title="statement not covered" >for(let s of t.args)<span class="cstat-no" title="statement not covered" >o=await this.interpretNode(s,r,n,i);<span class="cstat-no" title="statement not covered" >r</span></span>eturn o??{value:void 0}}</span>case"get":<span class="cstat-no" title="statement not covered" >return{value:n[t.args.name]};c</span>ase"let":{let o=<span class="cstat-no" title="statement not covered" >Object.create(n);<span class="cstat-no" title="statement not covered" ></span>for(let s of t.args.bindings){let{value:a}=<span class="cstat-no" title="statement not covered" >await this.interpretNode(s.expr,r,o,i);<span class="cstat-no" title="statement not covered" ></span>o[s.name]=a}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.interpretNode(t.args.expr,r,o,i)}</span>case"getFirstNonEmpty":{<span class="cstat-no" title="statement not covered" >for(let o of t.args.names){let s=<span class="cstat-no" title="statement not covered" >n[o];<span class="cstat-no" title="statement not covered" ></span>if(!lc(s))<span class="cstat-no" title="statement not covered" >return{value:s}}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn{value:[]}}</span>case"concat":{let o=<span class="cstat-no" title="statement not covered" >await Promise.all(t.args.map(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >this.interpretNode(s,r,n,i).then(<span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >a.value)</span>)</span>);<span class="cstat-no" title="statement not covered" ></span>return{value:o.length&gt;0?o.reduce(<span class="fstat-no" title="function not covered" >(s</span>,a)=&gt;<span class="cstat-no" title="statement not covered" >s.concat(vo(a)),</span>[]):[]}}</span>case"sum":{let o=<span class="cstat-no" title="statement not covered" >await Promise.all(t.args.map(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >this.interpretNode(s,r,n,i).then(<span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >a.value)</span>)</span>);<span class="cstat-no" title="statement not covered" ></span>return{value:o.length&gt;0?o.reduce(<span class="fstat-no" title="function not covered" >(s</span>,a)=&gt;<span class="cstat-no" title="statement not covered" >Oe(s)+Oe(a))</span>:0}}</span>case"execute":{let o=<span class="cstat-no" title="statement not covered" >Po(t.args,n,i,this.#l()),</span>s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let a of o)<span class="cstat-no" title="statement not covered" >s+=await this.#u(a,r,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >r.executeRaw(a).catch(<span class="fstat-no" title="function not covered" >f=</span>&gt;<span class="cstat-no" title="statement not covered" >t.args.type==="rawSql"?Ji(f):_t(f))</span>)</span>;<span class="cstat-no" title="statement not covered" >r</span></span>eturn{value:s}}</span>case"query":{let o=<span class="cstat-no" title="statement not covered" >Po(t.args,n,i,this.#l()),</span>s;<span class="cstat-no" title="statement not covered" >for(let a of o){let f=<span class="cstat-no" title="statement not covered" >await this.#u(a,r,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >r.queryRaw(a).catch(<span class="fstat-no" title="function not covered" >w=</span>&gt;<span class="cstat-no" title="statement not covered" >t.args.type==="rawSql"?Ji(w):_t(w))</span>)</span>;<span class="cstat-no" title="statement not covered" ></span>s===void 0?s=f:(s.rows.push(...f.rows),s.lastInsertId=f.lastInsertId)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{value:t.args.type==="rawSql"?this.#a(s):this.#i(s),lastInsertId:s?.lastInsertId}}</span>case"reverse":{let{value:o,lastInsertId:s}=<span class="cstat-no" title="statement not covered" >await this.interpretNode(t.args,r,n,i);<span class="cstat-no" title="statement not covered" ></span>return{value:Array.isArray(o)?o.reverse():o,lastInsertId:s}}</span>case"unique":{let{value:o,lastInsertId:s}=<span class="cstat-no" title="statement not covered" >await this.interpretNode(t.args,r,n,i);<span class="cstat-no" title="statement not covered" ></span>if(!Array.isArray(o))<span class="cstat-no" title="statement not covered" >return{value:o,lastInsertId:s};<span class="cstat-no" title="statement not covered" >i</span></span>f(o.length&gt;1)<span class="cstat-no" title="statement not covered" >throw new Error(`Expected zero or one element, got ${o.length}`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{value:o[0]??null,lastInsertId:s}}</span>case"required":{let{value:o,lastInsertId:s}=<span class="cstat-no" title="statement not covered" >await this.interpretNode(t.args,r,n,i);<span class="cstat-no" title="statement not covered" ></span>if(lc(o))<span class="cstat-no" title="statement not covered" >throw new Error("Required value is empty");<span class="cstat-no" title="statement not covered" >r</span></span>eturn{value:o,lastInsertId:s}}</span>case"mapField":{let{value:o,lastInsertId:s}=<span class="cstat-no" title="statement not covered" >await this.interpretNode(t.args.records,r,n,i);<span class="cstat-no" title="statement not covered" ></span>return{value:cc(o,t.args.field),lastInsertId:s}}</span>case"join":{let{value:o,lastInsertId:s}=<span class="cstat-no" title="statement not covered" >await this.interpretNode(t.args.parent,r,n,i);<span class="cstat-no" title="statement not covered" ></span>if(o===null)<span class="cstat-no" title="statement not covered" >return{value:null,lastInsertId:s};l</span></span>et a=<span class="cstat-no" title="statement not covered" >await Promise.all(t.args.children.map(<span class="fstat-no" title="function not covered" >as</span>ync f=&gt;(<span class="cstat-no" title="statement not covered" >{joinExpr:f,childRecords:(await this.interpretNode(f.child,r,n,i)).value})</span>));<span class="cstat-no" title="statement not covered" ></span>return{value:jd(o,a),lastInsertId:s}}</span>case"transaction":{<span class="cstat-no" title="statement not covered" >if(!this.#t.enabled)<span class="cstat-no" title="statement not covered" >return this.interpretNode(t.args,r,n,i);l</span></span>et o=<span class="cstat-no" title="statement not covered" >this.#t.manager,</span>s=<span class="cstat-no" title="statement not covered" >await o.startTransaction(),</span>a=<span class="cstat-no" title="statement not covered" >await o.getTransaction(s,"query");<span class="cstat-no" title="statement not covered" ></span>try{let f=<span class="cstat-no" title="statement not covered" >await this.interpretNode(t.args,a,n,i);<span class="cstat-no" title="statement not covered" ></span>return await o.commitTransaction(s.id),f}</span>catch(f){<span class="cstat-no" title="statement not covered" >throw await o.rollbackTransaction(s.id),f}</span>}</span>case"dataMap":{let{value:o,lastInsertId:s}=<span class="cstat-no" title="statement not covered" >await this.interpretNode(t.args.expr,r,n,i);<span class="cstat-no" title="statement not covered" ></span>return{value:el(o,t.args.structure,t.args.enums),lastInsertId:s}}</span>case"validate":{let{value:o,lastInsertId:s}=<span class="cstat-no" title="statement not covered" >await this.interpretNode(t.args.expr,r,n,i);<span class="cstat-no" title="statement not covered" ></span>return ac(o,t.args.rules,t.args),{value:o,lastInsertId:s}}</span>case"if":{let{value:o}=<span class="cstat-no" title="statement not covered" >await this.interpretNode(t.args.value,r,n,i);<span class="cstat-no" title="statement not covered" ></span>return To(o,t.args.rule)?await this.interpretNode(t.args.then,r,n,i):await this.interpretNode(t.args.else,r,n,i)}</span>case"unit":<span class="cstat-no" title="statement not covered" >return{value:void 0};c</span>ase"diff":{let{value:o}=<span class="cstat-no" title="statement not covered" >await this.interpretNode(t.args.from,r,n,i),</span>{value:s}=<span class="cstat-no" title="statement not covered" >await this.interpretNode(t.args.to,r,n,i),</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >w=</span>&gt;<span class="cstat-no" title="statement not covered" >w!==null?Ft(Gn(w),t.args.fields):null,</span></span>f=<span class="cstat-no" title="statement not covered" >new Set(vo(s).map(a));<span class="cstat-no" title="statement not covered" ></span>return{value:vo(o).filter(<span class="fstat-no" title="function not covered" >w=</span>&gt;<span class="cstat-no" title="statement not covered" >!f.has(a(w)))</span>}}</span>case"process":{let{value:o,lastInsertId:s}=<span class="cstat-no" title="statement not covered" >await this.interpretNode(t.args.expr,r,n,i);<span class="cstat-no" title="statement not covered" ></span>return{value:Hn(o,t.args.operations),lastInsertId:s}}</span>case"initializeRecord":{let{lastInsertId:o}=<span class="cstat-no" title="statement not covered" >await this.interpretNode(t.args.expr,r,n,i),</span>s=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let[a,f]of Object.entries(t.args.fields))<span class="cstat-no" title="statement not covered" >s[a]=Qd(f,o,n,i);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{value:s,lastInsertId:o}}</span>case"mapRecord":{let{value:o,lastInsertId:s}=<span class="cstat-no" title="statement not covered" >await this.interpretNode(t.args.expr,r,n,i),</span>a=<span class="cstat-no" title="statement not covered" >o===null?{}:Gn(o);<span class="cstat-no" title="statement not covered" ></span>for(let[f,w]of Object.entries(t.args.fields))<span class="cstat-no" title="statement not covered" >a[f]=Hd(w,a[f],n,i);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{value:a,lastInsertId:s}}</span>default:<span class="cstat-no" title="statement not covered" >$(t,`Unexpected node type: ${t.type}`)}</span>}</span>#l(){<span class="cstat-no" title="statement not covered" >return this.#c?.maxBindValues!==void 0?this.#c.maxBindValues:this.#p()}</span>#p(){<span class="cstat-no" title="statement not covered" >if(this.#o!==void 0)<span class="cstat-no" title="statement not covered" >switch(this.#o){case"cockroachdb":case"postgres":case"postgresql":case"prisma+postgres":<span class="cstat-no" title="statement not covered" >return 32766;c</span>ase"mysql":<span class="cstat-no" title="statement not covered" >return 65535;c</span>ase"sqlite":<span class="cstat-no" title="statement not covered" >return 999;c</span>ase"sqlserver":<span class="cstat-no" title="statement not covered" >return 2098;c</span>ase"mongodb":<span class="cstat-no" title="statement not covered" >return;d</span>efault:<span class="cstat-no" title="statement not covered" >$(this.#o,`Unexpected provider: ${this.#o}`)}</span>}</span></span>#u(t,r,n){<span class="cstat-no" title="statement not covered" >return Ln({query:t,execute:n,provider:this.#o??r.provider,tracingHelper:this.#s,onQuery:this.#r})}</span>};</span>function <span class="fstat-no" title="function not covered" >lc(</span>e){<span class="cstat-no" title="statement not covered" >return Array.isArray(e)?e.length===0:e==null}</span>function <span class="fstat-no" title="function not covered" >vo(</span>e){<span class="cstat-no" title="statement not covered" >return Array.isArray(e)?e:[e]}</span>function <span class="fstat-no" title="function not covered" >Oe(</span>e){<span class="cstat-no" title="statement not covered" >if(typeof e=="number")<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof e=="string")<span class="cstat-no" title="statement not covered" >return Number(e);<span class="cstat-no" title="statement not covered" >t</span></span>hrow new Error(`Expected number, got ${typeof e}`)}</span>function <span class="fstat-no" title="function not covered" >Gn(</span>e){<span class="cstat-no" title="statement not covered" >if(typeof e=="object"&amp;&amp;e!==null)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >t</span></span>hrow new Error(`Expected object, got ${typeof e}`)}</span>function <span class="fstat-no" title="function not covered" >cc(</span>e,t){<span class="cstat-no" title="statement not covered" >return Array.isArray(e)?e.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >cc(r,t))</span>:typeof e=="object"&amp;&amp;e!==null?e[t]??null:e}</span>function <span class="fstat-no" title="function not covered" >jd(</span>e,t){<span class="cstat-no" title="statement not covered" >for(let{joinExpr:r,childRecords:n}of t){let i=<span class="cstat-no" title="statement not covered" >r.on.map(<span class="fstat-no" title="function not covered" >([</span>a])=&gt;<span class="cstat-no" title="statement not covered" >a)</span>,</span>o=<span class="cstat-no" title="statement not covered" >r.on.map(<span class="fstat-no" title="function not covered" >([</span>,a])=&gt;<span class="cstat-no" title="statement not covered" >a)</span>,</span>s=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let a of Array.isArray(e)?e:[e]){let f=<span class="cstat-no" title="statement not covered" >Gn(a),</span>w=<span class="cstat-no" title="statement not covered" >Ft(f,i);<span class="cstat-no" title="statement not covered" ></span>s[w]||(s[w]=[]),s[w].push(f),r.isRelationUnique?f[r.parentField]=null:f[r.parentField]=[]}<span class="cstat-no" title="statement not covered" ></span>f</span>or(let a of Array.isArray(n)?n:[n]){<span class="cstat-no" title="statement not covered" >if(a===null)<span class="cstat-no" title="statement not covered" >continue;l</span></span>et f=<span class="cstat-no" title="statement not covered" >Ft(Gn(a),o);<span class="cstat-no" title="statement not covered" ></span>for(let w of s[f]??[])<span class="cstat-no" title="statement not covered" >r.isRelationUnique?w[r.parentField]=a:w[r.parentField].push(a)}</span></span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>function <span class="fstat-no" title="function not covered" >Qd(</span>e,t,r,n){<span class="cstat-no" title="statement not covered" >switch(e.type){case"value":<span class="cstat-no" title="statement not covered" >return Te(e.value,r,n);c</span>ase"lastInsertId":<span class="cstat-no" title="statement not covered" >return t;d</span>efault:<span class="cstat-no" title="statement not covered" >$(e,`Unexpected field initializer type: ${e.type}`)}</span>}</span>function <span class="fstat-no" title="function not covered" >Hd(</span>e,t,r,n){<span class="cstat-no" title="statement not covered" >switch(e.type){case"set":<span class="cstat-no" title="statement not covered" >return Te(e.value,r,n);c</span>ase"add":<span class="cstat-no" title="statement not covered" >return Oe(t)+Oe(Te(e.value,r,n));c</span>ase"subtract":<span class="cstat-no" title="statement not covered" >return Oe(t)-Oe(Te(e.value,r,n));c</span>ase"multiply":<span class="cstat-no" title="statement not covered" >return Oe(t)*Oe(Te(e.value,r,n));c</span>ase"divide":{let i=<span class="cstat-no" title="statement not covered" >Oe(t),</span>o=<span class="cstat-no" title="statement not covered" >Oe(Te(e.value,r,n));<span class="cstat-no" title="statement not covered" ></span>return o===0?null:i/o}</span>default:<span class="cstat-no" title="statement not covered" >$(e,`Unexpected field operation type: ${e.type}`)}</span>}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();a</span>sync function <span class="fstat-no" title="function not covered" >Gd(</span>){<span class="cstat-no" title="statement not covered" >return globalThis.crypto??await Promise.resolve().then(<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >Xe(),xi)</span>)}</span>async function <span class="fstat-no" title="function not covered" >uc(</span>){<span class="cstat-no" title="statement not covered" >return(await Gd()).randomUUID()}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Ee=<span class="cstat-no" title="statement not covered" >class extends ce{name=<span class="cstat-no" title="statement not covered" >"TransactionManagerError";<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >super("Transaction API error: "+t,"P2028",r)}</span>},</span>Sr=<span class="cstat-no" title="statement not covered" >class extends Ee{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super("Transaction not found. Transaction ID is invalid, refers to an old closed transaction Prisma doesn't have information about anymore, or was obtained before disconnecting.")}</span>},</span>Jn=<span class="cstat-no" title="statement not covered" >class extends Ee{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(`Transaction already closed: A ${t} cannot be executed on a committed transaction.`)}</span>},</span>Wn=<span class="cstat-no" title="statement not covered" >class extends Ee{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(`Transaction already closed: A ${t} cannot be executed on a transaction that was rolled back.`)}</span>},</span>Kn=<span class="cstat-no" title="statement not covered" >class extends Ee{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super("Unable to start a transaction in the given time.")}</span>},</span>zn=<span class="cstat-no" title="statement not covered" >class extends Ee{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,{timeout:r,timeTaken:n}){<span class="cstat-no" title="statement not covered" >super(`A ${t} cannot be executed on an expired transaction. The timeout for this transaction was ${r} ms, however ${n} ms passed since the start of the transaction. Consider increasing the interactive transaction timeout or doing less work in the transaction.`,{operation:t,timeout:r,timeTaken:n})}</span>},</span>Vt=<span class="cstat-no" title="statement not covered" >class extends Ee{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(`Internal Consistency Error: ${t}`)}</span>},</span>Yn=<span class="cstat-no" title="statement not covered" >class extends Ee{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(`Invalid isolation level: ${t}`,{isolationLevel:t})}</span>};</span>var Jd=<span class="cstat-no" title="statement not covered" >100,</span>Ir=<span class="cstat-no" title="statement not covered" >K("prisma:client:transactionManager"),</span>Wd=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >{sql:"COMMIT",args:[],argTypes:[]})</span>,</span>Kd=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >{sql:"ROLLBACK",args:[],argTypes:[]})</span>,</span>zd=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >{sql:'-- Implicit "COMMIT" query via underlying driver',args:[],argTypes:[]})</span>,</span>Yd=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >{sql:'-- Implicit "ROLLBACK" query via underlying driver',args:[],argTypes:[]})</span>,</span>kr=<span class="cstat-no" title="statement not covered" >class{transactions=<span class="cstat-no" title="statement not covered" >new Map;</span>closedTransactions=<span class="cstat-no" title="statement not covered" >[];</span>driverAdapter;transactionOptions;tracingHelper;#t;#e;<span class="fstat-no" title="function not covered" >co</span>nstructor({driverAdapter:t,transactionOptions:r,tracingHelper:n,onQuery:i,provider:o}){<span class="cstat-no" title="statement not covered" >this.driverAdapter=t,this.transactionOptions=r,this.tracingHelper=n,this.#t=i,this.#e=o}<span class="fstat-no" title="function not covered" ></span>as</span>ync startTransaction(t){<span class="cstat-no" title="statement not covered" >return await this.tracingHelper.runInChildSpan("start_transaction",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.#r(t))</span>}</span>async#r(t){let r=<span class="cstat-no" title="statement not covered" >t!==void 0?this.#a(t):this.transactionOptions,</span>n=<span class="cstat-no" title="statement not covered" >{id:await uc(),status:"waiting",timer:void 0,timeout:r.timeout,startedAt:Date.now(),transaction:void 0};<span class="cstat-no" title="statement not covered" ></span>this.transactions.set(n.id,n);l</span>et i=<span class="cstat-no" title="statement not covered" >!1,</span>o=<span class="cstat-no" title="statement not covered" >setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >i=!0,</span>r.maxWait);<span class="cstat-no" title="statement not covered" ></span>switch(o.unref?.(),n.transaction=await this.driverAdapter.startTransaction(r.isolationLevel).catch(_t),clearTimeout(o),n.status){case"waiting":<span class="cstat-no" title="statement not covered" >if(i)<span class="cstat-no" title="statement not covered" >throw await this.#i(n,"timed_out"),new Kn;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.status="running",n.timer=this.#s(n.id,r.timeout),{id:n.id};c</span>ase"timed_out":case"running":case"committed":case"rolled_back":<span class="cstat-no" title="statement not covered" >throw new Vt(`Transaction in invalid state ${n.status} although it just finished startup.`);d</span>efault:<span class="cstat-no" title="statement not covered" >$(n.status,"Unknown transaction status.")}</span>}<span class="fstat-no" title="function not covered" ></span>as</span>ync commitTransaction(t){<span class="cstat-no" title="statement not covered" >return await this.tracingHelper.runInChildSpan("commit_transaction",<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{let r=<span class="cstat-no" title="statement not covered" >this.#n(t,"commit");<span class="cstat-no" title="statement not covered" ></span>await this.#i(r,"committed")}</span>)}<span class="fstat-no" title="function not covered" ></span>as</span>ync rollbackTransaction(t){<span class="cstat-no" title="statement not covered" >return await this.tracingHelper.runInChildSpan("rollback_transaction",<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{let r=<span class="cstat-no" title="statement not covered" >this.#n(t,"rollback");<span class="cstat-no" title="statement not covered" ></span>await this.#i(r,"rolled_back")}</span>)}<span class="fstat-no" title="function not covered" ></span>as</span>ync getTransaction(t,r){let n=<span class="cstat-no" title="statement not covered" >this.#n(t.id,r);<span class="cstat-no" title="statement not covered" ></span>if(n.status==="closing"&amp;&amp;(await n.closing,n=this.#n(t.id,r)),!n.transaction)<span class="cstat-no" title="statement not covered" >throw new Sr;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.transaction}</span>#n(t,r){let n=<span class="cstat-no" title="statement not covered" >this.transactions.get(t);<span class="cstat-no" title="statement not covered" ></span>if(!n){let i=<span class="cstat-no" title="statement not covered" >this.closedTransactions.find(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >o.id===t)</span>;<span class="cstat-no" title="statement not covered" ></span>if(i)<span class="cstat-no" title="statement not covered" >switch(Ir("Transaction already closed.",{transactionId:t,status:i.status}),i.status){case"closing":case"waiting":case"running":<span class="cstat-no" title="statement not covered" >throw new Vt("Active transaction found in closed transactions list.");c</span>ase"committed":<span class="cstat-no" title="statement not covered" >throw new Jn(r);c</span>ase"rolled_back":<span class="cstat-no" title="statement not covered" >throw new Wn(r);c</span>ase"timed_out":<span class="cstat-no" title="statement not covered" >throw new zn(r,{timeout:i.timeout,timeTaken:Date.now()-i.startedAt})}</span>e</span>lse <span class="cstat-no" title="statement not covered" >throw Ir("Transaction not found.",t),new Sr}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(["committed","rolled_back","timed_out"].includes(n.status))<span class="cstat-no" title="statement not covered" >throw new Vt("Closed transaction found in active transactions map.");<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>as</span>ync cancelAllTransactions(){<span class="cstat-no" title="statement not covered" >await Promise.allSettled([...this.transactions.values()].map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.#i(t,"rolled_back"))</span>)}</span>#s(t,r){let n=<span class="cstat-no" title="statement not covered" >Date.now(),</span>i=<span class="cstat-no" title="statement not covered" >setTimeout(<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{<span class="cstat-no" title="statement not covered" >Ir("Transaction timed out.",{transactionId:t,timeoutStartedAt:n,timeout:r});l</span>et o=<span class="cstat-no" title="statement not covered" >this.transactions.get(t);<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;["running","waiting"].includes(o.status)?await this.#i(o,"timed_out"):Ir("Transaction already committed or rolled back when timeout happened.",t)}</span>,r);<span class="cstat-no" title="statement not covered" ></span>return i.unref?.(),i}</span>async#i(t,r){let n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{<span class="cstat-no" title="statement not covered" >Ir("Closing transaction.",{transactionId:t.id,status:r});<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >if(t.transaction&amp;&amp;r==="committed")<span class="cstat-no" title="statement not covered" >if(t.transaction.options.usePhantomQuery)<span class="cstat-no" title="statement not covered" >await this.#o(zd(),t.transaction,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.transaction.commit())</span>;e</span>lse{let i=<span class="cstat-no" title="statement not covered" >Wd();<span class="cstat-no" title="statement not covered" ></span>await this.#o(i,t.transaction,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.transaction.executeRaw(i))</span>,await t.transaction.commit()}</span>e</span>lse <span class="cstat-no" title="statement not covered" >if(t.transaction)<span class="cstat-no" title="statement not covered" >if(t.transaction.options.usePhantomQuery)<span class="cstat-no" title="statement not covered" >await this.#o(Yd(),t.transaction,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.transaction.rollback())</span>;e</span>lse{let i=<span class="cstat-no" title="statement not covered" >Kd();<span class="cstat-no" title="statement not covered" ></span>await this.#o(i,t.transaction,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.transaction.executeRaw(i))</span>,await t.transaction.rollback()}</span>}</span></span></span>finally{<span class="cstat-no" title="statement not covered" >t.status=r,clearTimeout(t.timer),t.timer=void 0,this.transactions.delete(t.id),this.closedTransactions.push(t),this.closedTransactions.length&gt;Jd&amp;&amp;this.closedTransactions.shift()}</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>t.status==="closing"?(await t.closing,this.#n(t.id,r==="committed"?"commit":"rollback")):await Object.assign(t,{status:"closing",reason:r,closing:n()}).closing}</span>#a(t){<span class="cstat-no" title="statement not covered" >if(!t.timeout)<span class="cstat-no" title="statement not covered" >throw new Ee("timeout is required");<span class="cstat-no" title="statement not covered" >i</span></span>f(!t.maxWait)<span class="cstat-no" title="statement not covered" >throw new Ee("maxWait is required");<span class="cstat-no" title="statement not covered" >i</span></span>f(t.isolationLevel==="SNAPSHOT")<span class="cstat-no" title="statement not covered" >throw new Yn(t.isolationLevel);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{...t,timeout:t.timeout,maxWait:t.maxWait}}</span>#o(t,r,n){<span class="cstat-no" title="statement not covered" >return Ln({query:t,execute:n,provider:this.#e??r.provider,tracingHelper:this.tracingHelper,onQuery:this.#t})}</span>};</span>var Zn=<span class="cstat-no" title="statement not covered" >"6.17.1";<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Xn=<span class="cstat-no" title="statement not covered" >class e{#t;#e;#r;#n;<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r,n){<span class="cstat-no" title="statement not covered" >this.#t=t,this.#e=r,this.#r=n,this.#n=r.getConnectionInfo?.()}<span class="fstat-no" title="function not covered" ></span>st</span>atic async connect(t){let r,n;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >r=await t.driverAdapterFactory.connect(),n=new kr({driverAdapter:r,transactionOptions:t.transactionOptions,tracingHelper:t.tracingHelper,onQuery:t.onQuery,provider:t.provider})}</span>catch(i){<span class="cstat-no" title="statement not covered" >throw await r?.dispose(),i}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new e(t,r,n)}<span class="fstat-no" title="function not covered" ></span>ge</span>tConnectionInfo(){let t=<span class="cstat-no" title="statement not covered" >this.#n??{supportsRelationJoins:!1};<span class="cstat-no" title="statement not covered" ></span>return Promise.resolve({provider:this.#e.provider,connectionInfo:t})}<span class="fstat-no" title="function not covered" ></span>as</span>ync execute({plan:t,placeholderValues:r,transaction:n,batchIndex:i}){let o=<span class="cstat-no" title="statement not covered" >n?await this.#r.getTransaction(n,i!==void 0?"batch query":"query"):this.#e;<span class="cstat-no" title="statement not covered" ></span>return await Cr.forSql({transactionManager:n?{enabled:!1}:{enabled:!0,manager:this.#r},placeholderValues:r,onQuery:this.#t.onQuery,tracingHelper:this.#t.tracingHelper,provider:this.#t.provider,connectionInfo:this.#n}).run(t,o)}<span class="fstat-no" title="function not covered" ></span>as</span>ync startTransaction(t){<span class="cstat-no" title="statement not covered" >return{...await this.#r.startTransaction(t),payload:void 0}}<span class="fstat-no" title="function not covered" ></span>as</span>ync commitTransaction(t){<span class="cstat-no" title="statement not covered" >await this.#r.commitTransaction(t.id)}<span class="fstat-no" title="function not covered" ></span>as</span>ync rollbackTransaction(t){<span class="cstat-no" title="statement not covered" >await this.#r.rollbackTransaction(t.id)}<span class="fstat-no" title="function not covered" ></span>as</span>ync disconnect(){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >await this.#r.cancelAllTransactions()}</span>finally{<span class="cstat-no" title="statement not covered" >await this.#e.dispose()}</span>}<span class="fstat-no" title="function not covered" ></span>ap</span>iKey(){<span class="cstat-no" title="statement not covered" >return null}</span>};<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar ei=<span class="cstat-no" title="statement not covered" >/^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;</span>function <span class="fstat-no" title="function not covered" >pc(</span>e,t,r){let n=<span class="cstat-no" title="statement not covered" >r||{},</span>i=<span class="cstat-no" title="statement not covered" >n.encode||encodeURIComponent;<span class="cstat-no" title="statement not covered" ></span>if(typeof i!="function")<span class="cstat-no" title="statement not covered" >throw new TypeError("option encode is invalid");<span class="cstat-no" title="statement not covered" >i</span></span>f(!ei.test(e))<span class="cstat-no" title="statement not covered" >throw new TypeError("argument name is invalid");l</span></span>et o=<span class="cstat-no" title="statement not covered" >i(t);<span class="cstat-no" title="statement not covered" ></span>if(o&amp;&amp;!ei.test(o))<span class="cstat-no" title="statement not covered" >throw new TypeError("argument val is invalid");l</span></span>et s=<span class="cstat-no" title="statement not covered" >e+"="+o;<span class="cstat-no" title="statement not covered" ></span>if(n.maxAge!==void 0&amp;&amp;n.maxAge!==null){let a=<span class="cstat-no" title="statement not covered" >n.maxAge-0;<span class="cstat-no" title="statement not covered" ></span>if(Number.isNaN(a)||!Number.isFinite(a))<span class="cstat-no" title="statement not covered" >throw new TypeError("option maxAge is invalid");<span class="cstat-no" title="statement not covered" >s</span></span>+="; Max-Age="+Math.floor(a)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(n.domain){<span class="cstat-no" title="statement not covered" >if(!ei.test(n.domain))<span class="cstat-no" title="statement not covered" >throw new TypeError("option domain is invalid");<span class="cstat-no" title="statement not covered" >s</span></span>+="; Domain="+n.domain}<span class="cstat-no" title="statement not covered" ></span>i</span>f(n.path){<span class="cstat-no" title="statement not covered" >if(!ei.test(n.path))<span class="cstat-no" title="statement not covered" >throw new TypeError("option path is invalid");<span class="cstat-no" title="statement not covered" >s</span></span>+="; Path="+n.path}<span class="cstat-no" title="statement not covered" ></span>i</span>f(n.expires){<span class="cstat-no" title="statement not covered" >if(!Xd(n.expires)||Number.isNaN(n.expires.valueOf()))<span class="cstat-no" title="statement not covered" >throw new TypeError("option expires is invalid");<span class="cstat-no" title="statement not covered" >s</span></span>+="; Expires="+n.expires.toUTCString()}<span class="cstat-no" title="statement not covered" ></span>i</span>f(n.httpOnly&amp;&amp;(s+="; HttpOnly"),n.secure&amp;&amp;(s+="; Secure"),n.priority)<span class="cstat-no" title="statement not covered" >switch(typeof n.priority=="string"?n.priority.toLowerCase():n.priority){case"low":{<span class="cstat-no" title="statement not covered" >s+="; Priority=Low";<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"medium":{<span class="cstat-no" title="statement not covered" >s+="; Priority=Medium";<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"high":{<span class="cstat-no" title="statement not covered" >s+="; Priority=High";<span class="cstat-no" title="statement not covered" >b</span>reak}</span>default:<span class="cstat-no" title="statement not covered" >throw new TypeError("option priority is invalid")}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(n.sameSite)<span class="cstat-no" title="statement not covered" >switch(typeof n.sameSite=="string"?n.sameSite.toLowerCase():n.sameSite){case!0:{<span class="cstat-no" title="statement not covered" >s+="; SameSite=Strict";<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"lax":{<span class="cstat-no" title="statement not covered" >s+="; SameSite=Lax";<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"strict":{<span class="cstat-no" title="statement not covered" >s+="; SameSite=Strict";<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"none":{<span class="cstat-no" title="statement not covered" >s+="; SameSite=None";<span class="cstat-no" title="statement not covered" >b</span>reak}</span>default:<span class="cstat-no" title="statement not covered" >throw new TypeError("option sameSite is invalid")}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn n.partitioned&amp;&amp;(s+="; Partitioned"),s}</span>function <span class="fstat-no" title="function not covered" >Xd(</span>e){<span class="cstat-no" title="statement not covered" >return Object.prototype.toString.call(e)==="[object Date]"||e instanceof Date}</span>function <span class="fstat-no" title="function not covered" >mc(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >(e||"").split(";").filter(<span class="fstat-no" title="function not covered" >f=</span>&gt;<span class="cstat-no" title="statement not covered" >typeof f=="string"&amp;&amp;!!f.trim())</span>,</span>n=<span class="cstat-no" title="statement not covered" >r.shift()||"",</span>i=<span class="cstat-no" title="statement not covered" >ef(n),</span>o=<span class="cstat-no" title="statement not covered" >i.name,</span>s=<span class="cstat-no" title="statement not covered" >i.value;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >s=t?.decode===!1?s:(t?.decode||decodeURIComponent)(s)}</span>catch{}l</span>et a=<span class="cstat-no" title="statement not covered" >{name:o,value:s};<span class="cstat-no" title="statement not covered" ></span>for(let f of r){let w=<span class="cstat-no" title="statement not covered" >f.split("="),</span>A=<span class="cstat-no" title="statement not covered" >(w.shift()||"").trimStart().toLowerCase(),</span>R=<span class="cstat-no" title="statement not covered" >w.join("=");<span class="cstat-no" title="statement not covered" ></span>switch(A){case"expires":{<span class="cstat-no" title="statement not covered" >a.expires=new Date(R);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"max-age":{<span class="cstat-no" title="statement not covered" >a.maxAge=Number.parseInt(R,10);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"secure":{<span class="cstat-no" title="statement not covered" >a.secure=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"httponly":{<span class="cstat-no" title="statement not covered" >a.httpOnly=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"samesite":{<span class="cstat-no" title="statement not covered" >a.sameSite=R;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>default:<span class="cstat-no" title="statement not covered" >a[A]=R}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a}</span>function <span class="fstat-no" title="function not covered" >ef(</span>e){let t=<span class="cstat-no" title="statement not covered" >"",</span>r=<span class="cstat-no" title="statement not covered" >"",</span>n=<span class="cstat-no" title="statement not covered" >e.split("=");<span class="cstat-no" title="statement not covered" ></span>return n.length&gt;1?(t=n.shift(),r=n.join("=")):r=e,{name:t,value:r}}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar tf=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >globalThis.process?.release?.name==="node",</span></span>rf=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!!globalThis.Bun||!!globalThis.process?.versions?.bun,</span></span>nf=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!!globalThis.Deno,</span></span>of=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >typeof globalThis.Netlify=="object",</span></span>sf=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >typeof globalThis.EdgeRuntime=="object",</span></span>af=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >globalThis.navigator?.userAgent==="Cloudflare-Workers";</span></span>function <span class="fstat-no" title="function not covered" >lf(</span>){<span class="cstat-no" title="statement not covered" >return[[of,"netlify"],[sf,"edge-light"],[af,"workerd"],[nf,"deno"],[rf,"bun"],[tf,"node"]].flatMap(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r[0]()?[r[1]]:[])</span>.at(0)??""}</span>var cf=<span class="cstat-no" title="statement not covered" >{node:"Node.js",workerd:"Cloudflare Workers",deno:"Deno and Deno Deploy",netlify:"Netlify Edge Functions","edge-light":"Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)"};</span>function <span class="fstat-no" title="function not covered" >ti(</span>){let e=<span class="cstat-no" title="statement not covered" >lf();<span class="cstat-no" title="statement not covered" ></span>return{id:e,prettyName:cf[e]||e,isEdge:["workerd","deno","netlify","edge-light"].includes(e)}}</span>function <span class="fstat-no" title="function not covered" >qt(</span>{inlineDatasources:e,overrideDatasources:t,env:r,clientVersion:n}){let i,o=<span class="cstat-no" title="statement not covered" >Object.keys(e)[0],</span>s=<span class="cstat-no" title="statement not covered" >e[o]?.url,</span>a=<span class="cstat-no" title="statement not covered" >t[o]?.url;<span class="cstat-no" title="statement not covered" ></span>if(o===void 0?i=void 0:a?i=a:s?.value?i=s.value:s?.fromEnvVar&amp;&amp;(i=r[s.fromEnvVar]),s?.fromEnvVar!==void 0&amp;&amp;i===void 0)<span class="cstat-no" title="statement not covered" >throw ti().id==="workerd"?new F(`error: Environment variable not found: ${s.fromEnvVar}.</span></span>
&nbsp;
In Cloudflare module Workers, environment variables are available only in the Worker's \`env\` parameter of \`fetch\`.
To solve this, provide the connection string directly: https://pris.ly/d/cloudflare-datasource-url`,n):new F(`error: Environment variable not found: ${s.fromEnvVar}.`,n);<span class="cstat-no" title="statement not covered" >if(i===void 0)<span class="cstat-no" title="statement not covered" >throw new F("error: Missing URL environment variable, value, or override.",n);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar ri=<span class="cstat-no" title="statement not covered" >class extends Error{clientVersion;cause;<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >super(t),this.clientVersion=r.clientVersion,this.cause=r.cause}<span class="fstat-no" title="function not covered" ></span>ge</span>t[Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return this.name}</span>};</span>var ge=<span class="cstat-no" title="statement not covered" >class extends ri{isRetryable;<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >super(t,r),this.isRetryable=r.isRetryable??!0}</span>};<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >N(</span>e,t){<span class="cstat-no" title="statement not covered" >return{...e,isRetryable:t}}</span>var st=<span class="cstat-no" title="statement not covered" >class extends ge{name=<span class="cstat-no" title="statement not covered" >"InvalidDatasourceError";</span>code=<span class="cstat-no" title="statement not covered" >"P6001";<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >super(t,N(r,!1))}</span>};<span class="cstat-no" title="statement not covered" ></span>D(st,"InvalidDatasourceError");f</span>unction <span class="fstat-no" title="function not covered" >ni(</span>e){let t=<span class="cstat-no" title="statement not covered" >{clientVersion:e.clientVersion},</span>r=<span class="cstat-no" title="statement not covered" >Object.keys(e.inlineDatasources)[0],</span>n=<span class="cstat-no" title="statement not covered" >qt({inlineDatasources:e.inlineDatasources,overrideDatasources:e.overrideDatasources,clientVersion:e.clientVersion,env:{...e.env,...typeof g&lt;"u"?g.env:{}}}),</span>i;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >i=new URL(n)}</span>catch{<span class="cstat-no" title="statement not covered" >throw new st(`Error validating datasource \`${r}\`: the URL must start with the protocol \`prisma://\``,t)}</span>l</span>et{protocol:o,searchParams:s}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>if(o!=="prisma:"&amp;&amp;o!==ln)<span class="cstat-no" title="statement not covered" >throw new st(`Error validating datasource \`${r}\`: the URL must start with the protocol \`prisma://\` or \`prisma+postgres://\``,t);l</span></span>et a=<span class="cstat-no" title="statement not covered" >s.get("api_key");<span class="cstat-no" title="statement not covered" ></span>if(a===null||a.length&lt;1)<span class="cstat-no" title="statement not covered" >throw new st(`Error validating datasource \`${r}\`: the URL must contain a valid API key`,t);l</span></span>et f=<span class="cstat-no" title="statement not covered" >Ti(i)?"http:":"https:";<span class="cstat-no" title="statement not covered" ></span>g.env.TEST_CLIENT_ENGINE_REMOTE_EXECUTOR&amp;&amp;i.searchParams.has("use_http")&amp;&amp;(f="http:");l</span>et w=<span class="cstat-no" title="statement not covered" >new URL(i.href.replace(o,f));<span class="cstat-no" title="statement not covered" ></span>return{apiKey:a,url:w}}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar dc=<span class="cstat-no" title="statement not covered" >$e(Ts()),</span>Bt=<span class="cstat-no" title="statement not covered" >class{apiKey;tracingHelper;logLevel;logQueries;engineHash;<span class="fstat-no" title="function not covered" >co</span>nstructor({apiKey:t,tracingHelper:r,logLevel:n,logQueries:i,engineHash:o}){<span class="cstat-no" title="statement not covered" >this.apiKey=t,this.tracingHelper=r,this.logLevel=n,this.logQueries=i,this.engineHash=o}<span class="fstat-no" title="function not covered" ></span>bu</span>ild({traceparent:t,transactionId:r}=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let n=<span class="cstat-no" title="statement not covered" >{Accept:"application/json",Authorization:`Bearer ${this.apiKey}`,"Content-Type":"application/json","Prisma-Engine-Hash":this.engineHash,"Prisma-Engine-Version":dc.enginesVersion};<span class="cstat-no" title="statement not covered" ></span>this.tracingHelper.isEnabled()&amp;&amp;(n.traceparent=t??this.tracingHelper.getTraceParent()),r&amp;&amp;(n["X-Transaction-Id"]=r);l</span>et i=<span class="cstat-no" title="statement not covered" >this.#t();<span class="cstat-no" title="statement not covered" ></span>return i.length&gt;0&amp;&amp;(n["X-Capture-Telemetry"]=i.join(", ")),n}</span>#t(){let t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return this.tracingHelper.isEnabled()&amp;&amp;t.push("tracing"),this.logLevel&amp;&amp;t.push(this.logLevel),this.logQueries&amp;&amp;t.push("query"),t}</span>};<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >uf(</span>e){<span class="cstat-no" title="statement not covered" >return e[0]*1e3+e[1]/1e6}</span>function <span class="fstat-no" title="function not covered" >jt(</span>e){<span class="cstat-no" title="statement not covered" >return new Date(uf(e))}</span>var fc=<span class="cstat-no" title="statement not covered" >K("prisma:client:clientEngine:remoteExecutor"),</span>ii=<span class="cstat-no" title="statement not covered" >class{#t;#e;#r;#n;#s;<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.#t=t.clientVersion,this.#n=t.logEmitter,this.#s=t.tracingHelper;l</span>et{url:r,apiKey:n}=<span class="cstat-no" title="statement not covered" >ni({clientVersion:t.clientVersion,env:t.env,inlineDatasources:t.inlineDatasources,overrideDatasources:t.overrideDatasources});<span class="cstat-no" title="statement not covered" ></span>this.#r=new Ao(r),this.#e=new Bt({apiKey:n,engineHash:t.clientVersion,logLevel:t.logLevel,logQueries:t.logQueries,tracingHelper:t.tracingHelper})}<span class="fstat-no" title="function not covered" ></span>as</span>ync getConnectionInfo(){<span class="cstat-no" title="statement not covered" >return await this.#i({path:"/connection-info",method:"GET"})}<span class="fstat-no" title="function not covered" ></span>as</span>ync execute({plan:t,placeholderValues:r,batchIndex:n,model:i,operation:o,transaction:s,customFetch:a}){<span class="cstat-no" title="statement not covered" >return(await this.#i({path:s?`/transaction/${s.id}/query`:"/query",method:"POST",body:{model:i,operation:o,plan:t,params:r},batchRequestIdx:n,fetch:a})).data}<span class="fstat-no" title="function not covered" ></span>as</span>ync startTransaction(t){<span class="cstat-no" title="statement not covered" >return{...await this.#i({path:"/transaction/start",method:"POST",body:t}),payload:void 0}}<span class="fstat-no" title="function not covered" ></span>as</span>ync commitTransaction(t){<span class="cstat-no" title="statement not covered" >await this.#i({path:`/transaction/${t.id}/commit`,method:"POST"})}<span class="fstat-no" title="function not covered" ></span>as</span>ync rollbackTransaction(t){<span class="cstat-no" title="statement not covered" >await this.#i({path:`/transaction/${t.id}/rollback`,method:"POST"})}<span class="fstat-no" title="function not covered" ></span>di</span>sconnect(){<span class="cstat-no" title="statement not covered" >return Promise.resolve()}<span class="fstat-no" title="function not covered" ></span>ap</span>iKey(){<span class="cstat-no" title="statement not covered" >return this.#e.apiKey}</span>async#i({path:t,method:r,body:n,fetch:i=<span class="branch-0 cbranch-no" title="branch not covered" >globalThis.fetch,</span>batchRequestIdx:o}){let s=<span class="cstat-no" title="statement not covered" >await this.#r.request({method:r,path:t,headers:this.#e.build(),body:n,fetch:i});<span class="cstat-no" title="statement not covered" ></span>s.ok||await this.#a(s,o);l</span>et a=<span class="cstat-no" title="statement not covered" >await s.json();<span class="cstat-no" title="statement not covered" ></span>return typeof a.extensions=="object"&amp;&amp;a.extensions!==null&amp;&amp;this.#o(a.extensions),a}</span>async#a(t,r){let n=<span class="cstat-no" title="statement not covered" >t.headers.get("Prisma-Error-Code"),</span>i=<span class="cstat-no" title="statement not covered" >await t.text(),</span>o,s=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >o=JSON.parse(i)}</span>catch{<span class="cstat-no" title="statement not covered" >o={}}<span class="cstat-no" title="statement not covered" ></span>t</span>ypeof o.code=="string"&amp;&amp;(n=o.code),typeof o.error=="string"?s=o.error:typeof o.message=="string"?s=o.message:typeof o.InvalidRequestError=="object"&amp;&amp;o.InvalidRequestError!==null&amp;&amp;typeof o.InvalidRequestError.reason=="string"&amp;&amp;(s=o.InvalidRequestError.reason),s=s||`HTTP ${t.status}: ${t.statusText}`;l</span>et a=<span class="cstat-no" title="statement not covered" >typeof o.meta=="object"&amp;&amp;o.meta!==null?o.meta:o;<span class="cstat-no" title="statement not covered" ></span>throw new X(s,{clientVersion:this.#t,code:n??"P6000",batchRequestIdx:r,meta:a})}</span>#o(t){<span class="cstat-no" title="statement not covered" >if(t.logs)<span class="cstat-no" title="statement not covered" >for(let r of t.logs)<span class="cstat-no" title="statement not covered" >this.#c(r);<span class="cstat-no" title="statement not covered" >t</span></span></span>.traces&amp;&amp;this.#s.dispatchEngineSpans(t.traces)}</span>#c(t){<span class="cstat-no" title="statement not covered" >switch(t.level){case"debug":case"trace":<span class="cstat-no" title="statement not covered" >fc(t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"error":case"warn":case"info":{<span class="cstat-no" title="statement not covered" >this.#n.emit(t.level,{timestamp:jt(t.timestamp),message:t.attributes.message??"",target:t.target??"RemoteExecutor"});<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"query":{<span class="cstat-no" title="statement not covered" >this.#n.emit("query",{query:t.attributes.query??"",timestamp:jt(t.timestamp),duration:t.attributes.duration_ms??0,params:t.attributes.params??"",target:t.target??"RemoteExecutor"});<span class="cstat-no" title="statement not covered" >b</span>reak}</span>default:<span class="cstat-no" title="statement not covered" >throw new Error(`Unexpected log level: ${t.level}`)}</span>}</span>},</span>Ao=<span class="cstat-no" title="statement not covered" >class{#t;#e;#r;<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.#t=t,this.#e=new Map}<span class="fstat-no" title="function not covered" ></span>as</span>ync request({method:t,path:r,headers:n,body:i,fetch:o}){let s=<span class="cstat-no" title="statement not covered" >new URL(r,this.#t),</span>a=<span class="cstat-no" title="statement not covered" >this.#n(s);<span class="cstat-no" title="statement not covered" ></span>a&amp;&amp;(n.Cookie=a),this.#r&amp;&amp;(n["Accelerate-Query-Engine-Jwt"]=this.#r);l</span>et f=<span class="cstat-no" title="statement not covered" >await o(s.href,{method:t,body:i!==void 0?JSON.stringify(i):void 0,headers:n});<span class="cstat-no" title="statement not covered" ></span>return fc(t,s,f.status,f.statusText),this.#r=f.headers.get("Accelerate-Query-Engine-Jwt")??void 0,this.#s(s,f),f}</span>#n(t){let r=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >new Date;<span class="cstat-no" title="statement not covered" ></span>for(let[i,o]of this.#e){<span class="cstat-no" title="statement not covered" >if(o.expires&amp;&amp;o.expires&lt;n){<span class="cstat-no" title="statement not covered" >this.#e.delete(i);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et s=<span class="cstat-no" title="statement not covered" >o.domain??t.hostname,</span>a=<span class="cstat-no" title="statement not covered" >o.path??"/";<span class="cstat-no" title="statement not covered" ></span>t.hostname.endsWith(s)&amp;&amp;t.pathname.startsWith(a)&amp;&amp;r.push(pc(o.name,o.value))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r.length&gt;0?r.join("; "):void 0}</span>#s(t,r){let n=<span class="cstat-no" title="statement not covered" >r.headers.getSetCookie?.()||[];<span class="cstat-no" title="statement not covered" ></span>if(n.length===0){let i=<span class="cstat-no" title="statement not covered" >r.headers.get("Set-Cookie");<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;n.push(i)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(let i of n){let o=<span class="cstat-no" title="statement not covered" >mc(i),</span>s=<span class="cstat-no" title="statement not covered" >o.domain??t.hostname,</span>a=<span class="cstat-no" title="statement not covered" >o.path??"/",</span>f=<span class="cstat-no" title="statement not covered" >`${s}:${a}:${o.name}`;<span class="cstat-no" title="statement not covered" ></span>this.#e.set(f,{name:o.name,value:o.value,domain:s,path:a,expires:o.expires})}</span>}</span>};<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Ro,gc=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >as</span>ync loadQueryCompiler(e){let{clientVersion:t,compilerWasm:r}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>if(r===void 0)<span class="cstat-no" title="statement not covered" >throw new F("WASM query compiler was unexpectedly `undefined`",t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn Ro===void 0&amp;&amp;(Ro=(<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{let n=<span class="cstat-no" title="statement not covered" >await r.getRuntime(),</span>i=<span class="cstat-no" title="statement not covered" >await r.getQueryCompilerWasmModule();<span class="cstat-no" title="statement not covered" ></span>if(i==null)<span class="cstat-no" title="statement not covered" >throw new F("The loaded wasm module was unexpectedly `undefined` or `null` once loaded",t);l</span></span>et o=<span class="cstat-no" title="statement not covered" >{"./query_compiler_bg.js":n},</span>s=<span class="cstat-no" title="statement not covered" >new WebAssembly.Instance(i,o),</span>a=<span class="cstat-no" title="statement not covered" >s.exports.__wbindgen_start;<span class="cstat-no" title="statement not covered" ></span>return n.__wbg_set_wasm(s.exports),a(),n.QueryCompiler}</span>)()),await Ro}</span>};</span>var pf=<span class="cstat-no" title="statement not covered" >"P2038",</span>Or=<span class="cstat-no" title="statement not covered" >K("prisma:client:clientEngine"),</span>hc=<span class="cstat-no" title="statement not covered" >globalThis;<span class="cstat-no" title="statement not covered" ></span>hc.PRISMA_WASM_PANIC_REGISTRY={<span class="fstat-no" title="function not covered" >se</span>t_message(e){<span class="cstat-no" title="statement not covered" >throw new ae(e,Zn)}</span>};v</span>ar Dr=<span class="cstat-no" title="statement not covered" >class{name=<span class="cstat-no" title="statement not covered" >"ClientEngine";</span>#t;#e=<span class="cstat-no" title="statement not covered" >{type:"disconnected"};</span>#r;#n;config;datamodel;logEmitter;logQueries;logLevel;tracingHelper;#s;<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r,n){<span class="cstat-no" title="statement not covered" >if(r)<span class="cstat-no" title="statement not covered" >this.#n={remote:!0};e</span>lse <span class="cstat-no" title="statement not covered" >if(t.adapter)<span class="cstat-no" title="statement not covered" >this.#n={remote:!1,driverAdapterFactory:t.adapter},Or("Using driver adapter: %O",t.adapter);e</span>lse <span class="cstat-no" title="statement not covered" >throw new F("Missing configured driver adapter. Engine type `client` requires an active driver adapter. Please check your PrismaClient initialization code.",t.clientVersion,pf);<span class="cstat-no" title="statement not covered" >t</span></span></span>his.#r=n??gc,this.config=t,this.logQueries=t.logQueries??!1,this.logLevel=t.logLevel??"error",this.logEmitter=t.logEmitter,this.datamodel=t.inlineSchema,this.tracingHelper=t.tracingHelper,t.enableDebugLogs&amp;&amp;(this.logLevel="debug"),this.logQueries&amp;&amp;(this.#s=<span class="fstat-no" title="function not covered" >i=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.logEmitter.emit("query",{...i,params:br(i.params),target:"ClientEngine"})}</span>)}<span class="fstat-no" title="function not covered" ></span>ap</span>plyPendingMigrations(){<span class="cstat-no" title="statement not covered" >throw new Error("Cannot call applyPendingMigrations on engine type client.")}</span>async#i(){<span class="cstat-no" title="statement not covered" >switch(this.#e.type){case"disconnected":{let t=<span class="cstat-no" title="statement not covered" >this.tracingHelper.runInChildSpan("connect",<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{let r,n;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >r=await this.#a(),n=await this.#o(r)}</span>catch(o){<span class="cstat-no" title="statement not covered" >throw this.#e={type:"disconnected"},n?.free(),await r?.disconnect(),o}</span>l</span>et i=<span class="cstat-no" title="statement not covered" >{executor:r,queryCompiler:n};<span class="cstat-no" title="statement not covered" ></span>return this.#e={type:"connected",engine:i},i}</span>);<span class="cstat-no" title="statement not covered" ></span>return this.#e={type:"connecting",promise:t},await t}</span>case"connecting":<span class="cstat-no" title="statement not covered" >return await this.#e.promise;c</span>ase"connected":<span class="cstat-no" title="statement not covered" >return this.#e.engine;c</span>ase"disconnecting":<span class="cstat-no" title="statement not covered" >return await this.#e.promise,await this.#i()}</span>}</span>async#a(){<span class="cstat-no" title="statement not covered" >return this.#n.remote?new ii({clientVersion:this.config.clientVersion,env:this.config.env,inlineDatasources:this.config.inlineDatasources,logEmitter:this.logEmitter,logLevel:this.logLevel,logQueries:this.logQueries,overrideDatasources:this.config.overrideDatasources,tracingHelper:this.tracingHelper}):await Xn.connect({driverAdapterFactory:this.#n.driverAdapterFactory,tracingHelper:this.tracingHelper,transactionOptions:{...this.config.transactionOptions,isolationLevel:this.#m(this.config.transactionOptions.isolationLevel)},onQuery:this.#s,provider:this.config.activeProvider})}</span>async#o(t){let r=<span class="cstat-no" title="statement not covered" >this.#t;<span class="cstat-no" title="statement not covered" ></span>r===void 0&amp;&amp;(r=await this.#r.loadQueryCompiler(this.config),this.#t=r);l</span>et{provider:n,connectionInfo:i}=<span class="cstat-no" title="statement not covered" >await t.getConnectionInfo();<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >return this.#u(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >new r({datamodel:this.datamodel,provider:n,connectionInfo:i}),</span>void 0,!1)}</span>catch(o){<span class="cstat-no" title="statement not covered" >throw this.#c(o)}</span>}</span>#c(t){<span class="cstat-no" title="statement not covered" >if(t instanceof ae)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >t</span></span>ry{let r=<span class="cstat-no" title="statement not covered" >JSON.parse(t.message);<span class="cstat-no" title="statement not covered" ></span>return new F(r.message,this.config.clientVersion,r.error_code)}</span>catch{<span class="cstat-no" title="statement not covered" >return t}</span>}</span>#l(t,r){<span class="cstat-no" title="statement not covered" >if(t instanceof F)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >i</span></span>f(t.code==="GenericFailure"&amp;&amp;t.message?.startsWith("PANIC:"))<span class="cstat-no" title="statement not covered" >return new ae(yc(this,t.message,r),this.config.clientVersion);<span class="cstat-no" title="statement not covered" >i</span></span>f(t instanceof ce)<span class="cstat-no" title="statement not covered" >return new X(t.message,{code:t.code,meta:t.meta,clientVersion:this.config.clientVersion});<span class="cstat-no" title="statement not covered" >t</span></span>ry{let n=<span class="cstat-no" title="statement not covered" >JSON.parse(t);<span class="cstat-no" title="statement not covered" ></span>return new ne(`${n.message}</span></span></span>
${n.backtrace}`,{clientVersion:this.config.clientVersion})}catch{<span class="cstat-no" title="statement not covered" >return t}</span>}#p(t){<span class="cstat-no" title="statement not covered" >return t instanceof ae?t:typeof t.message=="string"&amp;&amp;typeof t.code=="string"?new X(t.message,{code:t.code,meta:t.meta,clientVersion:this.config.clientVersion}):typeof t.message=="string"?new ne(t.message,{clientVersion:this.config.clientVersion}):t}</span>#u(t,r,n=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{let i=<span class="cstat-no" title="statement not covered" >hc.PRISMA_WASM_PANIC_REGISTRY.set_message,</span>o;<span class="cstat-no" title="statement not covered" >globalThis.PRISMA_WASM_PANIC_REGISTRY.set_message=<span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >o=s}</span>;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >return t()}</span>finally{<span class="cstat-no" title="statement not covered" >if(globalThis.PRISMA_WASM_PANIC_REGISTRY.set_message=i,o)<span class="cstat-no" title="statement not covered" >throw this.#t=void 0,n&amp;&amp;this.stop().catch(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >Or("failed to disconnect:",s))</span>,new ae(yc(this,o,r),this.config.clientVersion)}</span></span>}<span class="fstat-no" title="function not covered" ></span>on</span>BeforeExit(){<span class="cstat-no" title="statement not covered" >throw new Error('"beforeExit" hook is not applicable to the client engine, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.')}<span class="fstat-no" title="function not covered" ></span>as</span>ync start(){<span class="cstat-no" title="statement not covered" >await this.#i()}<span class="fstat-no" title="function not covered" ></span>as</span>ync stop(){<span class="cstat-no" title="statement not covered" >switch(this.#e.type){case"disconnected":<span class="cstat-no" title="statement not covered" >return;c</span>ase"connecting":<span class="cstat-no" title="statement not covered" >return await this.#e.promise,await this.stop();c</span>ase"connected":{let t=<span class="cstat-no" title="statement not covered" >this.#e.engine,</span>r=<span class="cstat-no" title="statement not covered" >this.tracingHelper.runInChildSpan("disconnect",<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >await t.executor.disconnect(),t.queryCompiler.free()}</span>finally{<span class="cstat-no" title="statement not covered" >this.#e={type:"disconnected"}}</span>}</span>);<span class="cstat-no" title="statement not covered" ></span>return this.#e={type:"disconnecting",promise:r},await r}</span>case"disconnecting":<span class="cstat-no" title="statement not covered" >return await this.#e.promise}</span>}<span class="fstat-no" title="function not covered" ></span>ve</span>rsion(){<span class="cstat-no" title="statement not covered" >return"unknown"}<span class="fstat-no" title="function not covered" ></span>as</span>ync transaction(t,r,n){let i,{executor:o}=<span class="cstat-no" title="statement not covered" >await this.#i();<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >if(t==="start"){let s=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>i=await o.startTransaction({...s,isolationLevel:this.#m(s.isolationLevel)})}</span>else <span class="cstat-no" title="statement not covered" >if(t==="commit"){let s=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>await o.commitTransaction(s)}</span>else <span class="cstat-no" title="statement not covered" >if(t==="rollback"){let s=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>await o.rollbackTransaction(s)}</span>else <span class="cstat-no" title="statement not covered" >Me(t,"Invalid transaction action.")}</span></span></span></span>catch(s){<span class="cstat-no" title="statement not covered" >throw this.#l(s)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i?{id:i.id,payload:void 0}:void 0}<span class="fstat-no" title="function not covered" ></span>as</span>ync request(t,{interactiveTransaction:r,customDataProxyFetch:n}){<span class="cstat-no" title="statement not covered" >Or("sending request");l</span>et i=<span class="cstat-no" title="statement not covered" >JSON.stringify(t),</span>{executor:o,queryCompiler:s}=<span class="cstat-no" title="statement not covered" >await this.#i().catch(<span class="fstat-no" title="function not covered" >f=</span>&gt;{<span class="cstat-no" title="statement not covered" >throw this.#l(f,i)}</span>),</span>a;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >a=this.#u(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.#d({queries:[t],execute:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >s.compile(i)}</span>))</span>}</span>catch(f){<span class="cstat-no" title="statement not covered" >throw this.#p(f)}<span class="cstat-no" title="statement not covered" ></span>t</span>ry{<span class="cstat-no" title="statement not covered" >Or("query plan created",a);l</span>et f=<span class="cstat-no" title="statement not covered" >{},</span>w=<span class="cstat-no" title="statement not covered" >await o.execute({plan:a,model:t.modelName,operation:t.action,placeholderValues:f,transaction:r,batchIndex:void 0,customFetch:n?.(globalThis.fetch)});<span class="cstat-no" title="statement not covered" ></span>return Or("query plan executed"),{data:{[t.action]:w}}}</span>catch(f){<span class="cstat-no" title="statement not covered" >throw this.#l(f,i)}</span>}<span class="fstat-no" title="function not covered" ></span>as</span>ync requestBatch(t,{transaction:r,customDataProxyFetch:n}){<span class="cstat-no" title="statement not covered" >if(t.length===0)<span class="cstat-no" title="statement not covered" >return[];l</span></span>et i=<span class="cstat-no" title="statement not covered" >t[0].action,</span>o=<span class="cstat-no" title="statement not covered" >JSON.stringify(kt(t,r)),</span>{executor:s,queryCompiler:a}=<span class="cstat-no" title="statement not covered" >await this.#i().catch(<span class="fstat-no" title="function not covered" >w=</span>&gt;{<span class="cstat-no" title="statement not covered" >throw this.#l(w,o)}</span>),</span>f;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >f=this.#u(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.#d({queries:t,execute:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >a.compileBatch(o)}</span>))</span>}</span>catch(w){<span class="cstat-no" title="statement not covered" >throw this.#p(w)}<span class="cstat-no" title="statement not covered" ></span>t</span>ry{let w;<span class="cstat-no" title="statement not covered" >r?.kind==="itx"&amp;&amp;(w=r.options);l</span>et A=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>switch(f.type){case"multi":{<span class="cstat-no" title="statement not covered" >if(r?.kind!=="itx"){let C=<span class="cstat-no" title="statement not covered" >r?.options.isolationLevel?{...this.config.transactionOptions,isolationLevel:r.options.isolationLevel}:this.config.transactionOptions;<span class="cstat-no" title="statement not covered" ></span>w=await this.transaction("start",{},C)}</span>l</span>et R=<span class="cstat-no" title="statement not covered" >[],</span>S=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(let[C,L]of f.plans.entries())<span class="cstat-no" title="statement not covered" >try{let k=<span class="cstat-no" title="statement not covered" >await s.execute({plan:L,placeholderValues:A,model:t[C].modelName,operation:t[C].action,batchIndex:C,transaction:w,customFetch:n?.(globalThis.fetch)});<span class="cstat-no" title="statement not covered" ></span>R.push({data:{[t[C].action]:k}})}</span>catch(k){<span class="cstat-no" title="statement not covered" >R.push(k),S=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn w!==void 0&amp;&amp;r?.kind!=="itx"&amp;&amp;(S?await this.transaction("rollback",{},w):await this.transaction("commit",{},w)),R}</span>case"compacted":{<span class="cstat-no" title="statement not covered" >if(!t.every(<span class="fstat-no" title="function not covered" >C=</span>&gt;<span class="cstat-no" title="statement not covered" >C.action===i)</span>)<span class="cstat-no" title="statement not covered" >throw new Error("All queries in a batch must have the same action");l</span></span>et R=<span class="cstat-no" title="statement not covered" >await s.execute({plan:f.plan,placeholderValues:A,model:t[0].modelName,operation:i,batchIndex:void 0,transaction:w,customFetch:n?.(globalThis.fetch)});<span class="cstat-no" title="statement not covered" ></span>return Za(R,f).map(<span class="fstat-no" title="function not covered" >C=</span>&gt;(<span class="cstat-no" title="statement not covered" >{data:{[i]:C}})</span>)}</span>}}</span>catch(w){<span class="cstat-no" title="statement not covered" >throw this.#l(w,o)}</span>}<span class="fstat-no" title="function not covered" ></span>me</span>trics(t){<span class="cstat-no" title="statement not covered" >throw new Error("Method not implemented.")}<span class="fstat-no" title="function not covered" ></span>as</span>ync apiKey(){let{executor:t}=<span class="cstat-no" title="statement not covered" >await this.#i();<span class="cstat-no" title="statement not covered" ></span>return t.apiKey()}</span>#m(t){<span class="cstat-no" title="statement not covered" >switch(t){case void 0:<span class="cstat-no" title="statement not covered" >return;c</span>ase"ReadUncommitted":<span class="cstat-no" title="statement not covered" >return"READ UNCOMMITTED";c</span>ase"ReadCommitted":<span class="cstat-no" title="statement not covered" >return"READ COMMITTED";c</span>ase"RepeatableRead":<span class="cstat-no" title="statement not covered" >return"REPEATABLE READ";c</span>ase"Serializable":<span class="cstat-no" title="statement not covered" >return"SERIALIZABLE";c</span>ase"Snapshot":<span class="cstat-no" title="statement not covered" >return"SNAPSHOT";d</span>efault:<span class="cstat-no" title="statement not covered" >throw new X(`Inconsistent column data: Conversion failed: Invalid isolation level \`${t}\``,{code:"P2023",clientVersion:this.config.clientVersion,meta:{providedIsolationLevel:t}})}</span>}</span>#d({queries:t,execute:r}){<span class="cstat-no" title="statement not covered" >return this.tracingHelper.runInChildSpan({name:"compile",attributes:{models:t.map(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >n.modelName)</span>.filter(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >n!==void 0)</span>,actions:t.map(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >n.action)</span>}},r)}</span>};function <span class="fstat-no" title="function not covered" >yc(</span>e,t,r){<span class="cstat-no" title="statement not covered" >return Ha({binaryTarget:void 0,title:t,version:e.config.clientVersion,engineVersion:"unknown",database:e.config.activeProvider,query:r})}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Qt=<span class="cstat-no" title="statement not covered" >class extends ge{name=<span class="cstat-no" title="statement not covered" >"ForcedRetryError";</span>code=<span class="cstat-no" title="statement not covered" >"P5001";<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super("This request must be retried",N(t,!0))}</span>};<span class="cstat-no" title="statement not covered" ></span>D(Qt,"ForcedRetryError");<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar at=<span class="cstat-no" title="statement not covered" >class extends ge{name=<span class="cstat-no" title="statement not covered" >"NotImplementedYetError";</span>code=<span class="cstat-no" title="statement not covered" >"P5004";<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >super(t,N(r,!1))}</span>};<span class="cstat-no" title="statement not covered" ></span>D(at,"NotImplementedYetError");<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Q=<span class="cstat-no" title="statement not covered" >class extends ge{response;<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >super(t,r),this.response=r.response;l</span>et n=<span class="cstat-no" title="statement not covered" >this.response.headers.get("prisma-request-id");<span class="cstat-no" title="statement not covered" ></span>if(n){let i=<span class="cstat-no" title="statement not covered" >`(The request id was: ${n})`;<span class="cstat-no" title="statement not covered" ></span>this.message=this.message+" "+i}</span>}</span>};</span>var lt=<span class="cstat-no" title="statement not covered" >class extends Q{name=<span class="cstat-no" title="statement not covered" >"SchemaMissingError";</span>code=<span class="cstat-no" title="statement not covered" >"P5005";<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super("Schema needs to be uploaded",N(t,!0))}</span>};<span class="cstat-no" title="statement not covered" ></span>D(lt,"SchemaMissingError");<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Co=<span class="cstat-no" title="statement not covered" >"This request could not be understood by the server",</span>_r=<span class="cstat-no" title="statement not covered" >class extends Q{name=<span class="cstat-no" title="statement not covered" >"BadRequestError";</span>code=<span class="cstat-no" title="statement not covered" >"P5000";<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,r,n){<span class="cstat-no" title="statement not covered" >super(r||Co,N(t,!1)),n&amp;&amp;(this.code=n)}</span>};<span class="cstat-no" title="statement not covered" ></span>D(_r,"BadRequestError");<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Mr=<span class="cstat-no" title="statement not covered" >class extends Q{name=<span class="cstat-no" title="statement not covered" >"HealthcheckTimeoutError";</span>code=<span class="cstat-no" title="statement not covered" >"P5013";</span>logs;<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >super("Engine not started: healthcheck timeout",N(t,!0)),this.logs=r}</span>};<span class="cstat-no" title="statement not covered" ></span>D(Mr,"HealthcheckTimeoutError");<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Nr=<span class="cstat-no" title="statement not covered" >class extends Q{name=<span class="cstat-no" title="statement not covered" >"EngineStartupError";</span>code=<span class="cstat-no" title="statement not covered" >"P5014";</span>logs;<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r,n){<span class="cstat-no" title="statement not covered" >super(r,N(t,!0)),this.logs=n}</span>};<span class="cstat-no" title="statement not covered" ></span>D(Nr,"EngineStartupError");<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Lr=<span class="cstat-no" title="statement not covered" >class extends Q{name=<span class="cstat-no" title="statement not covered" >"EngineVersionNotSupportedError";</span>code=<span class="cstat-no" title="statement not covered" >"P5012";<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super("Engine version is not supported",N(t,!1))}</span>};<span class="cstat-no" title="statement not covered" ></span>D(Lr,"EngineVersionNotSupportedError");<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar So=<span class="cstat-no" title="statement not covered" >"Request timed out",</span>Ur=<span class="cstat-no" title="statement not covered" >class extends Q{name=<span class="cstat-no" title="statement not covered" >"GatewayTimeoutError";</span>code=<span class="cstat-no" title="statement not covered" >"P5009";<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,r=<span class="branch-0 cbranch-no" title="branch not covered" >So)</span>{<span class="cstat-no" title="statement not covered" >super(r,N(t,!1))}</span>};<span class="cstat-no" title="statement not covered" ></span>D(Ur,"GatewayTimeoutError");<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar mf=<span class="cstat-no" title="statement not covered" >"Interactive transaction error",</span>Fr=<span class="cstat-no" title="statement not covered" >class extends Q{name=<span class="cstat-no" title="statement not covered" >"InteractiveTransactionError";</span>code=<span class="cstat-no" title="statement not covered" >"P5015";<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,r=<span class="branch-0 cbranch-no" title="branch not covered" >mf)</span>{<span class="cstat-no" title="statement not covered" >super(r,N(t,!1))}</span>};<span class="cstat-no" title="statement not covered" ></span>D(Fr,"InteractiveTransactionError");<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar df=<span class="cstat-no" title="statement not covered" >"Request parameters are invalid",</span>$r=<span class="cstat-no" title="statement not covered" >class extends Q{name=<span class="cstat-no" title="statement not covered" >"InvalidRequestError";</span>code=<span class="cstat-no" title="statement not covered" >"P5011";<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,r=<span class="branch-0 cbranch-no" title="branch not covered" >df)</span>{<span class="cstat-no" title="statement not covered" >super(r,N(t,!1))}</span>};<span class="cstat-no" title="statement not covered" ></span>D($r,"InvalidRequestError");<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Io=<span class="cstat-no" title="statement not covered" >"Requested resource does not exist",</span>Vr=<span class="cstat-no" title="statement not covered" >class extends Q{name=<span class="cstat-no" title="statement not covered" >"NotFoundError";</span>code=<span class="cstat-no" title="statement not covered" >"P5003";<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,r=<span class="branch-0 cbranch-no" title="branch not covered" >Io)</span>{<span class="cstat-no" title="statement not covered" >super(r,N(t,!1))}</span>};<span class="cstat-no" title="statement not covered" ></span>D(Vr,"NotFoundError");<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar ko=<span class="cstat-no" title="statement not covered" >"Unknown server error",</span>Ht=<span class="cstat-no" title="statement not covered" >class extends Q{name=<span class="cstat-no" title="statement not covered" >"ServerError";</span>code=<span class="cstat-no" title="statement not covered" >"P5006";</span>logs;<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r,n){<span class="cstat-no" title="statement not covered" >super(r||ko,N(t,!0)),this.logs=n}</span>};<span class="cstat-no" title="statement not covered" ></span>D(Ht,"ServerError");<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Oo=<span class="cstat-no" title="statement not covered" >"Unauthorized, check your connection string",</span>qr=<span class="cstat-no" title="statement not covered" >class extends Q{name=<span class="cstat-no" title="statement not covered" >"UnauthorizedError";</span>code=<span class="cstat-no" title="statement not covered" >"P5007";<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,r=<span class="branch-0 cbranch-no" title="branch not covered" >Oo)</span>{<span class="cstat-no" title="statement not covered" >super(r,N(t,!1))}</span>};<span class="cstat-no" title="statement not covered" ></span>D(qr,"UnauthorizedError");<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Do=<span class="cstat-no" title="statement not covered" >"Usage exceeded, retry again later",</span>Br=<span class="cstat-no" title="statement not covered" >class extends Q{name=<span class="cstat-no" title="statement not covered" >"UsageExceededError";</span>code=<span class="cstat-no" title="statement not covered" >"P5008";<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,r=<span class="branch-0 cbranch-no" title="branch not covered" >Do)</span>{<span class="cstat-no" title="statement not covered" >super(r,N(t,!0))}</span>};<span class="cstat-no" title="statement not covered" ></span>D(Br,"UsageExceededError");a</span>sync function <span class="fstat-no" title="function not covered" >ff(</span>e){let t;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >t=await e.text()}</span>catch{<span class="cstat-no" title="statement not covered" >return{type:"EmptyError"}}<span class="cstat-no" title="statement not covered" ></span>t</span>ry{let r=<span class="cstat-no" title="statement not covered" >JSON.parse(t);<span class="cstat-no" title="statement not covered" ></span>if(typeof r=="string")<span class="cstat-no" title="statement not covered" >switch(r){case"InternalDataProxyError":<span class="cstat-no" title="statement not covered" >return{type:"DataProxyError",body:r};d</span>efault:<span class="cstat-no" title="statement not covered" >return{type:"UnknownTextError",body:r}}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(typeof r=="object"&amp;&amp;r!==null){<span class="cstat-no" title="statement not covered" >if("is_panic"in r&amp;&amp;"message"in r&amp;&amp;"error_code"in r)<span class="cstat-no" title="statement not covered" >return{type:"QueryEngineError",body:r};<span class="cstat-no" title="statement not covered" >i</span></span>f("EngineNotStarted"in r||"InteractiveTransactionMisrouted"in r||"InvalidRequestError"in r){let n=<span class="cstat-no" title="statement not covered" >Object.values(r)[0].reason;<span class="cstat-no" title="statement not covered" ></span>return typeof n=="string"&amp;&amp;!["SchemaMissing","EngineVersionNotSupported"].includes(n)?{type:"UnknownJsonError",body:r}:{type:"DataProxyError",body:r}}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{type:"UnknownJsonError",body:r}}</span>catch{<span class="cstat-no" title="statement not covered" >return t===""?{type:"EmptyError"}:{type:"UnknownTextError",body:t}}</span>}</span>async function <span class="fstat-no" title="function not covered" >jr(</span>e,t){<span class="cstat-no" title="statement not covered" >if(e.ok)<span class="cstat-no" title="statement not covered" >return;l</span></span>et r=<span class="cstat-no" title="statement not covered" >{clientVersion:t,response:e},</span>n=<span class="cstat-no" title="statement not covered" >await ff(e);<span class="cstat-no" title="statement not covered" ></span>if(n.type==="QueryEngineError")<span class="cstat-no" title="statement not covered" >throw new X(n.body.message,{code:n.body.error_code,clientVersion:t});<span class="cstat-no" title="statement not covered" >i</span></span>f(n.type==="DataProxyError"){<span class="cstat-no" title="statement not covered" >if(n.body==="InternalDataProxyError")<span class="cstat-no" title="statement not covered" >throw new Ht(r,"Internal Data Proxy error");<span class="cstat-no" title="statement not covered" >i</span></span>f("EngineNotStarted"in n.body){<span class="cstat-no" title="statement not covered" >if(n.body.EngineNotStarted.reason==="SchemaMissing")<span class="cstat-no" title="statement not covered" >return new lt(r);<span class="cstat-no" title="statement not covered" >i</span></span>f(n.body.EngineNotStarted.reason==="EngineVersionNotSupported")<span class="cstat-no" title="statement not covered" >throw new Lr(r);<span class="cstat-no" title="statement not covered" >i</span></span>f("EngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,logs:o}=<span class="cstat-no" title="statement not covered" >n.body.EngineNotStarted.reason.EngineStartupError;<span class="cstat-no" title="statement not covered" ></span>throw new Nr(r,i,o)}<span class="cstat-no" title="statement not covered" ></span>i</span>f("KnownEngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,error_code:o}=<span class="cstat-no" title="statement not covered" >n.body.EngineNotStarted.reason.KnownEngineStartupError;<span class="cstat-no" title="statement not covered" ></span>throw new F(i,t,o)}<span class="cstat-no" title="statement not covered" ></span>i</span>f("HealthcheckTimeout"in n.body.EngineNotStarted.reason){let{logs:i}=<span class="cstat-no" title="statement not covered" >n.body.EngineNotStarted.reason.HealthcheckTimeout;<span class="cstat-no" title="statement not covered" ></span>throw new Mr(r,i)}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f("InteractiveTransactionMisrouted"in n.body){let i=<span class="cstat-no" title="statement not covered" >{IDParseError:"Could not parse interactive transaction ID",NoQueryEngineFoundError:"Could not find Query Engine for the specified host and transaction ID",TransactionStartError:"Could not start interactive transaction"};<span class="cstat-no" title="statement not covered" ></span>throw new Fr(r,i[n.body.InteractiveTransactionMisrouted.reason])}<span class="cstat-no" title="statement not covered" ></span>i</span>f("InvalidRequestError"in n.body)<span class="cstat-no" title="statement not covered" >throw new $r(r,n.body.InvalidRequestError.reason)}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(e.status===401||e.status===403)<span class="cstat-no" title="statement not covered" >throw new qr(r,Gt(Oo,n));<span class="cstat-no" title="statement not covered" >i</span></span>f(e.status===404)<span class="cstat-no" title="statement not covered" >return new Vr(r,Gt(Io,n));<span class="cstat-no" title="statement not covered" >i</span></span>f(e.status===429)<span class="cstat-no" title="statement not covered" >throw new Br(r,Gt(Do,n));<span class="cstat-no" title="statement not covered" >i</span></span>f(e.status===504)<span class="cstat-no" title="statement not covered" >throw new Ur(r,Gt(So,n));<span class="cstat-no" title="statement not covered" >i</span></span>f(e.status&gt;=500)<span class="cstat-no" title="statement not covered" >throw new Ht(r,Gt(ko,n));<span class="cstat-no" title="statement not covered" >i</span></span>f(e.status&gt;=400)<span class="cstat-no" title="statement not covered" >throw new _r(r,Gt(Co,n))}</span></span>function <span class="fstat-no" title="function not covered" >Gt(</span>e,t){<span class="cstat-no" title="statement not covered" >return t.type==="EmptyError"?e:`${e}: ${JSON.stringify(t)}`}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >wc(</span>e){let t=<span class="cstat-no" title="statement not covered" >Math.pow(2,e)*50,</span>r=<span class="cstat-no" title="statement not covered" >Math.ceil(Math.random()*t)-Math.ceil(t/2),</span>n=<span class="cstat-no" title="statement not covered" >t+r;<span class="cstat-no" title="statement not covered" ></span>return new Promise(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >i(n),</span>n))</span>}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Fe=<span class="cstat-no" title="statement not covered" >"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";</span>function <span class="fstat-no" title="function not covered" >bc(</span>e){let t=<span class="cstat-no" title="statement not covered" >new TextEncoder().encode(e),</span>r=<span class="cstat-no" title="statement not covered" >"",</span>n=<span class="cstat-no" title="statement not covered" >t.byteLength,</span>i=<span class="cstat-no" title="statement not covered" >n%3,</span>o=<span class="cstat-no" title="statement not covered" >n-i,</span>s,a,f,w,A;<span class="cstat-no" title="statement not covered" >for(let R=<span class="cstat-no" title="statement not covered" >0;</span>R&lt;o;R=R+3)<span class="cstat-no" title="statement not covered" >A=t[R]&lt;&lt;16|t[R+1]&lt;&lt;8|t[R+2],s=(A&amp;16515072)&gt;&gt;18,a=(A&amp;258048)&gt;&gt;12,f=(A&amp;4032)&gt;&gt;6,w=A&amp;63,r+=Fe[s]+Fe[a]+Fe[f]+Fe[w];<span class="cstat-no" title="statement not covered" >r</span></span>eturn i==1?(A=t[o],s=(A&amp;252)&gt;&gt;2,a=(A&amp;3)&lt;&lt;4,r+=Fe[s]+Fe[a]+"=="):i==2&amp;&amp;(A=t[o]&lt;&lt;8|t[o+1],s=(A&amp;64512)&gt;&gt;10,a=(A&amp;1008)&gt;&gt;4,f=(A&amp;15)&lt;&lt;2,r+=Fe[s]+Fe[a]+Fe[f]+"="),r}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ec(</span>e){<span class="cstat-no" title="statement not covered" >if(!!e.generator?.previewFeatures.some(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r.toLowerCase().includes("metrics"))</span>)<span class="cstat-no" title="statement not covered" >throw new F("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate",e.clientVersion)}<span class="cstat-no" title="statement not covered" ></span></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar xc=<span class="cstat-no" title="statement not covered" >{"@prisma/debug":"workspace:*","@prisma/engines-version":"6.17.1-1.272a37d34178c2894197e17273bf937f25acdeac","@prisma/fetch-engine":"workspace:*","@prisma/get-platform":"workspace:*"};<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Qr=<span class="cstat-no" title="statement not covered" >class extends ge{name=<span class="cstat-no" title="statement not covered" >"RequestError";</span>code=<span class="cstat-no" title="statement not covered" >"P5010";<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >super(`Cannot fetch data from service:</span></span>
${t}`,N(r,!0))}};<span class="cstat-no" title="statement not covered" >D(Qr,"RequestError");a</span>sync function <span class="fstat-no" title="function not covered" >ct(</span>e,t,r=<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >n)</span></span>{let{clientVersion:n,...i}=<span class="cstat-no" title="statement not covered" >t,</span>o=<span class="cstat-no" title="statement not covered" >r(fetch);<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >return await o(e,i)}</span>catch(s){let a=<span class="cstat-no" title="statement not covered" >s.message??"Unknown error";<span class="cstat-no" title="statement not covered" ></span>throw new Qr(a,{clientVersion:n,cause:s})}</span>}</span>var yf=<span class="cstat-no" title="statement not covered" >/^[1-9][0-9]*\.[0-9]+\.[0-9]+$/,</span>Pc=<span class="cstat-no" title="statement not covered" >K("prisma:client:dataproxyEngine");</span>async function <span class="fstat-no" title="function not covered" >hf(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >xc["@prisma/engines-version"],</span>n=<span class="cstat-no" title="statement not covered" >t.clientVersion??"unknown";<span class="cstat-no" title="statement not covered" ></span>if(g.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION||globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)<span class="cstat-no" title="statement not covered" >return g.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION||globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.includes("accelerate")&amp;&amp;n!=="0.0.0"&amp;&amp;n!=="in-memory")<span class="cstat-no" title="statement not covered" >return n;l</span></span>et[i,o]=<span class="cstat-no" title="statement not covered" >n?.split("-")??[];<span class="cstat-no" title="statement not covered" ></span>if(o===void 0&amp;&amp;yf.test(i))<span class="cstat-no" title="statement not covered" >return i;<span class="cstat-no" title="statement not covered" >i</span></span>f(o!==void 0||n==="0.0.0"||n==="in-memory"){let[s]=<span class="cstat-no" title="statement not covered" >r.split("-")??[],</span>[a,f,w]=<span class="cstat-no" title="statement not covered" >s.split("."),</span>A=<span class="cstat-no" title="statement not covered" >wf(`&lt;=${a}.${f}.${w}`),</span>R=<span class="cstat-no" title="statement not covered" >await ct(A,{clientVersion:n});<span class="cstat-no" title="statement not covered" ></span>if(!R.ok)<span class="cstat-no" title="statement not covered" >throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${R.status} ${R.statusText}, response body: ${await R.text()||"&lt;empty body&gt;"}`);l</span></span>et S=<span class="cstat-no" title="statement not covered" >await R.text();<span class="cstat-no" title="statement not covered" ></span>Pc("length of body fetched from unpkg.com",S.length);l</span>et C;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >C=JSON.parse(S)}</span>catch(L){<span class="cstat-no" title="statement not covered" >throw console.error("JSON.parse error: body fetched from unpkg.com: ",S),L}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn C.version}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow new at("Only `major.minor.patch` versions are supported by Accelerate.",{clientVersion:n})}</span>async function <span class="fstat-no" title="function not covered" >Tc(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >await hf(e,t);<span class="cstat-no" title="statement not covered" ></span>return Pc("version",r),r}</span>function <span class="fstat-no" title="function not covered" >wf(</span>e){<span class="cstat-no" title="statement not covered" >return encodeURI(`https://unpkg.com/prisma@${e}/package.json`)}</span>var vc=<span class="cstat-no" title="statement not covered" >3,</span>Hr=<span class="cstat-no" title="statement not covered" >K("prisma:client:dataproxyEngine"),</span>Gr=<span class="cstat-no" title="statement not covered" >class{name=<span class="cstat-no" title="statement not covered" >"DataProxyEngine";</span>inlineSchema;inlineSchemaHash;inlineDatasources;config;logEmitter;env;clientVersion;engineHash;tracingHelper;remoteClientVersion;host;headerBuilder;startPromise;protocol;<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >Ec(t),this.config=t,this.env=t.env,this.inlineSchema=bc(t.inlineSchema),this.inlineDatasources=t.inlineDatasources,this.inlineSchemaHash=t.inlineSchemaHash,this.clientVersion=t.clientVersion,this.engineHash=t.engineVersion,this.logEmitter=t.logEmitter,this.tracingHelper=t.tracingHelper}<span class="fstat-no" title="function not covered" ></span>ap</span>iKey(){<span class="cstat-no" title="statement not covered" >return this.headerBuilder.apiKey}<span class="fstat-no" title="function not covered" ></span>ve</span>rsion(){<span class="cstat-no" title="statement not covered" >return this.engineHash}<span class="fstat-no" title="function not covered" ></span>as</span>ync start(){<span class="cstat-no" title="statement not covered" >this.startPromise!==void 0&amp;&amp;await this.startPromise,this.startPromise=(<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{let{apiKey:t,url:r}=<span class="cstat-no" title="statement not covered" >this.getURLAndAPIKey();<span class="cstat-no" title="statement not covered" ></span>this.host=r.host,this.protocol=r.protocol,this.headerBuilder=new Bt({apiKey:t,tracingHelper:this.tracingHelper,logLevel:this.config.logLevel??"error",logQueries:this.config.logQueries,engineHash:this.engineHash}),this.remoteClientVersion=await Tc(this.host,this.config),Hr("host",this.host),Hr("protocol",this.protocol)}</span>)(),await this.startPromise}<span class="fstat-no" title="function not covered" ></span>as</span>ync stop(){}<span class="fstat-no" title="function not covered" >pr</span>opagateResponseExtensions(t){<span class="cstat-no" title="statement not covered" >t?.logs?.length&amp;&amp;t.logs.forEach(<span class="fstat-no" title="function not covered" >r=</span>&gt;{<span class="cstat-no" title="statement not covered" >switch(r.level){case"debug":case"trace":<span class="cstat-no" title="statement not covered" >Hr(r);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"error":case"warn":case"info":{<span class="cstat-no" title="statement not covered" >this.logEmitter.emit(r.level,{timestamp:jt(r.timestamp),message:r.attributes.message??"",target:r.target??"BinaryEngine"});<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"query":{<span class="cstat-no" title="statement not covered" >this.logEmitter.emit("query",{query:r.attributes.query??"",timestamp:jt(r.timestamp),duration:r.attributes.duration_ms??0,params:r.attributes.params??"",target:r.target??"BinaryEngine"});<span class="cstat-no" title="statement not covered" >b</span>reak}</span>default:<span class="cstat-no" title="statement not covered" >r.level}</span>}</span>),t?.traces?.length&amp;&amp;this.tracingHelper.dispatchEngineSpans(t.traces)}<span class="fstat-no" title="function not covered" ></span>on</span>BeforeExit(){<span class="cstat-no" title="statement not covered" >throw new Error('"beforeExit" hook is not applicable to the remote query engine')}<span class="fstat-no" title="function not covered" ></span>as</span>ync url(t){<span class="cstat-no" title="statement not covered" >return await this.start(),`${this.protocol}//${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${t}`}<span class="fstat-no" title="function not covered" ></span>as</span>ync uploadSchema(){let t=<span class="cstat-no" title="statement not covered" >{name:"schemaUpload",internal:!0};<span class="cstat-no" title="statement not covered" ></span>return this.tracingHelper.runInChildSpan(t,<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{let r=<span class="cstat-no" title="statement not covered" >await ct(await this.url("schema"),{method:"PUT",headers:this.headerBuilder.build(),body:this.inlineSchema,clientVersion:this.clientVersion});<span class="cstat-no" title="statement not covered" ></span>r.ok||Hr("schema response status",r.status);l</span>et n=<span class="cstat-no" title="statement not covered" >await jr(r,this.clientVersion);<span class="cstat-no" title="statement not covered" ></span>if(n)<span class="cstat-no" title="statement not covered" >throw this.logEmitter.emit("warn",{message:`Error while uploading schema: ${n.message}`,timestamp:new Date,target:""}),n;<span class="cstat-no" title="statement not covered" >t</span></span>his.logEmitter.emit("info",{message:`Schema (re)uploaded (hash: ${this.inlineSchemaHash})`,timestamp:new Date,target:""})}</span>)}<span class="fstat-no" title="function not covered" ></span>re</span>quest(t,{traceparent:r,interactiveTransaction:n,customDataProxyFetch:i}){<span class="cstat-no" title="statement not covered" >return this.requestInternal({body:t,traceparent:r,interactiveTransaction:n,customDataProxyFetch:i})}<span class="fstat-no" title="function not covered" ></span>as</span>ync requestBatch(t,{traceparent:r,transaction:n,customDataProxyFetch:i}){let o=<span class="cstat-no" title="statement not covered" >n?.kind==="itx"?n.options:void 0,</span>s=<span class="cstat-no" title="statement not covered" >kt(t,n);<span class="cstat-no" title="statement not covered" ></span>return(await this.requestInternal({body:s,customDataProxyFetch:i,interactiveTransaction:o,traceparent:r})).map(<span class="fstat-no" title="function not covered" >f=</span>&gt;(<span class="cstat-no" title="statement not covered" >f.extensions&amp;&amp;this.propagateResponseExtensions(f.extensions),"errors"in f?this.convertProtocolErrorsToClientError(f.errors):f)</span>)}<span class="fstat-no" title="function not covered" ></span>re</span>questInternal({body:t,traceparent:r,customDataProxyFetch:n,interactiveTransaction:i}){<span class="cstat-no" title="statement not covered" >return this.withRetry({actionGerund:"querying",callback:<span class="fstat-no" title="function not covered" >as</span>ync({logHttpCall:o})=&gt;{let s=<span class="cstat-no" title="statement not covered" >i?`${i.payload.endpoint}/graphql`:await this.url("graphql");<span class="cstat-no" title="statement not covered" ></span>o(s);l</span>et a=<span class="cstat-no" title="statement not covered" >await ct(s,{method:"POST",headers:this.headerBuilder.build({traceparent:r,transactionId:i?.id}),body:JSON.stringify(t),clientVersion:this.clientVersion},n);<span class="cstat-no" title="statement not covered" ></span>a.ok||Hr("graphql response status",a.status),await this.handleError(await jr(a,this.clientVersion));l</span>et f=<span class="cstat-no" title="statement not covered" >await a.json();<span class="cstat-no" title="statement not covered" ></span>if(f.extensions&amp;&amp;this.propagateResponseExtensions(f.extensions),"errors"in f)<span class="cstat-no" title="statement not covered" >throw this.convertProtocolErrorsToClientError(f.errors);<span class="cstat-no" title="statement not covered" >r</span></span>eturn"batchResult"in f?f.batchResult:f}</span>})}<span class="fstat-no" title="function not covered" ></span>as</span>ync transaction(t,r,n){let i=<span class="cstat-no" title="statement not covered" >{start:"starting",commit:"committing",rollback:"rolling back"};<span class="cstat-no" title="statement not covered" ></span>return this.withRetry({actionGerund:`${i[t]} transaction`,callback:<span class="fstat-no" title="function not covered" >as</span>ync({logHttpCall:o})=&gt;{<span class="cstat-no" title="statement not covered" >if(t==="start"){let s=<span class="cstat-no" title="statement not covered" >JSON.stringify({max_wait:n.maxWait,timeout:n.timeout,isolation_level:n.isolationLevel}),</span>a=<span class="cstat-no" title="statement not covered" >await this.url("transaction/start");<span class="cstat-no" title="statement not covered" ></span>o(a);l</span>et f=<span class="cstat-no" title="statement not covered" >await ct(a,{method:"POST",headers:this.headerBuilder.build({traceparent:r.traceparent}),body:s,clientVersion:this.clientVersion});<span class="cstat-no" title="statement not covered" ></span>await this.handleError(await jr(f,this.clientVersion));l</span>et w=<span class="cstat-no" title="statement not covered" >await f.json(),</span>{extensions:A}=<span class="cstat-no" title="statement not covered" >w;<span class="cstat-no" title="statement not covered" ></span>A&amp;&amp;this.propagateResponseExtensions(A);l</span>et R=<span class="cstat-no" title="statement not covered" >w.id,</span>S=<span class="cstat-no" title="statement not covered" >w["data-proxy"].endpoint;<span class="cstat-no" title="statement not covered" ></span>return{id:R,payload:{endpoint:S}}}</span>else{let s=<span class="cstat-no" title="statement not covered" >`${n.payload.endpoint}/${t}`;<span class="cstat-no" title="statement not covered" ></span>o(s);l</span>et a=<span class="cstat-no" title="statement not covered" >await ct(s,{method:"POST",headers:this.headerBuilder.build({traceparent:r.traceparent}),clientVersion:this.clientVersion});<span class="cstat-no" title="statement not covered" ></span>await this.handleError(await jr(a,this.clientVersion));l</span>et f=<span class="cstat-no" title="statement not covered" >await a.json(),</span>{extensions:w}=<span class="cstat-no" title="statement not covered" >f;<span class="cstat-no" title="statement not covered" ></span>w&amp;&amp;this.propagateResponseExtensions(w);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>}</span>})}<span class="fstat-no" title="function not covered" ></span>ge</span>tURLAndAPIKey(){<span class="cstat-no" title="statement not covered" >return ni({clientVersion:this.clientVersion,env:this.env,inlineDatasources:this.inlineDatasources,overrideDatasources:this.config.overrideDatasources})}<span class="fstat-no" title="function not covered" ></span>me</span>trics(){<span class="cstat-no" title="statement not covered" >throw new at("Metrics are not yet supported for Accelerate",{clientVersion:this.clientVersion})}<span class="fstat-no" title="function not covered" ></span>as</span>ync withRetry(t){<span class="cstat-no" title="statement not covered" >for(let r=<span class="cstat-no" title="statement not covered" >0;</span>;r++){let n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >i=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.logEmitter.emit("info",{message:`Calling ${i} (n=${r})`,timestamp:new Date,target:""})}</span>;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >return await t.callback({logHttpCall:n})}</span>catch(i){<span class="cstat-no" title="statement not covered" >if(!(i instanceof ge)||!i.isRetryable)<span class="cstat-no" title="statement not covered" >throw i;<span class="cstat-no" title="statement not covered" >i</span></span>f(r&gt;=vc)<span class="cstat-no" title="statement not covered" >throw i instanceof Qt?i.cause:i;<span class="cstat-no" title="statement not covered" >t</span></span>his.logEmitter.emit("warn",{message:`Attempt ${r+1}/${vc} failed for ${t.actionGerund}: ${i.message??"(unknown)"}`,timestamp:new Date,target:""});l</span>et o=<span class="cstat-no" title="statement not covered" >await wc(r);<span class="cstat-no" title="statement not covered" ></span>this.logEmitter.emit("warn",{message:`Retrying after ${o}ms`,timestamp:new Date,target:""})}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>as</span>ync handleError(t){<span class="cstat-no" title="statement not covered" >if(t instanceof lt)<span class="cstat-no" title="statement not covered" >throw await this.uploadSchema(),new Qt({clientVersion:this.clientVersion,cause:t});<span class="cstat-no" title="statement not covered" >i</span></span>f(t)<span class="cstat-no" title="statement not covered" >throw t}<span class="fstat-no" title="function not covered" ></span></span>co</span>nvertProtocolErrorsToClientError(t){<span class="cstat-no" title="statement not covered" >return t.length===1?_n(t[0],this.config.clientVersion,this.config.activeProvider):new ne(JSON.stringify(t),{clientVersion:this.config.clientVersion})}<span class="fstat-no" title="function not covered" ></span>ap</span>plyPendingMigrations(){<span class="cstat-no" title="statement not covered" >throw new Error("Method not implemented.")}</span>};<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ac(</span>{url:e,adapter:t,copyEngine:r,targetBuildType:n}){let i=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >k=</span>&gt;{<span class="cstat-no" title="statement not covered" >i.push({_tag:"warning",value:k})}</span>,</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >k=</span>&gt;{let M=<span class="cstat-no" title="statement not covered" >k.join(`</span></span>
`);<span class="cstat-no" title="statement not covered" >o.push({_tag:"error",value:M})}</span>,f=<span class="cstat-no" title="statement not covered" >!!e?.startsWith("prisma://"),</span>w=<span class="cstat-no" title="statement not covered" >cn(e),</span>A=<span class="cstat-no" title="statement not covered" >!!t,</span>R=<span class="cstat-no" title="statement not covered" >f||w;<span class="cstat-no" title="statement not covered" ></span>!A&amp;&amp;r&amp;&amp;R&amp;&amp;n!=="client"&amp;&amp;n!=="wasm-compiler-edge"&amp;&amp;s(["recommend--no-engine","In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)"]);l</span>et S=<span class="cstat-no" title="statement not covered" >R||!r;<span class="cstat-no" title="statement not covered" ></span>A&amp;&amp;(S||n==="edge")&amp;&amp;(n==="edge"?a(["Prisma Client was configured to use the `adapter` option but it was imported via its `/edge` endpoint.","Please either remove the `/edge` endpoint or remove the `adapter` from the Prisma Client constructor."]):R?a(["You've provided both a driver adapter and an Accelerate database URL. Driver adapters currently cannot connect to Accelerate.","Please provide either a driver adapter with a direct database URL or an Accelerate URL and no driver adapter."]):r||a(["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.","Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."]));l</span>et C=<span class="cstat-no" title="statement not covered" >{accelerate:S,ppg:w,driverAdapters:A};</span>function <span class="fstat-no" title="function not covered" >L(</span>k){<span class="cstat-no" title="statement not covered" >return k.length&gt;0}<span class="cstat-no" title="statement not covered" ></span>return L(o)?{ok:!1,diagnostics:{warnings:i,errors:o},isUsing:C}:{ok:!0,diagnostics:{warnings:i},isUsing:C}}</span>function <span class="fstat-no" title="function not covered" >Rc(</span>{copyEngine:e=<span class="branch-0 cbranch-no" title="branch not covered" >!0}</span>,t){let r;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >r=qt({inlineDatasources:t.inlineDatasources,overrideDatasources:t.overrideDatasources,env:{...t.env,...g.env},clientVersion:t.clientVersion})}</span>catch{}l</span>et{ok:n,isUsing:i,diagnostics:o}=<span class="cstat-no" title="statement not covered" >Ac({url:r,adapter:t.adapter,copyEngine:e,targetBuildType:"wasm-compiler-edge"});<span class="cstat-no" title="statement not covered" ></span>for(let R of o.warnings)<span class="cstat-no" title="statement not covered" >rr(...R.value);<span class="cstat-no" title="statement not covered" >i</span></span>f(!n){let R=<span class="cstat-no" title="statement not covered" >o.errors[0];<span class="cstat-no" title="statement not covered" ></span>throw new ie(R.value,{clientVersion:t.clientVersion})}</span>l</span>et s=<span class="cstat-no" title="statement not covered" >gt(t.generator),</span>a=<span class="cstat-no" title="statement not covered" >s==="library",</span>f=<span class="cstat-no" title="statement not covered" >s==="binary",</span>w=<span class="cstat-no" title="statement not covered" >s==="client",</span>A=<span class="cstat-no" title="statement not covered" >(i.accelerate||i.ppg)&amp;&amp;!i.driverAdapters;<span class="cstat-no" title="statement not covered" ></span>return w?new Dr(t,A):i.accelerate?new Gr(t):(i.driverAdapters,i.accelerate,new _o({clientVersion:t.clientVersion}))}</span>var _o=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >return new Proxy(this,{<span class="fstat-no" title="function not covered" >ge</span>t(r,n){let i=<span class="cstat-no" title="statement not covered" >`In order to run Prisma Client on edge runtime, either:</span></span></span>
- Use Prisma Accelerate: https://pris.ly/d/accelerate
- Use Driver Adapters: https://pris.ly/d/driver-adapters`;<span class="cstat-no" title="statement not covered" >throw new ie(i,t)}</span>})}};<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Cc(</span>{generator:e}){<span class="cstat-no" title="statement not covered" >return e?.previewFeatures??[]}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Sc=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;(<span class="cstat-no" title="statement not covered" >{command:e})</span>;<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Ic=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.strings.reduce(<span class="fstat-no" title="function not covered" >(t</span>,r,n)=&gt;<span class="cstat-no" title="statement not covered" >`${t}@P${n}${r}`)</span>;<span class="cstat-no" title="statement not covered" ></span></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Jt(</span>e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return kc(e,"fast")}</span>catch{<span class="cstat-no" title="statement not covered" >return kc(e,"slow")}</span>}</span>function <span class="fstat-no" title="function not covered" >kc(</span>e,t){<span class="cstat-no" title="statement not covered" >return JSON.stringify(e.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >Dc(r,t))</span>)}</span>function <span class="fstat-no" title="function not covered" >Dc(</span>e,t){<span class="cstat-no" title="statement not covered" >if(Array.isArray(e))<span class="cstat-no" title="statement not covered" >return e.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >Dc(r,t))</span>;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof e=="bigint")<span class="cstat-no" title="statement not covered" >return{prisma__type:"bigint",prisma__value:e.toString()};<span class="cstat-no" title="statement not covered" >i</span></span>f(wt(e))<span class="cstat-no" title="statement not covered" >return{prisma__type:"date",prisma__value:e.toJSON()};<span class="cstat-no" title="statement not covered" >i</span></span>f(se.isDecimal(e))<span class="cstat-no" title="statement not covered" >return{prisma__type:"decimal",prisma__value:e.toJSON()};<span class="cstat-no" title="statement not covered" >i</span></span>f(y.isBuffer(e))<span class="cstat-no" title="statement not covered" >return{prisma__type:"bytes",prisma__value:e.toString("base64")};<span class="cstat-no" title="statement not covered" >i</span></span>f(bf(e))<span class="cstat-no" title="statement not covered" >return{prisma__type:"bytes",prisma__value:y.from(e).toString("base64")};<span class="cstat-no" title="statement not covered" >i</span></span>f(ArrayBuffer.isView(e)){let{buffer:r,byteOffset:n,byteLength:i}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return{prisma__type:"bytes",prisma__value:y.from(r,n,i).toString("base64")}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn typeof e=="object"&amp;&amp;t==="slow"?_c(e):e}</span>function <span class="fstat-no" title="function not covered" >bf(</span>e){<span class="cstat-no" title="statement not covered" >return e instanceof ArrayBuffer||e instanceof SharedArrayBuffer?!0:typeof e=="object"&amp;&amp;e!==null?e[Symbol.toStringTag]==="ArrayBuffer"||e[Symbol.toStringTag]==="SharedArrayBuffer":!1}</span>function <span class="fstat-no" title="function not covered" >_c(</span>e){<span class="cstat-no" title="statement not covered" >if(typeof e!="object"||e===null)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof e.toJSON=="function")<span class="cstat-no" title="statement not covered" >return e.toJSON();<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(e))<span class="cstat-no" title="statement not covered" >return e.map(Oc);l</span></span>et t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let r of Object.keys(e))<span class="cstat-no" title="statement not covered" >t[r]=Oc(e[r]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Oc(</span>e){<span class="cstat-no" title="statement not covered" >return typeof e=="bigint"?e.toString():_c(e)}</span>var Ef=<span class="cstat-no" title="statement not covered" >/^(\s*alter\s)/i,</span>Mc=<span class="cstat-no" title="statement not covered" >K("prisma:client");</span>function <span class="fstat-no" title="function not covered" >Mo(</span>e,t,r,n){<span class="cstat-no" title="statement not covered" >if(!(e!=="postgresql"&amp;&amp;e!=="cockroachdb")&amp;&amp;r.length&gt;0&amp;&amp;Ef.exec(t))<span class="cstat-no" title="statement not covered" >throw new Error(`Running ALTER using ${n} is not supported</span></span>
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.
&nbsp;
Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)
&nbsp;
More Information: https://pris.ly/d/execute-raw
`)}var No=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>clientMethod:e,activeProvider:t})=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >r=</span>&gt;{let n=<span class="cstat-no" title="statement not covered" >"",</span>i;<span class="cstat-no" title="statement not covered" >if(In(r))<span class="cstat-no" title="statement not covered" >n=r.sql,i={values:Jt(r.values),__prismaRawParameters__:!0};e</span>lse <span class="cstat-no" title="statement not covered" >if(Array.isArray(r)){let[o,...s]=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>n=o,i={values:Jt(s||[]),__prismaRawParameters__:!0}}</span>else <span class="cstat-no" title="statement not covered" >switch(t){case"sqlite":case"mysql":{<span class="cstat-no" title="statement not covered" >n=r.sql,i={values:Jt(r.values),__prismaRawParameters__:!0};<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"cockroachdb":case"postgresql":case"postgres":{<span class="cstat-no" title="statement not covered" >n=r.text,i={values:Jt(r.values),__prismaRawParameters__:!0};<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"sqlserver":{<span class="cstat-no" title="statement not covered" >n=Ic(r),i={values:Jt(r.values),__prismaRawParameters__:!0};<span class="cstat-no" title="statement not covered" >b</span>reak}</span>default:<span class="cstat-no" title="statement not covered" >throw new Error(`The ${t} provider does not support ${e}`)}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn i?.values?Mc(`prisma.${e}(${n}, ${i.values})`):Mc(`prisma.${e}(${n})`),{query:n,parameters:i}}</span>,</span></span>Nc=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >re</span>questArgsToMiddlewareArgs(e){<span class="cstat-no" title="statement not covered" >return[e.strings,...e.values]}</span>,<span class="fstat-no" title="function not covered" >mi</span>ddlewareArgsToRequestArgs(e){let[t,...r]=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return new fe(t,r)}</span>},</span>Lc=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >re</span>questArgsToMiddlewareArgs(e){<span class="cstat-no" title="statement not covered" >return[e]}</span>,<span class="fstat-no" title="function not covered" >mi</span>ddlewareArgsToRequestArgs(e){<span class="cstat-no" title="statement not covered" >return e[0]}</span>};<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Lo(</span>e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(r,n){let i,o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(s</span>=<span class="branch-0 cbranch-no" title="branch not covered" >e)</span>=&gt;{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return s===void 0||s?.kind==="itx"?i??=Uc(r(s)):Uc(r(s))}</span>catch(a){<span class="cstat-no" title="statement not covered" >return Promise.reject(a)}</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>return{<span class="fstat-no" title="function not covered" >ge</span>t spec(){<span class="cstat-no" title="statement not covered" >return n}</span>,<span class="fstat-no" title="function not covered" >th</span>en(s,a){<span class="cstat-no" title="statement not covered" >return o().then(s,a)}</span>,<span class="fstat-no" title="function not covered" >ca</span>tch(s){<span class="cstat-no" title="statement not covered" >return o().catch(s)}</span>,<span class="fstat-no" title="function not covered" >fi</span>nally(s){<span class="cstat-no" title="statement not covered" >return o().finally(s)}</span>,<span class="fstat-no" title="function not covered" >re</span>questTransaction(s){let a=<span class="cstat-no" title="statement not covered" >o(s);<span class="cstat-no" title="statement not covered" ></span>return a.requestTransaction?a.requestTransaction(s):a}</span>,[Symbol.toStringTag]:"PrismaPromise"}}</span>}</span>function <span class="fstat-no" title="function not covered" >Uc(</span>e){<span class="cstat-no" title="statement not covered" >return typeof e.then=="function"?e:Promise.resolve(e)}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar xf=<span class="cstat-no" title="statement not covered" >Ei.split(".")[0],</span>Pf=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >is</span>Enabled(){<span class="cstat-no" title="statement not covered" >return!1}</span>,<span class="fstat-no" title="function not covered" >ge</span>tTraceParent(){<span class="cstat-no" title="statement not covered" >return"00-10-10-00"}</span>,<span class="fstat-no" title="function not covered" >di</span>spatchEngineSpans(){},<span class="fstat-no" title="function not covered" >ge</span>tActiveContext(){},<span class="fstat-no" title="function not covered" >ru</span>nInChildSpan(e,t){<span class="cstat-no" title="statement not covered" >return t()}</span>},</span>Uo=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >is</span>Enabled(){<span class="cstat-no" title="statement not covered" >return this.getGlobalTracingHelper().isEnabled()}<span class="fstat-no" title="function not covered" ></span>ge</span>tTraceParent(t){<span class="cstat-no" title="statement not covered" >return this.getGlobalTracingHelper().getTraceParent(t)}<span class="fstat-no" title="function not covered" ></span>di</span>spatchEngineSpans(t){<span class="cstat-no" title="statement not covered" >return this.getGlobalTracingHelper().dispatchEngineSpans(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>tActiveContext(){<span class="cstat-no" title="statement not covered" >return this.getGlobalTracingHelper().getActiveContext()}<span class="fstat-no" title="function not covered" ></span>ru</span>nInChildSpan(t,r){<span class="cstat-no" title="statement not covered" >return this.getGlobalTracingHelper().runInChildSpan(t,r)}<span class="fstat-no" title="function not covered" ></span>ge</span>tGlobalTracingHelper(){let t=<span class="cstat-no" title="statement not covered" >globalThis[`V${xf}_PRISMA_INSTRUMENTATION`],</span>r=<span class="cstat-no" title="statement not covered" >globalThis.PRISMA_INSTRUMENTATION;<span class="cstat-no" title="statement not covered" ></span>return t?.helper??r?.helper??Pf}</span>};</span>function <span class="fstat-no" title="function not covered" >Fc(</span>){<span class="cstat-no" title="statement not covered" >return new Uo}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >$c(</span>e,t=<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >()</span>=&gt;{})</span>{let r,n=<span class="cstat-no" title="statement not covered" >new Promise(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >r=i)</span>;<span class="cstat-no" title="statement not covered" ></span>return{<span class="fstat-no" title="function not covered" >th</span>en(i){<span class="cstat-no" title="statement not covered" >return--e===0&amp;&amp;r(t()),i?.(n)}</span>}}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Vc(</span>e){<span class="cstat-no" title="statement not covered" >return typeof e=="string"?e:e.reduce(<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >typeof r=="string"?r:r.level;<span class="cstat-no" title="statement not covered" ></span>return n==="query"?t:t&amp;&amp;(r==="info"||t==="info")?"info":n}</span>,void 0)}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >oi(</span>e){<span class="cstat-no" title="statement not covered" >return typeof e.batchRequestIdx=="number"}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >qc(</span>e){<span class="cstat-no" title="statement not covered" >if(e.action!=="findUnique"&amp;&amp;e.action!=="findUniqueOrThrow")<span class="cstat-no" title="statement not covered" >return;l</span></span>et t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return e.modelName&amp;&amp;t.push(e.modelName),e.query.arguments&amp;&amp;t.push(Fo(e.query.arguments)),t.push(Fo(e.query.selection)),t.join("")}</span>function <span class="fstat-no" title="function not covered" >Fo(</span>e){<span class="cstat-no" title="statement not covered" >return`(${Object.keys(e).sort().map(<span class="fstat-no" title="function not covered" >r=</span>&gt;{let n=<span class="cstat-no" title="statement not covered" >e[r];<span class="cstat-no" title="statement not covered" ></span>return typeof n=="object"&amp;&amp;n!==null?`(${r} ${Fo(n)})`:r}</span>).join(" ")})`}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Tf=<span class="cstat-no" title="statement not covered" >{aggregate:!1,aggregateRaw:!1,createMany:!0,createManyAndReturn:!0,createOne:!0,deleteMany:!0,deleteOne:!0,executeRaw:!0,findFirst:!1,findFirstOrThrow:!1,findMany:!1,findRaw:!1,findUnique:!1,findUniqueOrThrow:!1,groupBy:!1,queryRaw:!1,runCommandRaw:!0,updateMany:!0,updateManyAndReturn:!0,updateOne:!0,upsertOne:!0};</span>function <span class="fstat-no" title="function not covered" >$o(</span>e){<span class="cstat-no" title="statement not covered" >return Tf[e]}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar si=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.options=t;<span class="cstat-no" title="statement not covered" >t</span>his.batches={}}</span>batches;tickActive=<span class="cstat-no" title="statement not covered" >!1;<span class="fstat-no" title="function not covered" ></span>re</span>quest(t){let r=<span class="cstat-no" title="statement not covered" >this.options.batchBy(t);<span class="cstat-no" title="statement not covered" ></span>return r?(this.batches[r]||(this.batches[r]=[],this.tickActive||(this.tickActive=!0,g.nextTick(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.dispatchBatches(),this.tickActive=!1}</span>))),new Promise(<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >this.batches[r].push({request:t,resolve:n,reject:i})}</span>)):this.options.singleLoader(t)}<span class="fstat-no" title="function not covered" ></span>di</span>spatchBatches(){<span class="cstat-no" title="statement not covered" >for(let t in this.batches){let r=<span class="cstat-no" title="statement not covered" >this.batches[t];<span class="cstat-no" title="statement not covered" ></span>delete this.batches[t],r.length===1?this.options.singleLoader(r[0].request).then(<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >n instanceof Error?r[0].reject(n):r[0].resolve(n)}</span>).catch(<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >r[0].reject(n)}</span>):(r.sort(<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >this.options.batchOrder(n.request,i.request))</span>,this.options.batchLoader(r.map(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >n.request)</span>).then(<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(n instanceof Error)<span class="cstat-no" title="statement not covered" >for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;r.length;i++)<span class="cstat-no" title="statement not covered" >r[i].reject(n);e</span></span>lse <span class="cstat-no" title="statement not covered" >for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;r.length;i++){let o=<span class="cstat-no" title="statement not covered" >n[i];<span class="cstat-no" title="statement not covered" ></span>o instanceof Error?r[i].reject(o):r[i].resolve(o)}</span>}</span></span>).catch(<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;r.length;i++)<span class="cstat-no" title="statement not covered" >r[i].reject(n)}</span></span>))}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t[Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"DataLoader"}</span>};<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >ut(</span>e,t){<span class="cstat-no" title="statement not covered" >if(t===null)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >s</span></span>witch(e){case"bigint":<span class="cstat-no" title="statement not covered" >return BigInt(t);c</span>ase"bytes":{let{buffer:r,byteOffset:n,byteLength:i}=<span class="cstat-no" title="statement not covered" >y.from(t,"base64");<span class="cstat-no" title="statement not covered" ></span>return new Uint8Array(r,n,i)}</span>case"decimal":<span class="cstat-no" title="statement not covered" >return new se(t);c</span>ase"datetime":case"date":<span class="cstat-no" title="statement not covered" >return new Date(t);c</span>ase"time":<span class="cstat-no" title="statement not covered" >return new Date(`1970-01-01T${t}Z`);c</span>ase"bigint-array":<span class="cstat-no" title="statement not covered" >return t.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >ut("bigint",r))</span>;c</span>ase"bytes-array":<span class="cstat-no" title="statement not covered" >return t.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >ut("bytes",r))</span>;c</span>ase"decimal-array":<span class="cstat-no" title="statement not covered" >return t.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >ut("decimal",r))</span>;c</span>ase"datetime-array":<span class="cstat-no" title="statement not covered" >return t.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >ut("datetime",r))</span>;c</span>ase"date-array":<span class="cstat-no" title="statement not covered" >return t.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >ut("date",r))</span>;c</span>ase"time-array":<span class="cstat-no" title="statement not covered" >return t.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >ut("time",r))</span>;d</span>efault:<span class="cstat-no" title="statement not covered" >return t}</span>}</span>function <span class="fstat-no" title="function not covered" >ai(</span>e){let t=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >vf(e);<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e.rows.length;n++){let i=<span class="cstat-no" title="statement not covered" >e.rows[n],</span>o=<span class="cstat-no" title="statement not covered" >{...r};<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;i.length;s++)<span class="cstat-no" title="statement not covered" >o[e.columns[s]]=ut(e.types[s],i[s]);<span class="cstat-no" title="statement not covered" >t</span></span>.push(o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >vf(</span>e){let t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;e.columns.length;r++)<span class="cstat-no" title="statement not covered" >t[e.columns[r]]=null;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>var Af=<span class="cstat-no" title="statement not covered" >K("prisma:client:request_handler"),</span>li=<span class="cstat-no" title="statement not covered" >class{client;dataloader;logEmitter;<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >this.logEmitter=r,this.client=t,this.dataloader=new si({batchLoader:Ma(<span class="fstat-no" title="function not covered" >as</span>ync({requests:n,customDataProxyFetch:i})=&gt;{let{transaction:o,otelParentCtx:s}=<span class="cstat-no" title="statement not covered" >n[0],</span>a=<span class="cstat-no" title="statement not covered" >n.map(<span class="fstat-no" title="function not covered" >R=</span>&gt;<span class="cstat-no" title="statement not covered" >R.protocolQuery)</span>,</span>f=<span class="cstat-no" title="statement not covered" >this.client._tracingHelper.getTraceParent(s),</span>w=<span class="cstat-no" title="statement not covered" >n.some(<span class="fstat-no" title="function not covered" >R=</span>&gt;<span class="cstat-no" title="statement not covered" >$o(R.protocolQuery.action))</span>;<span class="cstat-no" title="statement not covered" ></span>return(await this.client._engine.requestBatch(a,{traceparent:f,transaction:Rf(o),containsWrite:w,customDataProxyFetch:i})).map(<span class="fstat-no" title="function not covered" >(R</span>,S)=&gt;{<span class="cstat-no" title="statement not covered" >if(R instanceof Error)<span class="cstat-no" title="statement not covered" >return R;<span class="cstat-no" title="statement not covered" >t</span></span>ry{<span class="cstat-no" title="statement not covered" >return this.mapQueryEngineResult(n[S],R)}</span>catch(C){<span class="cstat-no" title="statement not covered" >return C}</span>}</span>)}</span>),singleLoader:<span class="fstat-no" title="function not covered" >as</span>ync n=&gt;{let i=<span class="cstat-no" title="statement not covered" >n.transaction?.kind==="itx"?Bc(n.transaction):void 0,</span>o=<span class="cstat-no" title="statement not covered" >await this.client._engine.request(n.protocolQuery,{traceparent:this.client._tracingHelper.getTraceParent(),interactiveTransaction:i,isWrite:$o(n.protocolQuery.action),customDataProxyFetch:n.customDataProxyFetch});<span class="cstat-no" title="statement not covered" ></span>return this.mapQueryEngineResult(n,o)}</span>,batchBy:<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >n.transaction?.id?`transaction-${n.transaction.id}`:qc(n.protocolQuery),<span class="fstat-no" title="function not covered" ></span>ba</span>tchOrder(n,i){<span class="cstat-no" title="statement not covered" >return n.transaction?.kind==="batch"&amp;&amp;i.transaction?.kind==="batch"?n.transaction.index-i.transaction.index:0}</span>})}<span class="fstat-no" title="function not covered" ></span>as</span>ync request(t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return await this.dataloader.request(t)}</span>catch(r){let{clientMethod:n,callsite:i,transaction:o,args:s,modelName:a}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>this.handleAndLogRequestError({error:r,clientMethod:n,callsite:i,transaction:o,args:s,modelName:a,globalOmit:t.globalOmit})}</span>}<span class="fstat-no" title="function not covered" ></span>ma</span>pQueryEngineResult({dataPath:t,unpacker:r},n){let i=<span class="cstat-no" title="statement not covered" >n?.data,</span>o=<span class="cstat-no" title="statement not covered" >this.unpack(i,t,r);<span class="cstat-no" title="statement not covered" ></span>return g.env.PRISMA_CLIENT_GET_TIME?{data:o}:o}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleAndLogRequestError(t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >this.handleRequestError(t)}</span>catch(r){<span class="cstat-no" title="statement not covered" >throw this.logEmitter&amp;&amp;this.logEmitter.emit("error",{message:r.message,target:t.clientMethod,timestamp:new Date}),r}</span>}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleRequestError({error:t,clientMethod:r,callsite:n,transaction:i,args:o,modelName:s,globalOmit:a}){<span class="cstat-no" title="statement not covered" >if(Af(t),Cf(t,i))<span class="cstat-no" title="statement not covered" >throw t;<span class="cstat-no" title="statement not covered" >i</span></span>f(t instanceof X&amp;&amp;Sf(t)){let w=<span class="cstat-no" title="statement not covered" >jc(t.meta);<span class="cstat-no" title="statement not covered" ></span>Tn({args:o,errors:[w],callsite:n,errorFormat:this.client._errorFormat,originalMethod:r,clientVersion:this.client._clientVersion,globalOmit:a})}</span>l</span>et f=<span class="cstat-no" title="statement not covered" >t.message;<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;(f=dn({callsite:n,originalMethod:r,isPanic:t.isPanic,showColors:this.client._errorFormat==="pretty",message:f})),f=this.sanitizeMessage(f),t.code){let w=<span class="cstat-no" title="statement not covered" >s?{modelName:s,...t.meta}:t.meta;<span class="cstat-no" title="statement not covered" ></span>throw new X(f,{code:t.code,clientVersion:this.client._clientVersion,meta:w,batchRequestIdx:t.batchRequestIdx})}</span>else{<span class="cstat-no" title="statement not covered" >if(t.isPanic)<span class="cstat-no" title="statement not covered" >throw new ae(f,this.client._clientVersion);<span class="cstat-no" title="statement not covered" >i</span></span>f(t instanceof ne)<span class="cstat-no" title="statement not covered" >throw new ne(f,{clientVersion:this.client._clientVersion,batchRequestIdx:t.batchRequestIdx});<span class="cstat-no" title="statement not covered" >i</span></span>f(t instanceof F)<span class="cstat-no" title="statement not covered" >throw new F(f,this.client._clientVersion);<span class="cstat-no" title="statement not covered" >i</span></span>f(t instanceof ae)<span class="cstat-no" title="statement not covered" >throw new ae(f,this.client._clientVersion)}<span class="cstat-no" title="statement not covered" ></span></span>t</span>hrow t.clientVersion=this.client._clientVersion,t}<span class="fstat-no" title="function not covered" ></span>sa</span>nitizeMessage(t){<span class="cstat-no" title="statement not covered" >return this.client._errorFormat&amp;&amp;this.client._errorFormat!=="pretty"?ht(t):t}<span class="fstat-no" title="function not covered" ></span>un</span>pack(t,r,n){<span class="cstat-no" title="statement not covered" >if(!t||(t.data&amp;&amp;(t=t.data),!t))<span class="cstat-no" title="statement not covered" >return t;l</span></span>et i=<span class="cstat-no" title="statement not covered" >Object.keys(t)[0],</span>o=<span class="cstat-no" title="statement not covered" >Object.values(t)[0],</span>s=<span class="cstat-no" title="statement not covered" >r.filter(<span class="fstat-no" title="function not covered" >w=</span>&gt;<span class="cstat-no" title="statement not covered" >w!=="select"&amp;&amp;w!=="include")</span>,</span>a=<span class="cstat-no" title="statement not covered" >qi(o,s),</span>f=<span class="cstat-no" title="statement not covered" >i==="queryRaw"?ai(a):Qe(a);<span class="cstat-no" title="statement not covered" ></span>return n?n(f):f}<span class="fstat-no" title="function not covered" ></span>ge</span>t[Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"RequestHandler"}</span>};</span>function <span class="fstat-no" title="function not covered" >Rf(</span>e){<span class="cstat-no" title="statement not covered" >if(e){<span class="cstat-no" title="statement not covered" >if(e.kind==="batch")<span class="cstat-no" title="statement not covered" >return{kind:"batch",options:{isolationLevel:e.isolationLevel}};<span class="cstat-no" title="statement not covered" >i</span></span>f(e.kind==="itx")<span class="cstat-no" title="statement not covered" >return{kind:"itx",options:Bc(e)};<span class="cstat-no" title="statement not covered" >M</span></span>e(e,"Unknown transaction kind")}</span>}</span>function <span class="fstat-no" title="function not covered" >Bc(</span>e){<span class="cstat-no" title="statement not covered" >return{id:e.id,payload:e.payload}}</span>function <span class="fstat-no" title="function not covered" >Cf(</span>e,t){<span class="cstat-no" title="statement not covered" >return oi(e)&amp;&amp;t?.kind==="batch"&amp;&amp;e.batchRequestIdx!==t.index}</span>function <span class="fstat-no" title="function not covered" >Sf(</span>e){<span class="cstat-no" title="statement not covered" >return e.code==="P2009"||e.code==="P2012"}</span>function <span class="fstat-no" title="function not covered" >jc(</span>e){<span class="cstat-no" title="statement not covered" >if(e.kind==="Union")<span class="cstat-no" title="statement not covered" >return{kind:"Union",errors:e.errors.map(jc)};<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(e.selectionPath)){let[,...t]=<span class="cstat-no" title="statement not covered" >e.selectionPath;<span class="cstat-no" title="statement not covered" ></span>return{...e,selectionPath:t}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Qc=<span class="cstat-no" title="statement not covered" >Zn;<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Kc=<span class="cstat-no" title="statement not covered" >$e(Ii());<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar V=<span class="cstat-no" title="statement not covered" >class extends Error{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t+`</span></span>
Read more at https://pris.ly/d/client-constructor`),this.name="PrismaClientConstructorValidationError"}<span class="fstat-no" title="function not covered" >ge</span>t[Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientConstructorValidationError"}</span>};<span class="cstat-no" title="statement not covered" >D(V,"PrismaClientConstructorValidationError");v</span>ar Hc=<span class="cstat-no" title="statement not covered" >["datasources","datasourceUrl","errorFormat","adapter","log","transactionOptions","omit","__internal"],</span>Gc=<span class="cstat-no" title="statement not covered" >["pretty","colorless","minimal"],</span>Jc=<span class="cstat-no" title="statement not covered" >["info","query","warn","error"],</span>If=<span class="cstat-no" title="statement not covered" >{datasources:<span class="fstat-no" title="function not covered" >(e</span>,{datasourceNames:t})=&gt;{<span class="cstat-no" title="statement not covered" >if(e){<span class="cstat-no" title="statement not covered" >if(typeof e!="object"||Array.isArray(e))<span class="cstat-no" title="statement not covered" >throw new V(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);<span class="cstat-no" title="statement not covered" >f</span></span>or(let[r,n]of Object.entries(e)){<span class="cstat-no" title="statement not covered" >if(!t.includes(r)){let i=<span class="cstat-no" title="statement not covered" >Wt(r,t)||` Available datasources: ${t.join(", ")}`;<span class="cstat-no" title="statement not covered" ></span>throw new V(`Unknown datasource ${r} provided to PrismaClient constructor.${i}`)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof n!="object"||Array.isArray(n))<span class="cstat-no" title="statement not covered" >throw new V(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.</span></span></span></span></span>
It should have this form: { url: "CONNECTION_STRING" }`);<span class="cstat-no" title="statement not covered" >if(n&amp;&amp;typeof n=="object")<span class="cstat-no" title="statement not covered" >for(let[i,o]of Object.entries(n)){<span class="cstat-no" title="statement not covered" >if(i!=="url")<span class="cstat-no" title="statement not covered" >throw new V(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.</span></span></span></span>
It should have this form: { url: "CONNECTION_STRING" }`);<span class="cstat-no" title="statement not covered" >if(typeof o!="string")<span class="cstat-no" title="statement not covered" >throw new V(`Invalid value ${JSON.stringify(o)} for datasource "${r}" provided to PrismaClient constructor.</span></span>
It should have this form: { url: "CONNECTION_STRING" }`)}}}},adapter:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if(!e&amp;&amp;gt(t.generator)==="client")<span class="cstat-no" title="statement not covered" >throw new V('Using engine type "client" requires a driver adapter to be provided to PrismaClient constructor.');<span class="cstat-no" title="statement not covered" >i</span></span>f(e!==null){<span class="cstat-no" title="statement not covered" >if(e===void 0)<span class="cstat-no" title="statement not covered" >throw new V('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');<span class="cstat-no" title="statement not covered" >i</span></span>f(gt(t.generator)==="binary")<span class="cstat-no" title="statement not covered" >throw new V('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.')}</span></span>}</span>,datasourceUrl:<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(typeof e&lt;"u"&amp;&amp;typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new V(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.</span></span>
Expected string or undefined.`)},errorFormat:<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(e){<span class="cstat-no" title="statement not covered" >if(typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new V(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);<span class="cstat-no" title="statement not covered" >i</span></span>f(!Gc.includes(e)){let t=<span class="cstat-no" title="statement not covered" >Wt(e,Gc);<span class="cstat-no" title="statement not covered" ></span>throw new V(`Invalid errorFormat ${e} provided to PrismaClient constructor.${t}`)}</span>}</span>}</span>,log:<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(!Array.isArray(e))<span class="cstat-no" title="statement not covered" >throw new V(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);f</span></span>unction <span class="fstat-no" title="function not covered" >t(</span>r){<span class="cstat-no" title="statement not covered" >if(typeof r=="string"&amp;&amp;!Jc.includes(r)){let n=<span class="cstat-no" title="statement not covered" >Wt(r,Jc);<span class="cstat-no" title="statement not covered" ></span>throw new V(`Invalid log level "${r}" provided to PrismaClient constructor.${n}`)}</span>}<span class="cstat-no" title="statement not covered" ></span>for(let r of e){<span class="cstat-no" title="statement not covered" >t(r);l</span>et n=<span class="cstat-no" title="statement not covered" >{level:t,emit:<span class="fstat-no" title="function not covered" >i=</span>&gt;{let o=<span class="cstat-no" title="statement not covered" >["stdout","event"];<span class="cstat-no" title="statement not covered" ></span>if(!o.includes(i)){let s=<span class="cstat-no" title="statement not covered" >Wt(i,o);<span class="cstat-no" title="statement not covered" ></span>throw new V(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`)}</span>}</span>};<span class="cstat-no" title="statement not covered" ></span>if(r&amp;&amp;typeof r=="object")<span class="cstat-no" title="statement not covered" >for(let[i,o]of Object.entries(r))<span class="cstat-no" title="statement not covered" >if(n[i])<span class="cstat-no" title="statement not covered" >n[i](o);e</span>lse <span class="cstat-no" title="statement not covered" >throw new V(`Invalid property ${i} for "log" provided to PrismaClient constructor`)}</span></span></span></span>}</span>,transactionOptions:<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return;l</span></span>et t=<span class="cstat-no" title="statement not covered" >e.maxWait;<span class="cstat-no" title="statement not covered" ></span>if(t!=null&amp;&amp;t&lt;=0)<span class="cstat-no" title="statement not covered" >throw new V(`Invalid value ${t} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);l</span></span>et r=<span class="cstat-no" title="statement not covered" >e.timeout;<span class="cstat-no" title="statement not covered" ></span>if(r!=null&amp;&amp;r&lt;=0)<span class="cstat-no" title="statement not covered" >throw new V(`Invalid value ${r} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`)}</span></span>,omit:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if(typeof e!="object")<span class="cstat-no" title="statement not covered" >throw new V('"omit" option is expected to be an object.');<span class="cstat-no" title="statement not covered" >i</span></span>f(e===null)<span class="cstat-no" title="statement not covered" >throw new V('"omit" option can not be `null`');l</span></span>et r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let[n,i]of Object.entries(e)){let o=<span class="cstat-no" title="statement not covered" >Of(n,t.runtimeDataModel);<span class="cstat-no" title="statement not covered" ></span>if(!o){<span class="cstat-no" title="statement not covered" >r.push({kind:"UnknownModel",modelKey:n});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>f</span>or(let[s,a]of Object.entries(i)){let f=<span class="cstat-no" title="statement not covered" >o.fields.find(<span class="fstat-no" title="function not covered" >w=</span>&gt;<span class="cstat-no" title="statement not covered" >w.name===s)</span>;<span class="cstat-no" title="statement not covered" ></span>if(!f){<span class="cstat-no" title="statement not covered" >r.push({kind:"UnknownField",modelKey:n,fieldName:s});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(f.relationName){<span class="cstat-no" title="statement not covered" >r.push({kind:"RelationInOmit",modelKey:n,fieldName:s});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>t</span>ypeof a!="boolean"&amp;&amp;r.push({kind:"InvalidFieldValue",modelKey:n,fieldName:s})}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r.length&gt;0)<span class="cstat-no" title="statement not covered" >throw new V(Df(e,r))}</span></span>,__internal:<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return;l</span></span>et t=<span class="cstat-no" title="statement not covered" >["debug","engine","configOverride"];<span class="cstat-no" title="statement not covered" ></span>if(typeof e!="object")<span class="cstat-no" title="statement not covered" >throw new V(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);<span class="cstat-no" title="statement not covered" >f</span></span>or(let[r]of Object.entries(e))<span class="cstat-no" title="statement not covered" >if(!t.includes(r)){let n=<span class="cstat-no" title="statement not covered" >Wt(r,t);<span class="cstat-no" title="statement not covered" ></span>throw new V(`Invalid property ${JSON.stringify(r)} for "__internal" provided to PrismaClient constructor.${n}`)}</span>}</span></span>};function <span class="fstat-no" title="function not covered" >zc(</span>e,t){<span class="cstat-no" title="statement not covered" >for(let[r,n]of Object.entries(e)){<span class="cstat-no" title="statement not covered" >if(!Hc.includes(r)){let i=<span class="cstat-no" title="statement not covered" >Wt(r,Hc);<span class="cstat-no" title="statement not covered" ></span>throw new V(`Unknown property ${r} provided to PrismaClient constructor.${i}`)}<span class="cstat-no" title="statement not covered" ></span>I</span>f[r](n,t)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e.datasourceUrl&amp;&amp;e.datasources)<span class="cstat-no" title="statement not covered" >throw new V('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them')}</span></span>function <span class="fstat-no" title="function not covered" >Wt(</span>e,t){<span class="cstat-no" title="statement not covered" >if(t.length===0||typeof e!="string")<span class="cstat-no" title="statement not covered" >return"";l</span></span>et r=<span class="cstat-no" title="statement not covered" >kf(e,t);<span class="cstat-no" title="statement not covered" ></span>return r?` Did you mean "${r}"?`:""}</span>function <span class="fstat-no" title="function not covered" >kf(</span>e,t){<span class="cstat-no" title="statement not covered" >if(t.length===0)<span class="cstat-no" title="statement not covered" >return null;l</span></span>et r=<span class="cstat-no" title="statement not covered" >t.map(<span class="fstat-no" title="function not covered" >i=</span>&gt;(<span class="cstat-no" title="statement not covered" >{value:i,distance:(0,Kc.default)(e,i)})</span>);<span class="cstat-no" title="statement not covered" ></span>r.sort(<span class="fstat-no" title="function not covered" >(i</span>,o)=&gt;<span class="cstat-no" title="statement not covered" >i.distance&lt;o.distance?-1:1)</span>;l</span>et n=<span class="cstat-no" title="statement not covered" >r[0];<span class="cstat-no" title="statement not covered" ></span>return n.distance&lt;3?n.value:null}</span>function <span class="fstat-no" title="function not covered" >Of(</span>e,t){<span class="cstat-no" title="statement not covered" >return Wc(t.models,e)??Wc(t.types,e)}</span>function <span class="fstat-no" title="function not covered" >Wc(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >Object.keys(e).find(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >qe(n)===t)</span>;<span class="cstat-no" title="statement not covered" ></span>if(r)<span class="cstat-no" title="statement not covered" >return e[r]}</span></span>function <span class="fstat-no" title="function not covered" >Df(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >Rt(e);<span class="cstat-no" title="statement not covered" ></span>for(let o of t)<span class="cstat-no" title="statement not covered" >switch(o.kind){case"UnknownModel":<span class="cstat-no" title="statement not covered" >r.arguments.getField(o.modelKey)?.markAsError(),r.addErrorMessage(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >`Unknown model name: ${o.modelKey}.`)</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"UnknownField":<span class="cstat-no" title="statement not covered" >r.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >`Model "${o.modelKey}" does not have a field named "${o.fieldName}".`)</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"RelationInOmit":<span class="cstat-no" title="statement not covered" >r.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >'Relations are already excluded by default and can not be specified in "omit".')</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"InvalidFieldValue":<span class="cstat-no" title="statement not covered" >r.arguments.getDeepFieldValue([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >"Omit field option value must be a boolean.")</span>;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>l</span></span>et{message:n,args:i}=<span class="cstat-no" title="statement not covered" >Pn(r,"colorless");<span class="cstat-no" title="statement not covered" ></span>return`Error validating "omit" option:</span>
&nbsp;
${i}
&nbsp;
${n}`}<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Yc(</span>e){<span class="cstat-no" title="statement not covered" >return e.length===0?Promise.resolve([]):new Promise(<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >new Array(e.length),</span>i=<span class="cstat-no" title="statement not covered" >null,</span>o=<span class="cstat-no" title="statement not covered" >!1,</span>s=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >o||(s++,s===e.length&amp;&amp;(o=!0,i?r(i):t(n)))}</span>,</span>f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >w=</span>&gt;{<span class="cstat-no" title="statement not covered" >o||(o=!0,r(w))}</span>;<span class="cstat-no" title="statement not covered" ></span>for(let w=<span class="cstat-no" title="statement not covered" >0;</span>w&lt;e.length;w++)<span class="cstat-no" title="statement not covered" >e[w].then(<span class="fstat-no" title="function not covered" >A=</span>&gt;{<span class="cstat-no" title="statement not covered" >n[w]=A,a()}</span>,<span class="fstat-no" title="function not covered" >A=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!oi(A)){<span class="cstat-no" title="statement not covered" >f(A);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>A</span>.batchRequestIdx===w?f(A):(i||(i=A),a())}</span>)}</span></span>)}</span>var We=<span class="cstat-no" title="statement not covered" >K("prisma:client");<span class="cstat-no" title="statement not covered" ></span>typeof globalThis=="object"&amp;&amp;(globalThis.NODE_CLIENT=!0);v</span>ar _f=<span class="cstat-no" title="statement not covered" >{requestArgsToMiddlewareArgs:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e,</span>middlewareArgsToRequestArgs:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e}</span>,</span>Mf=<span class="cstat-no" title="statement not covered" >Symbol.for("prisma.client.transaction.id"),</span>Nf=<span class="cstat-no" title="statement not covered" >{id:0,<span class="fstat-no" title="function not covered" >ne</span>xtId(){<span class="cstat-no" title="statement not covered" >return++this.id}</span>};</span>function <span class="fstat-no" title="function not covered" >eu(</span>e){class t{_originalClient=<span class="cstat-no" title="statement not covered" >this;</span>_runtimeDataModel;_requestHandler;_connectionPromise;_disconnectionPromise;_engineConfig;_accelerateEngineConfig;_clientVersion;_errorFormat;_tracingHelper;_previewFeatures;_activeProvider;_globalOmit;_extensions;_engine;_appliedParent;_createPrismaPromise=<span class="cstat-no" title="statement not covered" >Lo();<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(n){<span class="cstat-no" title="statement not covered" >e=n?.__internal?.configOverride?.(e)??e,$a(e),n&amp;&amp;zc(n,e);l</span>et i=<span class="cstat-no" title="statement not covered" >new kn().on("error",<span class="fstat-no" title="function not covered" >()</span>=&gt;{});<span class="cstat-no" title="statement not covered" ></span>this._extensions=Ct.empty(),this._previewFeatures=Cc(e),this._clientVersion=e.clientVersion??Qc,this._activeProvider=e.activeProvider,this._globalOmit=n?.omit,this._tracingHelper=Fc();l</span>et o=<span class="cstat-no" title="statement not covered" >e.relativeEnvPaths&amp;&amp;{rootEnvPath:e.relativeEnvPaths.rootEnvPath&amp;&amp;rn.resolve(e.dirname,e.relativeEnvPaths.rootEnvPath),schemaEnvPath:e.relativeEnvPaths.schemaEnvPath&amp;&amp;rn.resolve(e.dirname,e.relativeEnvPaths.schemaEnvPath)},</span>s;<span class="cstat-no" title="statement not covered" >if(n?.adapter){<span class="cstat-no" title="statement not covered" >s=n.adapter;l</span>et f=<span class="cstat-no" title="statement not covered" >e.activeProvider==="postgresql"||e.activeProvider==="cockroachdb"?"postgres":e.activeProvider;<span class="cstat-no" title="statement not covered" ></span>if(s.provider!==f)<span class="cstat-no" title="statement not covered" >throw new F(`The Driver Adapter \`${s.adapterName}\`, based on \`${s.provider}\`, is not compatible with the provider \`${f}\` specified in the Prisma schema.`,this._clientVersion);<span class="cstat-no" title="statement not covered" >i</span></span>f(n.datasources||n.datasourceUrl!==void 0)<span class="cstat-no" title="statement not covered" >throw new F("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.",this._clientVersion)}</span></span>l</span>et a=<span class="cstat-no" title="statement not covered" >e.injectableEdgeEnv?.();<span class="cstat-no" title="statement not covered" ></span>try{let f=<span class="cstat-no" title="statement not covered" >n??{},</span>w=<span class="cstat-no" title="statement not covered" >f.__internal??{},</span>A=<span class="cstat-no" title="statement not covered" >w.debug===!0;<span class="cstat-no" title="statement not covered" ></span>A&amp;&amp;K.enable("prisma:client");l</span>et R=<span class="cstat-no" title="statement not covered" >rn.resolve(e.dirname,e.relativePath);<span class="cstat-no" title="statement not covered" ></span>fs.existsSync(R)||(R=e.dirname),We("dirname",e.dirname),We("relativePath",e.relativePath),We("cwd",R);l</span>et S=<span class="cstat-no" title="statement not covered" >w.engine||{};<span class="cstat-no" title="statement not covered" ></span>if(f.errorFormat?this._errorFormat=f.errorFormat:g.env.NODE_ENV==="production"?this._errorFormat="minimal":g.env.NO_COLOR?this._errorFormat="colorless":this._errorFormat="colorless",this._runtimeDataModel=e.runtimeDataModel,this._engineConfig={cwd:R,dirname:e.dirname,enableDebugLogs:A,allowTriggerPanic:S.allowTriggerPanic,prismaPath:S.binaryPath??void 0,engineEndpoint:S.endpoint,generator:e.generator,showColors:this._errorFormat==="pretty",logLevel:f.log&amp;&amp;Vc(f.log),logQueries:f.log&amp;&amp;!!(typeof f.log=="string"?f.log==="query":f.log.find(<span class="fstat-no" title="function not covered" >C=</span>&gt;<span class="cstat-no" title="statement not covered" >typeof C=="string"?C==="query":C.level==="query")</span>),env:a?.parsed??{},flags:[],engineWasm:e.engineWasm,compilerWasm:e.compilerWasm,clientVersion:e.clientVersion,engineVersion:e.engineVersion,previewFeatures:this._previewFeatures,activeProvider:e.activeProvider,inlineSchema:e.inlineSchema,overrideDatasources:Va(f,e.datasourceNames),inlineDatasources:e.inlineDatasources,inlineSchemaHash:e.inlineSchemaHash,tracingHelper:this._tracingHelper,transactionOptions:{maxWait:f.transactionOptions?.maxWait??2e3,timeout:f.transactionOptions?.timeout??5e3,isolationLevel:f.transactionOptions?.isolationLevel},logEmitter:i,isBundled:e.isBundled,adapter:s},this._accelerateEngineConfig={...this._engineConfig,accelerateUtils:{resolveDatasourceUrl:qt,getBatchRequestPayload:kt,prismaGraphQLToJSError:_n,PrismaClientUnknownRequestError:ne,PrismaClientInitializationError:F,PrismaClientKnownRequestError:X,debug:K("prisma:client:accelerateEngine"),engineVersion:Xc.version,clientVersion:e.clientVersion}},We("clientVersion",e.clientVersion),this._engine=Rc(e,this._engineConfig),this._requestHandler=new li(this,i),f.log)<span class="cstat-no" title="statement not covered" >for(let C of f.log){let L=<span class="cstat-no" title="statement not covered" >typeof C=="string"?C:C.emit==="stdout"?C.level:null;<span class="cstat-no" title="statement not covered" ></span>L&amp;&amp;this.$on(L,<span class="fstat-no" title="function not covered" >k=</span>&gt;{<span class="cstat-no" title="statement not covered" >tr.log(`${tr.tags[L]??""}`,k.message||k.query)}</span>)}</span>}</span></span>catch(f){<span class="cstat-no" title="statement not covered" >throw f.clientVersion=this._clientVersion,f}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._appliedParent=hr(this)}<span class="fstat-no" title="function not covered" ></span>ge</span>t[Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClient"}<span class="fstat-no" title="function not covered" ></span>$o</span>n(n,i){<span class="cstat-no" title="statement not covered" >return n==="beforeExit"?this._engine.onBeforeExit(i):n&amp;&amp;this._engineConfig.logEmitter.on(n,i),this}<span class="fstat-no" title="function not covered" ></span>$c</span>onnect(){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return this._engine.start()}</span>catch(n){<span class="cstat-no" title="statement not covered" >throw n.clientVersion=this._clientVersion,n}</span>}<span class="fstat-no" title="function not covered" ></span>as</span>ync $disconnect(){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >await this._engine.stop()}</span>catch(n){<span class="cstat-no" title="statement not covered" >throw n.clientVersion=this._clientVersion,n}</span>finally{<span class="cstat-no" title="statement not covered" >ds()}</span>}<span class="fstat-no" title="function not covered" ></span>$e</span>xecuteRawInternal(n,i,o,s){let a=<span class="cstat-no" title="statement not covered" >this._activeProvider;<span class="cstat-no" title="statement not covered" ></span>return this._request({action:"executeRaw",args:o,transaction:n,clientMethod:i,argsMapper:No({clientMethod:i,activeProvider:a}),callsite:je(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}<span class="fstat-no" title="function not covered" ></span>$e</span>xecuteRaw(n,...i){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >o=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(n.raw!==void 0||n.sql!==void 0){let[s,a]=<span class="cstat-no" title="statement not covered" >Zc(n,i);<span class="cstat-no" title="statement not covered" ></span>return Mo(this._activeProvider,s.text,s.values,Array.isArray(n)?"prisma.$executeRaw`&lt;SQL&gt;`":"prisma.$executeRaw(sql`&lt;SQL&gt;`)"),this.$executeRawInternal(o,"$executeRaw",s,a)}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow new ie("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n",{clientVersion:this._clientVersion})}</span>)}<span class="fstat-no" title="function not covered" ></span>$e</span>xecuteRawUnsafe(n,...i){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >o=</span>&gt;(<span class="cstat-no" title="statement not covered" >Mo(this._activeProvider,n,i,"prisma.$executeRawUnsafe(&lt;SQL&gt;, [...values])"),this.$executeRawInternal(o,"$executeRawUnsafe",[n,...i]))</span>)}<span class="fstat-no" title="function not covered" ></span>$r</span>unCommandRaw(n){<span class="cstat-no" title="statement not covered" >if(e.activeProvider!=="mongodb")<span class="cstat-no" title="statement not covered" >throw new ie(`The ${e.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`,{clientVersion:this._clientVersion});<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._createPrismaPromise(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >this._request({args:n,clientMethod:"$runCommandRaw",dataPath:[],action:"runCommandRaw",argsMapper:Sc,callsite:je(this._errorFormat),transaction:i}))</span>}<span class="fstat-no" title="function not covered" ></span>as</span>ync $queryRawInternal(n,i,o,s){let a=<span class="cstat-no" title="statement not covered" >this._activeProvider;<span class="cstat-no" title="statement not covered" ></span>return this._request({action:"queryRaw",args:o,transaction:n,clientMethod:i,argsMapper:No({clientMethod:i,activeProvider:a}),callsite:je(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}<span class="fstat-no" title="function not covered" ></span>$q</span>ueryRaw(n,...i){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >o=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(n.raw!==void 0||n.sql!==void 0)<span class="cstat-no" title="statement not covered" >return this.$queryRawInternal(o,"$queryRaw",...Zc(n,i));<span class="cstat-no" title="statement not covered" >t</span></span>hrow new ie("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n",{clientVersion:this._clientVersion})}</span>)}<span class="fstat-no" title="function not covered" ></span>$q</span>ueryRawTyped(n){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >i=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!this._hasPreviewFlag("typedSql"))<span class="cstat-no" title="statement not covered" >throw new ie("`typedSql` preview feature must be enabled in order to access $queryRawTyped API",{clientVersion:this._clientVersion});<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.$queryRawInternal(i,"$queryRawTyped",n)}</span>)}<span class="fstat-no" title="function not covered" ></span>$q</span>ueryRawUnsafe(n,...i){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >this.$queryRawInternal(o,"$queryRawUnsafe",[n,...i]))</span>}<span class="fstat-no" title="function not covered" ></span>_t</span>ransactionWithArray({promises:n,options:i}){let o=<span class="cstat-no" title="statement not covered" >Nf.nextId(),</span>s=<span class="cstat-no" title="statement not covered" >$c(n.length),</span>a=<span class="cstat-no" title="statement not covered" >n.map(<span class="fstat-no" title="function not covered" >(f</span>,w)=&gt;{<span class="cstat-no" title="statement not covered" >if(f?.[Symbol.toStringTag]!=="PrismaPromise")<span class="cstat-no" title="statement not covered" >throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");l</span></span>et A=<span class="cstat-no" title="statement not covered" >i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel,</span>R=<span class="cstat-no" title="statement not covered" >{kind:"batch",id:o,index:w,isolationLevel:A,lock:s};<span class="cstat-no" title="statement not covered" ></span>return f.requestTransaction?.(R)??f}</span>);<span class="cstat-no" title="statement not covered" ></span>return Yc(a)}<span class="fstat-no" title="function not covered" ></span>as</span>ync _transactionWithCallback({callback:n,options:i}){let o=<span class="cstat-no" title="statement not covered" >{traceparent:this._tracingHelper.getTraceParent()},</span>s=<span class="cstat-no" title="statement not covered" >{maxWait:i?.maxWait??this._engineConfig.transactionOptions.maxWait,timeout:i?.timeout??this._engineConfig.transactionOptions.timeout,isolationLevel:i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel},</span>a=<span class="cstat-no" title="statement not covered" >await this._engine.transaction("start",o,s),</span>f;<span class="cstat-no" title="statement not covered" >try{let w=<span class="cstat-no" title="statement not covered" >{kind:"itx",...a};<span class="cstat-no" title="statement not covered" ></span>f=await n(this._createItxClient(w)),await this._engine.transaction("commit",o,a)}</span>catch(w){<span class="cstat-no" title="statement not covered" >throw await this._engine.transaction("rollback",o,a).catch(<span class="fstat-no" title="function not covered" >()</span>=&gt;{}),w}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn f}<span class="fstat-no" title="function not covered" ></span>_c</span>reateItxClient(n){<span class="cstat-no" title="statement not covered" >return Pe(hr(Pe(va(this),[le("_appliedParent",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this._appliedParent._createItxClient(n))</span>,le("_createPrismaPromise",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Lo(n))</span>,le(Mf,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >n.id)</span>])),[It(Ia)])}<span class="fstat-no" title="function not covered" ></span>$t</span>ransaction(n,i){let o;<span class="cstat-no" title="statement not covered" >typeof n=="function"?this._engineConfig.adapter?.adapterName==="@prisma/adapter-d1"?o=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.")}</span>:o=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this._transactionWithCallback({callback:n,options:i}):</span>o=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this._transactionWithArray({promises:n,options:i});</span>l</span>et s=<span class="cstat-no" title="statement not covered" >{name:"transaction",attributes:{method:"$transaction"}};<span class="cstat-no" title="statement not covered" ></span>return this._tracingHelper.runInChildSpan(s,o)}<span class="fstat-no" title="function not covered" ></span>_r</span>equest(n){<span class="cstat-no" title="statement not covered" >n.otelParentCtx=this._tracingHelper.getActiveContext();l</span>et i=<span class="cstat-no" title="statement not covered" >n.middlewareArgsMapper??_f,</span>o=<span class="cstat-no" title="statement not covered" >{args:i.requestArgsToMiddlewareArgs(n.args),dataPath:n.dataPath,runInTransaction:!!n.transaction,action:n.action,model:n.model},</span>s=<span class="cstat-no" title="statement not covered" >{operation:{name:"operation",attributes:{method:o.action,model:o.model,name:o.model?`${o.model}.${o.action}`:o.action}}},</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >as</span>ync f=&gt;{let{runInTransaction:w,args:A,...R}=<span class="cstat-no" title="statement not covered" >f,</span>S=<span class="cstat-no" title="statement not covered" >{...n,...R};<span class="cstat-no" title="statement not covered" ></span>A&amp;&amp;(S.args=i.middlewareArgsToRequestArgs(A)),n.transaction!==void 0&amp;&amp;w===!1&amp;&amp;delete S.transaction;l</span>et C=<span class="cstat-no" title="statement not covered" >await _a(this,S);<span class="cstat-no" title="statement not covered" ></span>return S.model?Sa({result:C,modelName:S.model,args:S.args,extensions:this._extensions,runtimeDataModel:this._runtimeDataModel,globalOmit:this._globalOmit}):C}</span>;<span class="cstat-no" title="statement not covered" ></span>return this._tracingHelper.runInChildSpan(s.operation,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >a(o))</span>}<span class="fstat-no" title="function not covered" ></span>as</span>ync _executeRequest({args:n,clientMethod:i,dataPath:o,callsite:s,action:a,model:f,argsMapper:w,transaction:A,unpacker:R,otelParentCtx:S,customDataProxyFetch:C}){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >n=w?w(n):n;l</span>et L=<span class="cstat-no" title="statement not covered" >{name:"serialize"},</span>k=<span class="cstat-no" title="statement not covered" >this._tracingHelper.runInChildSpan(L,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Cn({modelName:f,runtimeDataModel:this._runtimeDataModel,action:a,args:n,clientMethod:i,callsite:s,extensions:this._extensions,errorFormat:this._errorFormat,clientVersion:this._clientVersion,previewFeatures:this._previewFeatures,globalOmit:this._globalOmit}))</span>;<span class="cstat-no" title="statement not covered" ></span>return K.enabled("prisma:client")&amp;&amp;(We("Prisma Client call:"),We(`prisma.${i}(${fa(n)})`),We("Generated request:"),We(JSON.stringify(k,null,2)+`</span></span>
`)),A?.kind==="batch"&amp;&amp;await A.lock,this._requestHandler.request({protocolQuery:k,modelName:f,action:a,clientMethod:i,dataPath:o,callsite:s,args:n,extensions:this._extensions,transaction:A,unpacker:R,otelParentCtx:S,otelChildCtx:this._tracingHelper.getActiveContext(),globalOmit:this._globalOmit,customDataProxyFetch:C})}catch(L){<span class="cstat-no" title="statement not covered" >throw L.clientVersion=this._clientVersion,L}</span>}$metrics=<span class="cstat-no" title="statement not covered" >new St(this);<span class="fstat-no" title="function not covered" ></span>_h</span>asPreviewFlag(n){<span class="cstat-no" title="statement not covered" >return!!this._engineConfig.previewFeatures?.includes(n)}<span class="fstat-no" title="function not covered" ></span>$a</span>pplyPendingMigrations(){<span class="cstat-no" title="statement not covered" >return this._engine.applyPendingMigrations()}</span>$extends=<span class="cstat-no" title="statement not covered" >Aa}<span class="cstat-no" title="statement not covered" ></span>return t}</span>function <span class="fstat-no" title="function not covered" >Zc(</span>e,t){<span class="cstat-no" title="statement not covered" >return Lf(e)?[new fe(e,t),Nc]:[e,Lc]}</span>function <span class="fstat-no" title="function not covered" >Lf(</span>e){<span class="cstat-no" title="statement not covered" >return Array.isArray(e)&amp;&amp;Array.isArray(e.raw)}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Uf=<span class="cstat-no" title="statement not covered" >new Set(["toJSON","$$typeof","asymmetricMatch",Symbol.iterator,Symbol.toStringTag,Symbol.isConcatSpreadable,Symbol.toPrimitive]);</span>function <span class="fstat-no" title="function not covered" >tu(</span>e){<span class="cstat-no" title="statement not covered" >return new Proxy(e,{<span class="fstat-no" title="function not covered" >ge</span>t(t,r){<span class="cstat-no" title="statement not covered" >if(r in t)<span class="cstat-no" title="statement not covered" >return t[r];<span class="cstat-no" title="statement not covered" >i</span></span>f(!Uf.has(r))<span class="cstat-no" title="statement not covered" >throw new TypeError(`Invalid enum value: ${String(r)}`)}</span></span>})}<span class="cstat-no" title="statement not covered" ></span>c();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >0</span>&amp;&amp;(module.exports={DMMF,Debug,Decimal,Extensions,MetricsClient,PrismaClientInitializationError,PrismaClientKnownRequestError,PrismaClientRustPanicError,PrismaClientUnknownRequestError,PrismaClientValidationError,Public,Sql,createParam,defineDmmfProperty,deserializeJsonResponse,deserializeRawResult,dmmfToRuntimeDataModel,empty,getPrismaClient,getRuntime,join,makeStrictEnum,makeTypedQueryFactory,objectEnumValues,raw,serializeJsonQuery,skip,sqltag,warnEnvConflicts,warnOnce});</span>
//# sourceMappingURL=wasm-compiler-edge.js.map
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-10-15T12:18:40.068Z
            </div>
        <script src="../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../sorter.js"></script>
        <script src="../../../../block-navigation.js"></script>
    </body>
</html>
    